# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


from typing_extensions import LiteralString
# -- template types.py.jinja --
from typing import TypeVar

import httpx
from .utils import _NoneType



# TODO: filters with aggregates should have their own recursive fields
# TODO: cleanup whitespace control
# TODO: add an argument to signify that the last iteration should be skipped


SortMode = Literal['default', 'insensitive']
SortOrder = Literal['asc', 'desc']

MetricsFormat = Literal['json', 'prometheus']


class _DatasourceOverrideOptional(TypedDict, total=False):
    env: str
    name: str


class DatasourceOverride(_DatasourceOverrideOptional):
    url: str


# NOTE: we don't support some options as their type hints are not publicly exposed
# https://github.com/encode/httpx/discussions/1977
class HttpConfig(TypedDict, total=False):
    app: Callable[[Mapping[str, Any], Any], Any]
    http1: bool
    http2: bool
    limits: httpx.Limits
    timeout: Union[None, float, httpx.Timeout]
    trust_env: bool
    max_redirects: int


# types that can be serialized to json by our query builder
Serializable = Union[
    None,
    bool,
    float,
    int,
    str,
    datetime.datetime,
    List['Serializable'],
    Dict[None, 'Serializable'],
    Dict[bool, 'Serializable'],
    Dict[float, 'Serializable'],
    Dict[int, 'Serializable'],
    Dict[str, 'Serializable'],
]


StringFilter = TypedDict(
    'StringFilter',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilter'],
        'mode': SortMode,
    },
    total=False,
)



class StringWithAggregatesFilter(StringFilter, total=False):
    _max: 'StringFilter'
    _min: 'StringFilter'
    _sum: 'StringFilter'
    _avg: 'StringFilter'
    _count: 'IntFilter'


DateTimeFilter = TypedDict(
    'DateTimeFilter',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilter'],
    },
    total=False,
)



class DateTimeWithAggregatesFilter(DateTimeFilter, total=False):
    _max: 'DateTimeFilter'
    _min: 'DateTimeFilter'
    _sum: 'DateTimeFilter'
    _avg: 'DateTimeFilter'
    _count: 'IntFilter'


BooleanFilter = TypedDict(
    'BooleanFilter',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilter'],
    },
    total=False,
)



class BooleanWithAggregatesFilter(BooleanFilter, total=False):
    _max: 'BooleanFilter'
    _min: 'BooleanFilter'
    _sum: 'BooleanFilter'
    _avg: 'BooleanFilter'
    _count: 'IntFilter'


IntFilter = TypedDict(
    'IntFilter',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilter'],
    },
    total=False,
)



class IntWithAggregatesFilter(IntFilter, total=False):
    _max: 'IntFilter'
    _min: 'IntFilter'
    _sum: 'IntFilter'
    _avg: 'IntFilter'
    _count: 'IntFilter'


BigIntFilter = IntFilter
BigIntWithAggregatesFilter = IntWithAggregatesFilter
FloatFilter = TypedDict(
    'FloatFilter',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilter'],
    },
    total=False,
)



class FloatWithAggregatesFilter(FloatFilter, total=False):
    _max: 'FloatFilter'
    _min: 'FloatFilter'
    _sum: 'FloatFilter'
    _avg: 'FloatFilter'
    _count: 'IntFilter'


BytesFilter = TypedDict(
    'BytesFilter',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilter'],
    },
    total=False,
)



class BytesWithAggregatesFilter(BytesFilter, total=False):
    _max: 'BytesFilter'
    _min: 'BytesFilter'
    _sum: 'BytesFilter'
    _avg: 'BytesFilter'
    _count: 'IntFilter'


# TODO: preview feature for improving JSON filtering
JsonFilter = TypedDict(
    'JsonFilter',
    {
        'equals': 'fields.Json',
        'not': 'fields.Json',
    },
    total=False,
)


class JsonWithAggregatesFilter(JsonFilter, total=False):
    _max: 'JsonFilter'
    _min: 'JsonFilter'
    _sum: 'JsonFilter'
    _avg: 'JsonFilter'
    _count: 'IntFilter'


DecimalFilter = TypedDict(
    'DecimalFilter',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilter'],
    },
    total=False,
)



class DecimalWithAggregatesFilter(StringFilter, total=False):
    _max: 'DecimalFilter'
    _min: 'DecimalFilter'
    _sum: 'DecimalFilter'
    _avg: 'DecimalFilter'
    _count: 'IntFilter'


class _FloatSetInput(TypedDict):
    set: float


class _FloatDivideInput(TypedDict):
    divide: float


class _FloatMultiplyInput(TypedDict):
    multiply: float


class _FloatIncrementInput(TypedDict):
    increment: float


class _FloatDecrementInput(TypedDict):
    decrement: float


class _IntSetInput(TypedDict):
    set: int


class _IntDivideInput(TypedDict):
    divide: int


class _IntMultiplyInput(TypedDict):
    multiply: int


class _IntIncrementInput(TypedDict):
    increment: int


class _IntDecrementInput(TypedDict):
    decrement: int


AtomicFloatInput = Union[
    _FloatSetInput,
    _FloatDivideInput,
    _FloatMultiplyInput,
    _FloatIncrementInput,
    _FloatDecrementInput,
]
AtomicIntInput = Union[
    _IntSetInput,
    _IntDivideInput,
    _IntMultiplyInput,
    _IntIncrementInput,
    _IntDecrementInput,
]
AtomicBigIntInput = AtomicIntInput

class _StringListFilterEqualsInput(TypedDict):
    equals: Optional[List[_str]]


class _StringListFilterHasInput(TypedDict):
    has: _str


class _StringListFilterHasEveryInput(TypedDict):
    has_every: List[_str]


class _StringListFilterHasSomeInput(TypedDict):
    has_some: List[_str]


class _StringListFilterIsEmptyInput(TypedDict):
    is_empty: bool


StringListFilter = Union[
    _StringListFilterHasInput,
    _StringListFilterEqualsInput,
    _StringListFilterHasSomeInput,
    _StringListFilterIsEmptyInput,
    _StringListFilterHasEveryInput,
]


class _StringListUpdateSet(TypedDict):
    set: List[_str]


class _StringListUpdatePush(TypedDict):
    push: List[_str]


StringListUpdate = Union[
    List[_str],
    _StringListUpdateSet,
    _StringListUpdatePush,
]

class _BytesListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Base64']]


class _BytesListFilterHasInput(TypedDict):
    has: 'fields.Base64'


class _BytesListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Base64']


class _BytesListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Base64']


class _BytesListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BytesListFilter = Union[
    _BytesListFilterHasInput,
    _BytesListFilterEqualsInput,
    _BytesListFilterHasSomeInput,
    _BytesListFilterIsEmptyInput,
    _BytesListFilterHasEveryInput,
]


class _BytesListUpdateSet(TypedDict):
    set: List['fields.Base64']


class _BytesListUpdatePush(TypedDict):
    push: List['fields.Base64']


BytesListUpdate = Union[
    List['fields.Base64'],
    _BytesListUpdateSet,
    _BytesListUpdatePush,
]

class _DateTimeListFilterEqualsInput(TypedDict):
    equals: Optional[List[datetime.datetime]]


class _DateTimeListFilterHasInput(TypedDict):
    has: datetime.datetime


class _DateTimeListFilterHasEveryInput(TypedDict):
    has_every: List[datetime.datetime]


class _DateTimeListFilterHasSomeInput(TypedDict):
    has_some: List[datetime.datetime]


class _DateTimeListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DateTimeListFilter = Union[
    _DateTimeListFilterHasInput,
    _DateTimeListFilterEqualsInput,
    _DateTimeListFilterHasSomeInput,
    _DateTimeListFilterIsEmptyInput,
    _DateTimeListFilterHasEveryInput,
]


class _DateTimeListUpdateSet(TypedDict):
    set: List[datetime.datetime]


class _DateTimeListUpdatePush(TypedDict):
    push: List[datetime.datetime]


DateTimeListUpdate = Union[
    List[datetime.datetime],
    _DateTimeListUpdateSet,
    _DateTimeListUpdatePush,
]

class _BooleanListFilterEqualsInput(TypedDict):
    equals: Optional[List[_bool]]


class _BooleanListFilterHasInput(TypedDict):
    has: _bool


class _BooleanListFilterHasEveryInput(TypedDict):
    has_every: List[_bool]


class _BooleanListFilterHasSomeInput(TypedDict):
    has_some: List[_bool]


class _BooleanListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BooleanListFilter = Union[
    _BooleanListFilterHasInput,
    _BooleanListFilterEqualsInput,
    _BooleanListFilterHasSomeInput,
    _BooleanListFilterIsEmptyInput,
    _BooleanListFilterHasEveryInput,
]


class _BooleanListUpdateSet(TypedDict):
    set: List[_bool]


class _BooleanListUpdatePush(TypedDict):
    push: List[_bool]


BooleanListUpdate = Union[
    List[_bool],
    _BooleanListUpdateSet,
    _BooleanListUpdatePush,
]

class _IntListFilterEqualsInput(TypedDict):
    equals: Optional[List[_int]]


class _IntListFilterHasInput(TypedDict):
    has: _int


class _IntListFilterHasEveryInput(TypedDict):
    has_every: List[_int]


class _IntListFilterHasSomeInput(TypedDict):
    has_some: List[_int]


class _IntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


IntListFilter = Union[
    _IntListFilterHasInput,
    _IntListFilterEqualsInput,
    _IntListFilterHasSomeInput,
    _IntListFilterIsEmptyInput,
    _IntListFilterHasEveryInput,
]


class _IntListUpdateSet(TypedDict):
    set: List[_int]


class _IntListUpdatePush(TypedDict):
    push: List[_int]


IntListUpdate = Union[
    List[_int],
    _IntListUpdateSet,
    _IntListUpdatePush,
]

class _BigIntListFilterEqualsInput(TypedDict):
    equals: Optional[List[_int]]


class _BigIntListFilterHasInput(TypedDict):
    has: _int


class _BigIntListFilterHasEveryInput(TypedDict):
    has_every: List[_int]


class _BigIntListFilterHasSomeInput(TypedDict):
    has_some: List[_int]


class _BigIntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BigIntListFilter = Union[
    _BigIntListFilterHasInput,
    _BigIntListFilterEqualsInput,
    _BigIntListFilterHasSomeInput,
    _BigIntListFilterIsEmptyInput,
    _BigIntListFilterHasEveryInput,
]


class _BigIntListUpdateSet(TypedDict):
    set: List[_int]


class _BigIntListUpdatePush(TypedDict):
    push: List[_int]


BigIntListUpdate = Union[
    List[_int],
    _BigIntListUpdateSet,
    _BigIntListUpdatePush,
]

class _FloatListFilterEqualsInput(TypedDict):
    equals: Optional[List[_float]]


class _FloatListFilterHasInput(TypedDict):
    has: _float


class _FloatListFilterHasEveryInput(TypedDict):
    has_every: List[_float]


class _FloatListFilterHasSomeInput(TypedDict):
    has_some: List[_float]


class _FloatListFilterIsEmptyInput(TypedDict):
    is_empty: bool


FloatListFilter = Union[
    _FloatListFilterHasInput,
    _FloatListFilterEqualsInput,
    _FloatListFilterHasSomeInput,
    _FloatListFilterIsEmptyInput,
    _FloatListFilterHasEveryInput,
]


class _FloatListUpdateSet(TypedDict):
    set: List[_float]


class _FloatListUpdatePush(TypedDict):
    push: List[_float]


FloatListUpdate = Union[
    List[_float],
    _FloatListUpdateSet,
    _FloatListUpdatePush,
]

class _JsonListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Json']]


class _JsonListFilterHasInput(TypedDict):
    has: 'fields.Json'


class _JsonListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Json']


class _JsonListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Json']


class _JsonListFilterIsEmptyInput(TypedDict):
    is_empty: bool


JsonListFilter = Union[
    _JsonListFilterHasInput,
    _JsonListFilterEqualsInput,
    _JsonListFilterHasSomeInput,
    _JsonListFilterIsEmptyInput,
    _JsonListFilterHasEveryInput,
]


class _JsonListUpdateSet(TypedDict):
    set: List['fields.Json']


class _JsonListUpdatePush(TypedDict):
    push: List['fields.Json']


JsonListUpdate = Union[
    List['fields.Json'],
    _JsonListUpdateSet,
    _JsonListUpdatePush,
]

class _DecimalListFilterEqualsInput(TypedDict):
    equals: Optional[List[decimal.Decimal]]


class _DecimalListFilterHasInput(TypedDict):
    has: decimal.Decimal


class _DecimalListFilterHasEveryInput(TypedDict):
    has_every: List[decimal.Decimal]


class _DecimalListFilterHasSomeInput(TypedDict):
    has_some: List[decimal.Decimal]


class _DecimalListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DecimalListFilter = Union[
    _DecimalListFilterHasInput,
    _DecimalListFilterEqualsInput,
    _DecimalListFilterHasSomeInput,
    _DecimalListFilterIsEmptyInput,
    _DecimalListFilterHasEveryInput,
]


class _DecimalListUpdateSet(TypedDict):
    set: List[decimal.Decimal]


class _DecimalListUpdatePush(TypedDict):
    push: List[decimal.Decimal]


DecimalListUpdate = Union[
    List[decimal.Decimal],
    _DecimalListUpdateSet,
    _DecimalListUpdatePush,
]

class _CategoryStatusListFilterEqualsInput(TypedDict):
    equals: Optional[List['enums.CategoryStatus']]


class _CategoryStatusListFilterHasInput(TypedDict):
    has: 'enums.CategoryStatus'


class _CategoryStatusListFilterHasEveryInput(TypedDict):
    has_every: List['enums.CategoryStatus']


class _CategoryStatusListFilterHasSomeInput(TypedDict):
    has_some: List['enums.CategoryStatus']


class _CategoryStatusListFilterIsEmptyInput(TypedDict):
    is_empty: bool


CategoryStatusListFilter = Union[
    _CategoryStatusListFilterHasInput,
    _CategoryStatusListFilterEqualsInput,
    _CategoryStatusListFilterHasSomeInput,
    _CategoryStatusListFilterIsEmptyInput,
    _CategoryStatusListFilterHasEveryInput,
]


class _CategoryStatusListUpdateSet(TypedDict):
    set: List['enums.CategoryStatus']


class _CategoryStatusListUpdatePush(TypedDict):
    push: List['enums.CategoryStatus']


CategoryStatusListUpdate = Union[
    List['enums.CategoryStatus'],
    _CategoryStatusListUpdateSet,
    _CategoryStatusListUpdatePush,
]

class _AccountTypeListFilterEqualsInput(TypedDict):
    equals: Optional[List['enums.AccountType']]


class _AccountTypeListFilterHasInput(TypedDict):
    has: 'enums.AccountType'


class _AccountTypeListFilterHasEveryInput(TypedDict):
    has_every: List['enums.AccountType']


class _AccountTypeListFilterHasSomeInput(TypedDict):
    has_some: List['enums.AccountType']


class _AccountTypeListFilterIsEmptyInput(TypedDict):
    is_empty: bool


AccountTypeListFilter = Union[
    _AccountTypeListFilterHasInput,
    _AccountTypeListFilterEqualsInput,
    _AccountTypeListFilterHasSomeInput,
    _AccountTypeListFilterIsEmptyInput,
    _AccountTypeListFilterHasEveryInput,
]


class _AccountTypeListUpdateSet(TypedDict):
    set: List['enums.AccountType']


class _AccountTypeListUpdatePush(TypedDict):
    push: List['enums.AccountType']


AccountTypeListUpdate = Union[
    List['enums.AccountType'],
    _AccountTypeListUpdateSet,
    _AccountTypeListUpdatePush,
]

class _BranchOrderStatusListFilterEqualsInput(TypedDict):
    equals: Optional[List['enums.BranchOrderStatus']]


class _BranchOrderStatusListFilterHasInput(TypedDict):
    has: 'enums.BranchOrderStatus'


class _BranchOrderStatusListFilterHasEveryInput(TypedDict):
    has_every: List['enums.BranchOrderStatus']


class _BranchOrderStatusListFilterHasSomeInput(TypedDict):
    has_some: List['enums.BranchOrderStatus']


class _BranchOrderStatusListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BranchOrderStatusListFilter = Union[
    _BranchOrderStatusListFilterHasInput,
    _BranchOrderStatusListFilterEqualsInput,
    _BranchOrderStatusListFilterHasSomeInput,
    _BranchOrderStatusListFilterIsEmptyInput,
    _BranchOrderStatusListFilterHasEveryInput,
]


class _BranchOrderStatusListUpdateSet(TypedDict):
    set: List['enums.BranchOrderStatus']


class _BranchOrderStatusListUpdatePush(TypedDict):
    push: List['enums.BranchOrderStatus']


BranchOrderStatusListUpdate = Union[
    List['enums.BranchOrderStatus'],
    _BranchOrderStatusListUpdateSet,
    _BranchOrderStatusListUpdatePush,
]

class _EnvironmentListFilterEqualsInput(TypedDict):
    equals: Optional[List['enums.Environment']]


class _EnvironmentListFilterHasInput(TypedDict):
    has: 'enums.Environment'


class _EnvironmentListFilterHasEveryInput(TypedDict):
    has_every: List['enums.Environment']


class _EnvironmentListFilterHasSomeInput(TypedDict):
    has_some: List['enums.Environment']


class _EnvironmentListFilterIsEmptyInput(TypedDict):
    is_empty: bool


EnvironmentListFilter = Union[
    _EnvironmentListFilterHasInput,
    _EnvironmentListFilterEqualsInput,
    _EnvironmentListFilterHasSomeInput,
    _EnvironmentListFilterIsEmptyInput,
    _EnvironmentListFilterHasEveryInput,
]


class _EnvironmentListUpdateSet(TypedDict):
    set: List['enums.Environment']


class _EnvironmentListUpdatePush(TypedDict):
    push: List['enums.Environment']


EnvironmentListUpdate = Union[
    List['enums.Environment'],
    _EnvironmentListUpdateSet,
    _EnvironmentListUpdatePush,
]

class _BackupTypeListFilterEqualsInput(TypedDict):
    equals: Optional[List['enums.BackupType']]


class _BackupTypeListFilterHasInput(TypedDict):
    has: 'enums.BackupType'


class _BackupTypeListFilterHasEveryInput(TypedDict):
    has_every: List['enums.BackupType']


class _BackupTypeListFilterHasSomeInput(TypedDict):
    has_some: List['enums.BackupType']


class _BackupTypeListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BackupTypeListFilter = Union[
    _BackupTypeListFilterHasInput,
    _BackupTypeListFilterEqualsInput,
    _BackupTypeListFilterHasSomeInput,
    _BackupTypeListFilterIsEmptyInput,
    _BackupTypeListFilterHasEveryInput,
]


class _BackupTypeListUpdateSet(TypedDict):
    set: List['enums.BackupType']


class _BackupTypeListUpdatePush(TypedDict):
    push: List['enums.BackupType']


BackupTypeListUpdate = Union[
    List['enums.BackupType'],
    _BackupTypeListUpdateSet,
    _BackupTypeListUpdatePush,
]

class _BackupStatusListFilterEqualsInput(TypedDict):
    equals: Optional[List['enums.BackupStatus']]


class _BackupStatusListFilterHasInput(TypedDict):
    has: 'enums.BackupStatus'


class _BackupStatusListFilterHasEveryInput(TypedDict):
    has_every: List['enums.BackupStatus']


class _BackupStatusListFilterHasSomeInput(TypedDict):
    has_some: List['enums.BackupStatus']


class _BackupStatusListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BackupStatusListFilter = Union[
    _BackupStatusListFilterHasInput,
    _BackupStatusListFilterEqualsInput,
    _BackupStatusListFilterHasSomeInput,
    _BackupStatusListFilterIsEmptyInput,
    _BackupStatusListFilterHasEveryInput,
]


class _BackupStatusListUpdateSet(TypedDict):
    set: List['enums.BackupStatus']


class _BackupStatusListUpdatePush(TypedDict):
    push: List['enums.BackupStatus']


BackupStatusListUpdate = Union[
    List['enums.BackupStatus'],
    _BackupStatusListUpdateSet,
    _BackupStatusListUpdatePush,
]

class _RoleListFilterEqualsInput(TypedDict):
    equals: Optional[List['enums.Role']]


class _RoleListFilterHasInput(TypedDict):
    has: 'enums.Role'


class _RoleListFilterHasEveryInput(TypedDict):
    has_every: List['enums.Role']


class _RoleListFilterHasSomeInput(TypedDict):
    has_some: List['enums.Role']


class _RoleListFilterIsEmptyInput(TypedDict):
    is_empty: bool


RoleListFilter = Union[
    _RoleListFilterHasInput,
    _RoleListFilterEqualsInput,
    _RoleListFilterHasSomeInput,
    _RoleListFilterIsEmptyInput,
    _RoleListFilterHasEveryInput,
]


class _RoleListUpdateSet(TypedDict):
    set: List['enums.Role']


class _RoleListUpdatePush(TypedDict):
    push: List['enums.Role']


RoleListUpdate = Union[
    List['enums.Role'],
    _RoleListUpdateSet,
    _RoleListUpdatePush,
]

class _AuditActionListFilterEqualsInput(TypedDict):
    equals: Optional[List['enums.AuditAction']]


class _AuditActionListFilterHasInput(TypedDict):
    has: 'enums.AuditAction'


class _AuditActionListFilterHasEveryInput(TypedDict):
    has_every: List['enums.AuditAction']


class _AuditActionListFilterHasSomeInput(TypedDict):
    has_some: List['enums.AuditAction']


class _AuditActionListFilterIsEmptyInput(TypedDict):
    is_empty: bool


AuditActionListFilter = Union[
    _AuditActionListFilterHasInput,
    _AuditActionListFilterEqualsInput,
    _AuditActionListFilterHasSomeInput,
    _AuditActionListFilterIsEmptyInput,
    _AuditActionListFilterHasEveryInput,
]


class _AuditActionListUpdateSet(TypedDict):
    set: List['enums.AuditAction']


class _AuditActionListUpdatePush(TypedDict):
    push: List['enums.AuditAction']


AuditActionListUpdate = Union[
    List['enums.AuditAction'],
    _AuditActionListUpdateSet,
    _AuditActionListUpdatePush,
]

class _PaymentTypeListFilterEqualsInput(TypedDict):
    equals: Optional[List['enums.PaymentType']]


class _PaymentTypeListFilterHasInput(TypedDict):
    has: 'enums.PaymentType'


class _PaymentTypeListFilterHasEveryInput(TypedDict):
    has_every: List['enums.PaymentType']


class _PaymentTypeListFilterHasSomeInput(TypedDict):
    has_some: List['enums.PaymentType']


class _PaymentTypeListFilterIsEmptyInput(TypedDict):
    is_empty: bool


PaymentTypeListFilter = Union[
    _PaymentTypeListFilterHasInput,
    _PaymentTypeListFilterEqualsInput,
    _PaymentTypeListFilterHasSomeInput,
    _PaymentTypeListFilterIsEmptyInput,
    _PaymentTypeListFilterHasEveryInput,
]


class _PaymentTypeListUpdateSet(TypedDict):
    set: List['enums.PaymentType']


class _PaymentTypeListUpdatePush(TypedDict):
    push: List['enums.PaymentType']


PaymentTypeListUpdate = Union[
    List['enums.PaymentType'],
    _PaymentTypeListUpdateSet,
    _PaymentTypeListUpdatePush,
]

class _TransferStatusListFilterEqualsInput(TypedDict):
    equals: Optional[List['enums.TransferStatus']]


class _TransferStatusListFilterHasInput(TypedDict):
    has: 'enums.TransferStatus'


class _TransferStatusListFilterHasEveryInput(TypedDict):
    has_every: List['enums.TransferStatus']


class _TransferStatusListFilterHasSomeInput(TypedDict):
    has_some: List['enums.TransferStatus']


class _TransferStatusListFilterIsEmptyInput(TypedDict):
    is_empty: bool


TransferStatusListFilter = Union[
    _TransferStatusListFilterHasInput,
    _TransferStatusListFilterEqualsInput,
    _TransferStatusListFilterHasSomeInput,
    _TransferStatusListFilterIsEmptyInput,
    _TransferStatusListFilterHasEveryInput,
]


class _TransferStatusListUpdateSet(TypedDict):
    set: List['enums.TransferStatus']


class _TransferStatusListUpdatePush(TypedDict):
    push: List['enums.TransferStatus']


TransferStatusListUpdate = Union[
    List['enums.TransferStatus'],
    _TransferStatusListUpdateSet,
    _TransferStatusListUpdatePush,
]

class _ReturnStatusListFilterEqualsInput(TypedDict):
    equals: Optional[List['enums.ReturnStatus']]


class _ReturnStatusListFilterHasInput(TypedDict):
    has: 'enums.ReturnStatus'


class _ReturnStatusListFilterHasEveryInput(TypedDict):
    has_every: List['enums.ReturnStatus']


class _ReturnStatusListFilterHasSomeInput(TypedDict):
    has_some: List['enums.ReturnStatus']


class _ReturnStatusListFilterIsEmptyInput(TypedDict):
    is_empty: bool


ReturnStatusListFilter = Union[
    _ReturnStatusListFilterHasInput,
    _ReturnStatusListFilterEqualsInput,
    _ReturnStatusListFilterHasSomeInput,
    _ReturnStatusListFilterIsEmptyInput,
    _ReturnStatusListFilterHasEveryInput,
]


class _ReturnStatusListUpdateSet(TypedDict):
    set: List['enums.ReturnStatus']


class _ReturnStatusListUpdatePush(TypedDict):
    push: List['enums.ReturnStatus']


ReturnStatusListUpdate = Union[
    List['enums.ReturnStatus'],
    _ReturnStatusListUpdateSet,
    _ReturnStatusListUpdatePush,
]

class _ReturnTypeListFilterEqualsInput(TypedDict):
    equals: Optional[List['enums.ReturnType']]


class _ReturnTypeListFilterHasInput(TypedDict):
    has: 'enums.ReturnType'


class _ReturnTypeListFilterHasEveryInput(TypedDict):
    has_every: List['enums.ReturnType']


class _ReturnTypeListFilterHasSomeInput(TypedDict):
    has_some: List['enums.ReturnType']


class _ReturnTypeListFilterIsEmptyInput(TypedDict):
    is_empty: bool


ReturnTypeListFilter = Union[
    _ReturnTypeListFilterHasInput,
    _ReturnTypeListFilterEqualsInput,
    _ReturnTypeListFilterHasSomeInput,
    _ReturnTypeListFilterIsEmptyInput,
    _ReturnTypeListFilterHasEveryInput,
]


class _ReturnTypeListUpdateSet(TypedDict):
    set: List['enums.ReturnType']


class _ReturnTypeListUpdatePush(TypedDict):
    push: List['enums.ReturnType']


ReturnTypeListUpdate = Union[
    List['enums.ReturnType'],
    _ReturnTypeListUpdateSet,
    _ReturnTypeListUpdatePush,
]

class _CurrencyListFilterEqualsInput(TypedDict):
    equals: Optional[List['enums.Currency']]


class _CurrencyListFilterHasInput(TypedDict):
    has: 'enums.Currency'


class _CurrencyListFilterHasEveryInput(TypedDict):
    has_every: List['enums.Currency']


class _CurrencyListFilterHasSomeInput(TypedDict):
    has_some: List['enums.Currency']


class _CurrencyListFilterIsEmptyInput(TypedDict):
    is_empty: bool


CurrencyListFilter = Union[
    _CurrencyListFilterHasInput,
    _CurrencyListFilterEqualsInput,
    _CurrencyListFilterHasSomeInput,
    _CurrencyListFilterIsEmptyInput,
    _CurrencyListFilterHasEveryInput,
]


class _CurrencyListUpdateSet(TypedDict):
    set: List['enums.Currency']


class _CurrencyListUpdatePush(TypedDict):
    push: List['enums.Currency']


CurrencyListUpdate = Union[
    List['enums.Currency'],
    _CurrencyListUpdateSet,
    _CurrencyListUpdatePush,
]

class _CustomerTypeListFilterEqualsInput(TypedDict):
    equals: Optional[List['enums.CustomerType']]


class _CustomerTypeListFilterHasInput(TypedDict):
    has: 'enums.CustomerType'


class _CustomerTypeListFilterHasEveryInput(TypedDict):
    has_every: List['enums.CustomerType']


class _CustomerTypeListFilterHasSomeInput(TypedDict):
    has_some: List['enums.CustomerType']


class _CustomerTypeListFilterIsEmptyInput(TypedDict):
    is_empty: bool


CustomerTypeListFilter = Union[
    _CustomerTypeListFilterHasInput,
    _CustomerTypeListFilterEqualsInput,
    _CustomerTypeListFilterHasSomeInput,
    _CustomerTypeListFilterIsEmptyInput,
    _CustomerTypeListFilterHasEveryInput,
]


class _CustomerTypeListUpdateSet(TypedDict):
    set: List['enums.CustomerType']


class _CustomerTypeListUpdatePush(TypedDict):
    push: List['enums.CustomerType']


CustomerTypeListUpdate = Union[
    List['enums.CustomerType'],
    _CustomerTypeListUpdateSet,
    _CustomerTypeListUpdatePush,
]

class _CustomerStatusListFilterEqualsInput(TypedDict):
    equals: Optional[List['enums.CustomerStatus']]


class _CustomerStatusListFilterHasInput(TypedDict):
    has: 'enums.CustomerStatus'


class _CustomerStatusListFilterHasEveryInput(TypedDict):
    has_every: List['enums.CustomerStatus']


class _CustomerStatusListFilterHasSomeInput(TypedDict):
    has_some: List['enums.CustomerStatus']


class _CustomerStatusListFilterIsEmptyInput(TypedDict):
    is_empty: bool


CustomerStatusListFilter = Union[
    _CustomerStatusListFilterHasInput,
    _CustomerStatusListFilterEqualsInput,
    _CustomerStatusListFilterHasSomeInput,
    _CustomerStatusListFilterIsEmptyInput,
    _CustomerStatusListFilterHasEveryInput,
]


class _CustomerStatusListUpdateSet(TypedDict):
    set: List['enums.CustomerStatus']


class _CustomerStatusListUpdatePush(TypedDict):
    push: List['enums.CustomerStatus']


CustomerStatusListUpdate = Union[
    List['enums.CustomerStatus'],
    _CustomerStatusListUpdateSet,
    _CustomerStatusListUpdatePush,
]

class _AuditSeverityListFilterEqualsInput(TypedDict):
    equals: Optional[List['enums.AuditSeverity']]


class _AuditSeverityListFilterHasInput(TypedDict):
    has: 'enums.AuditSeverity'


class _AuditSeverityListFilterHasEveryInput(TypedDict):
    has_every: List['enums.AuditSeverity']


class _AuditSeverityListFilterHasSomeInput(TypedDict):
    has_some: List['enums.AuditSeverity']


class _AuditSeverityListFilterIsEmptyInput(TypedDict):
    is_empty: bool


AuditSeverityListFilter = Union[
    _AuditSeverityListFilterHasInput,
    _AuditSeverityListFilterEqualsInput,
    _AuditSeverityListFilterHasSomeInput,
    _AuditSeverityListFilterIsEmptyInput,
    _AuditSeverityListFilterHasEveryInput,
]


class _AuditSeverityListUpdateSet(TypedDict):
    set: List['enums.AuditSeverity']


class _AuditSeverityListUpdatePush(TypedDict):
    push: List['enums.AuditSeverity']


AuditSeverityListUpdate = Union[
    List['enums.AuditSeverity'],
    _AuditSeverityListUpdateSet,
    _AuditSeverityListUpdatePush,
]

class _DebitCreditListFilterEqualsInput(TypedDict):
    equals: Optional[List['enums.DebitCredit']]


class _DebitCreditListFilterHasInput(TypedDict):
    has: 'enums.DebitCredit'


class _DebitCreditListFilterHasEveryInput(TypedDict):
    has_every: List['enums.DebitCredit']


class _DebitCreditListFilterHasSomeInput(TypedDict):
    has_some: List['enums.DebitCredit']


class _DebitCreditListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DebitCreditListFilter = Union[
    _DebitCreditListFilterHasInput,
    _DebitCreditListFilterEqualsInput,
    _DebitCreditListFilterHasSomeInput,
    _DebitCreditListFilterIsEmptyInput,
    _DebitCreditListFilterHasEveryInput,
]


class _DebitCreditListUpdateSet(TypedDict):
    set: List['enums.DebitCredit']


class _DebitCreditListUpdatePush(TypedDict):
    push: List['enums.DebitCredit']


DebitCreditListUpdate = Union[
    List['enums.DebitCredit'],
    _DebitCreditListUpdateSet,
    _DebitCreditListUpdatePush,
]

class _AdjustmentTypeListFilterEqualsInput(TypedDict):
    equals: Optional[List['enums.AdjustmentType']]


class _AdjustmentTypeListFilterHasInput(TypedDict):
    has: 'enums.AdjustmentType'


class _AdjustmentTypeListFilterHasEveryInput(TypedDict):
    has_every: List['enums.AdjustmentType']


class _AdjustmentTypeListFilterHasSomeInput(TypedDict):
    has_some: List['enums.AdjustmentType']


class _AdjustmentTypeListFilterIsEmptyInput(TypedDict):
    is_empty: bool


AdjustmentTypeListFilter = Union[
    _AdjustmentTypeListFilterHasInput,
    _AdjustmentTypeListFilterEqualsInput,
    _AdjustmentTypeListFilterHasSomeInput,
    _AdjustmentTypeListFilterIsEmptyInput,
    _AdjustmentTypeListFilterHasEveryInput,
]


class _AdjustmentTypeListUpdateSet(TypedDict):
    set: List['enums.AdjustmentType']


class _AdjustmentTypeListUpdatePush(TypedDict):
    push: List['enums.AdjustmentType']


AdjustmentTypeListUpdate = Union[
    List['enums.AdjustmentType'],
    _AdjustmentTypeListUpdateSet,
    _AdjustmentTypeListUpdatePush,
]

class _AdjustmentReasonListFilterEqualsInput(TypedDict):
    equals: Optional[List['enums.AdjustmentReason']]


class _AdjustmentReasonListFilterHasInput(TypedDict):
    has: 'enums.AdjustmentReason'


class _AdjustmentReasonListFilterHasEveryInput(TypedDict):
    has_every: List['enums.AdjustmentReason']


class _AdjustmentReasonListFilterHasSomeInput(TypedDict):
    has_some: List['enums.AdjustmentReason']


class _AdjustmentReasonListFilterIsEmptyInput(TypedDict):
    is_empty: bool


AdjustmentReasonListFilter = Union[
    _AdjustmentReasonListFilterHasInput,
    _AdjustmentReasonListFilterEqualsInput,
    _AdjustmentReasonListFilterHasSomeInput,
    _AdjustmentReasonListFilterIsEmptyInput,
    _AdjustmentReasonListFilterHasEveryInput,
]


class _AdjustmentReasonListUpdateSet(TypedDict):
    set: List['enums.AdjustmentReason']


class _AdjustmentReasonListUpdatePush(TypedDict):
    push: List['enums.AdjustmentReason']


AdjustmentReasonListUpdate = Union[
    List['enums.AdjustmentReason'],
    _AdjustmentReasonListUpdateSet,
    _AdjustmentReasonListUpdatePush,
]


# User types

class UserOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the User create method"""
    id: _int
    email: Optional[_str]
    role: 'enums.Role'
    isActive: _bool
    branchId: Optional[_int]
    branch: 'BranchCreateNestedWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    auditLogs: 'AuditLogCreateManyNestedWithoutRelationsInput'
    permissions: 'UserPermissionCreateManyNestedWithoutRelationsInput'
    notifications: 'NotificationCreateManyNestedWithoutRelationsInput'
    revokedTokens: 'RevokedTokenCreateManyNestedWithoutRelationsInput'
    stockAdjustments: 'StockAdjustmentCreateManyNestedWithoutRelationsInput'
    Sale: 'SaleCreateManyNestedWithoutRelationsInput'
    deletedSales: 'SaleCreateManyNestedWithoutRelationsInput'
    Payment: 'PaymentCreateManyNestedWithoutRelationsInput'
    Backup: 'BackupCreateManyNestedWithoutRelationsInput'
    requestedOrders: 'BranchOrderCreateManyNestedWithoutRelationsInput'
    approvedOrders: 'BranchOrderCreateManyNestedWithoutRelationsInput'
    sentOrders: 'BranchOrderCreateManyNestedWithoutRelationsInput'
    receivedOrders: 'BranchOrderCreateManyNestedWithoutRelationsInput'


class UserCreateInput(UserOptionalCreateInput):
    """Required arguments to the User create method"""
    username: _str
    firstName: _str
    lastName: _str
    hashedPassword: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class UserOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the User create method, without relations"""
    id: _int
    email: Optional[_str]
    role: 'enums.Role'
    isActive: _bool
    branchId: Optional[_int]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class UserCreateWithoutRelationsInput(UserOptionalCreateWithoutRelationsInput):
    """Required arguments to the User create method, without relations"""
    username: _str
    firstName: _str
    lastName: _str
    hashedPassword: _str


class UserCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'UserCreateWithoutRelationsInput'
    connect: 'UserWhereUniqueInput'


class UserCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['UserCreateWithoutRelationsInput', List['UserCreateWithoutRelationsInput']]
    connect: Union['UserWhereUniqueInput', List['UserWhereUniqueInput']]


_UserWhereUnique_id_Input = TypedDict(
    '_UserWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

_UserWhereUnique_username_Input = TypedDict(
    '_UserWhereUnique_username_Input',
    {
        'username': '_str',
    },
    total=True
)

_UserWhereUnique_email_Input = TypedDict(
    '_UserWhereUnique_email_Input',
    {
        'email': '_str',
    },
    total=True
)

UserWhereUniqueInput = Union[
    '_UserWhereUnique_id_Input',
    '_UserWhereUnique_username_Input',
    '_UserWhereUnique_email_Input',
]


class UserUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    username: _str
    email: Optional[_str]
    firstName: _str
    lastName: _str
    hashedPassword: _str
    role: 'enums.Role'
    isActive: _bool
    branch: 'BranchUpdateOneWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    auditLogs: 'AuditLogUpdateManyWithoutRelationsInput'
    permissions: 'UserPermissionUpdateManyWithoutRelationsInput'
    notifications: 'NotificationUpdateManyWithoutRelationsInput'
    revokedTokens: 'RevokedTokenUpdateManyWithoutRelationsInput'
    stockAdjustments: 'StockAdjustmentUpdateManyWithoutRelationsInput'
    Sale: 'SaleUpdateManyWithoutRelationsInput'
    deletedSales: 'SaleUpdateManyWithoutRelationsInput'
    Payment: 'PaymentUpdateManyWithoutRelationsInput'
    Backup: 'BackupUpdateManyWithoutRelationsInput'
    requestedOrders: 'BranchOrderUpdateManyWithoutRelationsInput'
    approvedOrders: 'BranchOrderUpdateManyWithoutRelationsInput'
    sentOrders: 'BranchOrderUpdateManyWithoutRelationsInput'
    receivedOrders: 'BranchOrderUpdateManyWithoutRelationsInput'


class UserUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    username: _str
    email: Optional[_str]
    firstName: _str
    lastName: _str
    hashedPassword: _str
    role: 'enums.Role'
    isActive: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class UserUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['UserCreateWithoutRelationsInput']
    connect: List['UserWhereUniqueInput']
    set: List['UserWhereUniqueInput']
    disconnect: List['UserWhereUniqueInput']
    delete: List['UserWhereUniqueInput']

    # TODO
    # update: List['UserUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['UserUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['UserScalarWhereInput']
    # upsert: List['UserUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['UserCreateOrConnectWithoutRelationsInput']


class UserUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'UserCreateWithoutRelationsInput'
    connect: 'UserWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'UserUpdateInput'
    # upsert: 'UserUpsertWithoutRelationsInput'
    # connectOrCreate: 'UserCreateOrConnectWithoutRelationsInput'


class UserUpsertInput(TypedDict):
    create: 'UserCreateInput'
    update: 'UserUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_User_id_OrderByInput = TypedDict(
    '_User_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_User_username_OrderByInput = TypedDict(
    '_User_username_OrderByInput',
    {
        'username': 'SortOrder',
    },
    total=True
)

_User_email_OrderByInput = TypedDict(
    '_User_email_OrderByInput',
    {
        'email': 'SortOrder',
    },
    total=True
)

_User_firstName_OrderByInput = TypedDict(
    '_User_firstName_OrderByInput',
    {
        'firstName': 'SortOrder',
    },
    total=True
)

_User_lastName_OrderByInput = TypedDict(
    '_User_lastName_OrderByInput',
    {
        'lastName': 'SortOrder',
    },
    total=True
)

_User_hashedPassword_OrderByInput = TypedDict(
    '_User_hashedPassword_OrderByInput',
    {
        'hashedPassword': 'SortOrder',
    },
    total=True
)

_User_role_OrderByInput = TypedDict(
    '_User_role_OrderByInput',
    {
        'role': 'SortOrder',
    },
    total=True
)

_User_isActive_OrderByInput = TypedDict(
    '_User_isActive_OrderByInput',
    {
        'isActive': 'SortOrder',
    },
    total=True
)

_User_branchId_OrderByInput = TypedDict(
    '_User_branchId_OrderByInput',
    {
        'branchId': 'SortOrder',
    },
    total=True
)

_User_createdAt_OrderByInput = TypedDict(
    '_User_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_User_updatedAt_OrderByInput = TypedDict(
    '_User_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

UserOrderByInput = Union[
    '_User_id_OrderByInput',
    '_User_username_OrderByInput',
    '_User_email_OrderByInput',
    '_User_firstName_OrderByInput',
    '_User_lastName_OrderByInput',
    '_User_hashedPassword_OrderByInput',
    '_User_role_OrderByInput',
    '_User_isActive_OrderByInput',
    '_User_branchId_OrderByInput',
    '_User_createdAt_OrderByInput',
    '_User_updatedAt_OrderByInput',
]



# recursive User types
# TODO: cleanup these types



UserRelationFilter = TypedDict(
    'UserRelationFilter',
    {
        'is': 'UserWhereInput',
        'is_not': 'UserWhereInput',
    },
    total=False,
)


class UserListRelationFilter(TypedDict, total=False):
    some: 'UserWhereInput'
    none: 'UserWhereInput'
    every: 'UserWhereInput'


class UserInclude(TypedDict, total=False):
    """User relational arguments"""
    branch: Union[bool, 'BranchArgsFromUser']
    auditLogs: Union[bool, 'FindManyAuditLogArgsFromUser']
    permissions: Union[bool, 'FindManyUserPermissionArgsFromUser']
    notifications: Union[bool, 'FindManyNotificationArgsFromUser']
    revokedTokens: Union[bool, 'FindManyRevokedTokenArgsFromUser']
    stockAdjustments: Union[bool, 'FindManyStockAdjustmentArgsFromUser']
    Sale: Union[bool, 'FindManySaleArgsFromUser']
    deletedSales: Union[bool, 'FindManySaleArgsFromUser']
    Payment: Union[bool, 'FindManyPaymentArgsFromUser']
    Backup: Union[bool, 'FindManyBackupArgsFromUser']
    requestedOrders: Union[bool, 'FindManyBranchOrderArgsFromUser']
    approvedOrders: Union[bool, 'FindManyBranchOrderArgsFromUser']
    sentOrders: Union[bool, 'FindManyBranchOrderArgsFromUser']
    receivedOrders: Union[bool, 'FindManyBranchOrderArgsFromUser']


class UserIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    branch: Union[bool, 'BranchArgsFromUser']
    auditLogs: Union[bool, 'FindManyAuditLogArgsFromUser']
    permissions: Union[bool, 'FindManyUserPermissionArgsFromUser']
    notifications: Union[bool, 'FindManyNotificationArgsFromUser']
    revokedTokens: Union[bool, 'FindManyRevokedTokenArgsFromUser']
    stockAdjustments: Union[bool, 'FindManyStockAdjustmentArgsFromUser']
    Sale: Union[bool, 'FindManySaleArgsFromUser']
    deletedSales: Union[bool, 'FindManySaleArgsFromUser']
    Payment: Union[bool, 'FindManyPaymentArgsFromUser']
    Backup: Union[bool, 'FindManyBackupArgsFromUser']
    requestedOrders: Union[bool, 'FindManyBranchOrderArgsFromUser']
    approvedOrders: Union[bool, 'FindManyBranchOrderArgsFromUser']
    sentOrders: Union[bool, 'FindManyBranchOrderArgsFromUser']
    receivedOrders: Union[bool, 'FindManyBranchOrderArgsFromUser']


class UserArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class UserPermissionIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUser']


class UserPermissionArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'UserPermissionIncludeFromUserPermission'


class FindManyUserPermissionArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['UserPermissionOrderByInput', List['UserPermissionOrderByInput']]
    where: 'UserPermissionWhereInput'
    cursor: 'UserPermissionWhereUniqueInput'
    distinct: List['UserPermissionScalarFieldKeys']
    include: 'UserPermissionIncludeFromUserPermission'


class BranchIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    users: Union[bool, 'FindManyUserArgsFromUser']
    Sale: Union[bool, 'FindManySaleArgsFromUser']
    Account: Union[bool, 'FindManyAccountArgsFromUser']
    BranchOrder: Union[bool, 'FindManyBranchOrderArgsFromUser']


class BranchArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'BranchIncludeFromBranch'


class FindManyBranchArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['BranchOrderByInput', List['BranchOrderByInput']]
    where: 'BranchWhereInput'
    cursor: 'BranchWhereUniqueInput'
    distinct: List['BranchScalarFieldKeys']
    include: 'BranchIncludeFromBranch'


class ProductIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    category: Union[bool, 'CategoryArgsFromUser']
    stocks: Union[bool, 'FindManyStockArgsFromUser']
    stockAdjustments: Union[bool, 'FindManyStockAdjustmentArgsFromUser']


class ProductArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'ProductIncludeFromProduct'


class FindManyProductArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProduct'


class CategoryIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    products: Union[bool, 'FindManyProductArgsFromUser']


class CategoryArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'CategoryIncludeFromCategory'


class FindManyCategoryArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['CategoryOrderByInput', List['CategoryOrderByInput']]
    where: 'CategoryWhereInput'
    cursor: 'CategoryWhereUniqueInput'
    distinct: List['CategoryScalarFieldKeys']
    include: 'CategoryIncludeFromCategory'


class StockIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    product: Union[bool, 'ProductArgsFromUser']
    SaleItem: Union[bool, 'FindManySaleItemArgsFromUser']
    BranchOrderItem: Union[bool, 'FindManyBranchOrderItemArgsFromUser']


class StockArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'StockIncludeFromStock'


class FindManyStockArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['StockOrderByInput', List['StockOrderByInput']]
    where: 'StockWhereInput'
    cursor: 'StockWhereUniqueInput'
    distinct: List['StockScalarFieldKeys']
    include: 'StockIncludeFromStock'


class CustomerIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    Sale: Union[bool, 'FindManySaleArgsFromUser']


class CustomerArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'CustomerIncludeFromCustomer'


class FindManyCustomerArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['CustomerOrderByInput', List['CustomerOrderByInput']]
    where: 'CustomerWhereInput'
    cursor: 'CustomerWhereUniqueInput'
    distinct: List['CustomerScalarFieldKeys']
    include: 'CustomerIncludeFromCustomer'


class SaleIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    branch: Union[bool, 'BranchArgsFromUser']
    customer: Union[bool, 'CustomerArgsFromUser']
    user: Union[bool, 'UserArgsFromUser']
    items: Union[bool, 'FindManySaleItemArgsFromUser']
    payments: Union[bool, 'FindManyPaymentArgsFromUser']
    returns: Union[bool, 'FindManyReturnSaleArgsFromUser']
    deletedBy: Union[bool, 'UserArgsFromUser']


class SaleArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'SaleIncludeFromSale'


class FindManySaleArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['SaleOrderByInput', List['SaleOrderByInput']]
    where: 'SaleWhereInput'
    cursor: 'SaleWhereUniqueInput'
    distinct: List['SaleScalarFieldKeys']
    include: 'SaleIncludeFromSale'


class SaleItemIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    sale: Union[bool, 'SaleArgsFromUser']
    stock: Union[bool, 'StockArgsFromUser']
    ReturnItem: Union[bool, 'FindManyReturnItemArgsFromUser']


class SaleItemArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'SaleItemIncludeFromSaleItem'


class FindManySaleItemArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['SaleItemOrderByInput', List['SaleItemOrderByInput']]
    where: 'SaleItemWhereInput'
    cursor: 'SaleItemWhereUniqueInput'
    distinct: List['SaleItemScalarFieldKeys']
    include: 'SaleItemIncludeFromSaleItem'


class ReturnSaleIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    original: Union[bool, 'SaleArgsFromUser']
    items: Union[bool, 'FindManyReturnItemArgsFromUser']
    refund: Union[bool, 'FindManyPaymentArgsFromUser']


class ReturnSaleArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'ReturnSaleIncludeFromReturnSale'


class FindManyReturnSaleArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['ReturnSaleOrderByInput', List['ReturnSaleOrderByInput']]
    where: 'ReturnSaleWhereInput'
    cursor: 'ReturnSaleWhereUniqueInput'
    distinct: List['ReturnSaleScalarFieldKeys']
    include: 'ReturnSaleIncludeFromReturnSale'


class ReturnItemIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    returnSale: Union[bool, 'ReturnSaleArgsFromUser']
    saleItem: Union[bool, 'SaleItemArgsFromUser']


class ReturnItemArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'ReturnItemIncludeFromReturnItem'


class FindManyReturnItemArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['ReturnItemOrderByInput', List['ReturnItemOrderByInput']]
    where: 'ReturnItemWhereInput'
    cursor: 'ReturnItemWhereUniqueInput'
    distinct: List['ReturnItemScalarFieldKeys']
    include: 'ReturnItemIncludeFromReturnItem'


class PaymentIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    sale: Union[bool, 'SaleArgsFromUser']
    account: Union[bool, 'AccountArgsFromUser']
    returnSale: Union[bool, 'ReturnSaleArgsFromUser']
    user: Union[bool, 'UserArgsFromUser']


class PaymentArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'PaymentIncludeFromPayment'


class FindManyPaymentArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['PaymentOrderByInput', List['PaymentOrderByInput']]
    where: 'PaymentWhereInput'
    cursor: 'PaymentWhereUniqueInput'
    distinct: List['PaymentScalarFieldKeys']
    include: 'PaymentIncludeFromPayment'


class JournalEntryIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    lines: Union[bool, 'FindManyJournalEntryLineArgsFromUser']


class JournalEntryArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'JournalEntryIncludeFromJournalEntry'


class FindManyJournalEntryArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['JournalEntryOrderByInput', List['JournalEntryOrderByInput']]
    where: 'JournalEntryWhereInput'
    cursor: 'JournalEntryWhereUniqueInput'
    distinct: List['JournalEntryScalarFieldKeys']
    include: 'JournalEntryIncludeFromJournalEntry'


class JournalEntryLineIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    entry: Union[bool, 'JournalEntryArgsFromUser']
    account: Union[bool, 'AccountArgsFromUser']


class JournalEntryLineArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'JournalEntryLineIncludeFromJournalEntryLine'


class FindManyJournalEntryLineArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['JournalEntryLineOrderByInput', List['JournalEntryLineOrderByInput']]
    where: 'JournalEntryLineWhereInput'
    cursor: 'JournalEntryLineWhereUniqueInput'
    distinct: List['JournalEntryLineScalarFieldKeys']
    include: 'JournalEntryLineIncludeFromJournalEntryLine'


class AccountIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    branch: Union[bool, 'BranchArgsFromUser']
    entries: Union[bool, 'FindManyJournalEntryLineArgsFromUser']
    payments: Union[bool, 'FindManyPaymentArgsFromUser']
    outgoingTransfers: Union[bool, 'FindManyAccountTransferArgsFromUser']
    incomingTransfers: Union[bool, 'FindManyAccountTransferArgsFromUser']


class AccountArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'AccountIncludeFromAccount'


class FindManyAccountArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['AccountOrderByInput', List['AccountOrderByInput']]
    where: 'AccountWhereInput'
    cursor: 'AccountWhereUniqueInput'
    distinct: List['AccountScalarFieldKeys']
    include: 'AccountIncludeFromAccount'


class AccountTransferIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    fromAccount: Union[bool, 'AccountArgsFromUser']
    toAccount: Union[bool, 'AccountArgsFromUser']


class AccountTransferArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'AccountTransferIncludeFromAccountTransfer'


class FindManyAccountTransferArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['AccountTransferOrderByInput', List['AccountTransferOrderByInput']]
    where: 'AccountTransferWhereInput'
    cursor: 'AccountTransferWhereUniqueInput'
    distinct: List['AccountTransferScalarFieldKeys']
    include: 'AccountTransferIncludeFromAccountTransfer'


class BranchOrderIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    branch: Union[bool, 'BranchArgsFromUser']
    requestedBy: Union[bool, 'UserArgsFromUser']
    approvedBy: Union[bool, 'UserArgsFromUser']
    sentBy: Union[bool, 'UserArgsFromUser']
    receivedBy: Union[bool, 'UserArgsFromUser']
    items: Union[bool, 'FindManyBranchOrderItemArgsFromUser']


class BranchOrderArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'BranchOrderIncludeFromBranchOrder'


class FindManyBranchOrderArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['BranchOrderOrderByInput', List['BranchOrderOrderByInput']]
    where: 'BranchOrderWhereInput'
    cursor: 'BranchOrderWhereUniqueInput'
    distinct: List['BranchOrderScalarFieldKeys']
    include: 'BranchOrderIncludeFromBranchOrder'


class BranchOrderItemIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    branchOrder: Union[bool, 'BranchOrderArgsFromUser']
    stock: Union[bool, 'StockArgsFromUser']


class BranchOrderItemArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'BranchOrderItemIncludeFromBranchOrderItem'


class FindManyBranchOrderItemArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['BranchOrderItemOrderByInput', List['BranchOrderItemOrderByInput']]
    where: 'BranchOrderItemWhereInput'
    cursor: 'BranchOrderItemWhereUniqueInput'
    distinct: List['BranchOrderItemScalarFieldKeys']
    include: 'BranchOrderItemIncludeFromBranchOrderItem'


class AuditLogIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUser']


class AuditLogArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'AuditLogIncludeFromAuditLog'


class FindManyAuditLogArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['AuditLogOrderByInput', List['AuditLogOrderByInput']]
    where: 'AuditLogWhereInput'
    cursor: 'AuditLogWhereUniqueInput'
    distinct: List['AuditLogScalarFieldKeys']
    include: 'AuditLogIncludeFromAuditLog'


class SystemInfoIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""


class SystemInfoArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'SystemInfoIncludeFromSystemInfo'


class FindManySystemInfoArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['SystemInfoOrderByInput', List['SystemInfoOrderByInput']]
    where: 'SystemInfoWhereInput'
    cursor: 'SystemInfoWhereUniqueInput'
    distinct: List['SystemInfoScalarFieldKeys']
    include: 'SystemInfoIncludeFromSystemInfo'


class BackupIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    createdBy: Union[bool, 'UserArgsFromUser']


class BackupArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'BackupIncludeFromBackup'


class FindManyBackupArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['BackupOrderByInput', List['BackupOrderByInput']]
    where: 'BackupWhereInput'
    cursor: 'BackupWhereUniqueInput'
    distinct: List['BackupScalarFieldKeys']
    include: 'BackupIncludeFromBackup'


class RevokedTokenIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUser']


class RevokedTokenArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'RevokedTokenIncludeFromRevokedToken'


class FindManyRevokedTokenArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['RevokedTokenOrderByInput', List['RevokedTokenOrderByInput']]
    where: 'RevokedTokenWhereInput'
    cursor: 'RevokedTokenWhereUniqueInput'
    distinct: List['RevokedTokenScalarFieldKeys']
    include: 'RevokedTokenIncludeFromRevokedToken'


class SystemSettingIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""


class SystemSettingArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'SystemSettingIncludeFromSystemSetting'


class FindManySystemSettingArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['SystemSettingOrderByInput', List['SystemSettingOrderByInput']]
    where: 'SystemSettingWhereInput'
    cursor: 'SystemSettingWhereUniqueInput'
    distinct: List['SystemSettingScalarFieldKeys']
    include: 'SystemSettingIncludeFromSystemSetting'


class NotificationIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUser']


class NotificationArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'NotificationIncludeFromNotification'


class FindManyNotificationArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['NotificationOrderByInput', List['NotificationOrderByInput']]
    where: 'NotificationWhereInput'
    cursor: 'NotificationWhereUniqueInput'
    distinct: List['NotificationScalarFieldKeys']
    include: 'NotificationIncludeFromNotification'


class StockAdjustmentIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    product: Union[bool, 'ProductArgsFromUser']
    createdBy: Union[bool, 'UserArgsFromUser']


class StockAdjustmentArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'StockAdjustmentIncludeFromStockAdjustment'


class FindManyStockAdjustmentArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['StockAdjustmentOrderByInput', List['StockAdjustmentOrderByInput']]
    where: 'StockAdjustmentWhereInput'
    cursor: 'StockAdjustmentWhereUniqueInput'
    distinct: List['StockAdjustmentScalarFieldKeys']
    include: 'StockAdjustmentIncludeFromStockAdjustment'




FindManyUserArgs = FindManyUserArgsFromUser
FindFirstUserArgs = FindManyUserArgsFromUser


class UserWhereInput(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    username: Union[_str, 'types.StringFilter']
    email: Union[None, _str, 'types.StringFilter']
    firstName: Union[_str, 'types.StringFilter']
    lastName: Union[_str, 'types.StringFilter']
    hashedPassword: Union[_str, 'types.StringFilter']
    role: 'enums.Role'
    isActive: Union[_bool, 'types.BooleanFilter']
    branchId: Union[None, _int, 'types.IntFilter']
    branch: 'BranchRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    auditLogs: 'AuditLogListRelationFilter'
    permissions: 'UserPermissionListRelationFilter'
    notifications: 'NotificationListRelationFilter'
    revokedTokens: 'RevokedTokenListRelationFilter'
    stockAdjustments: 'StockAdjustmentListRelationFilter'
    Sale: 'SaleListRelationFilter'
    deletedSales: 'SaleListRelationFilter'
    Payment: 'PaymentListRelationFilter'
    Backup: 'BackupListRelationFilter'
    requestedOrders: 'BranchOrderListRelationFilter'
    approvedOrders: 'BranchOrderListRelationFilter'
    sentOrders: 'BranchOrderListRelationFilter'
    receivedOrders: 'BranchOrderListRelationFilter'

    # should be noted that AND and NOT should be Union['UserWhereInput', List['UserWhereInput']]
    # but this causes mypy to hang :/
    AND: List['UserWhereInput']
    OR: List['UserWhereInput']
    NOT: List['UserWhereInput']



# aggregate User types


class UserScalarWhereWithAggregatesInput(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    username: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    firstName: Union[_str, 'types.StringWithAggregatesFilter']
    lastName: Union[_str, 'types.StringWithAggregatesFilter']
    hashedPassword: Union[_str, 'types.StringWithAggregatesFilter']
    role: 'enums.Role'
    isActive: Union[_bool, 'types.BooleanWithAggregatesFilter']
    branchId: Union[_int, 'types.IntWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['UserScalarWhereWithAggregatesInput']
    OR: List['UserScalarWhereWithAggregatesInput']
    NOT: List['UserScalarWhereWithAggregatesInput']



class UserGroupByOutput(TypedDict, total=False):
    id: _int
    username: _str
    email: _str
    firstName: _str
    lastName: _str
    hashedPassword: _str
    role: 'enums.Role'
    isActive: _bool
    branchId: _int
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'UserSumAggregateOutput'
    _avg: 'UserAvgAggregateOutput'
    _min: 'UserMinAggregateOutput'
    _max: 'UserMaxAggregateOutput'
    _count: 'UserCountAggregateOutput'


class UserAvgAggregateOutput(TypedDict, total=False):
    """User output for aggregating averages"""
    id: float
    branchId: float


class UserSumAggregateOutput(TypedDict, total=False):
    """User output for aggregating sums"""
    id: _int
    branchId: _int


class UserScalarAggregateOutput(TypedDict, total=False):
    """User output including scalar fields"""
    id: _int
    username: _str
    email: _str
    firstName: _str
    lastName: _str
    hashedPassword: _str
    role: 'enums.Role'
    isActive: _bool
    branchId: _int
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


UserMinAggregateOutput = UserScalarAggregateOutput
UserMaxAggregateOutput = UserScalarAggregateOutput


class UserMaxAggregateInput(TypedDict, total=False):
    """User input for aggregating by max"""
    id: bool
    username: bool
    email: bool
    firstName: bool
    lastName: bool
    hashedPassword: bool
    role: bool
    isActive: bool
    branchId: bool
    createdAt: bool
    updatedAt: bool


class UserMinAggregateInput(TypedDict, total=False):
    """User input for aggregating by min"""
    id: bool
    username: bool
    email: bool
    firstName: bool
    lastName: bool
    hashedPassword: bool
    role: bool
    isActive: bool
    branchId: bool
    createdAt: bool
    updatedAt: bool


class UserNumberAggregateInput(TypedDict, total=False):
    """User input for aggregating numbers"""
    id: bool
    branchId: bool


UserAvgAggregateInput = UserNumberAggregateInput
UserSumAggregateInput = UserNumberAggregateInput


UserCountAggregateInput = TypedDict(
    'UserCountAggregateInput',
    {
        'id': bool,
        'username': bool,
        'email': bool,
        'firstName': bool,
        'lastName': bool,
        'hashedPassword': bool,
        'role': bool,
        'isActive': bool,
        'branchId': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

UserCountAggregateOutput = TypedDict(
    'UserCountAggregateOutput',
    {
        'id': int,
        'username': int,
        'email': int,
        'firstName': int,
        'lastName': int,
        'hashedPassword': int,
        'role': int,
        'isActive': int,
        'branchId': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


UserKeys = Literal[
    'id',
    'username',
    'email',
    'firstName',
    'lastName',
    'hashedPassword',
    'role',
    'isActive',
    'branchId',
    'branch',
    'createdAt',
    'updatedAt',
    'auditLogs',
    'permissions',
    'notifications',
    'revokedTokens',
    'stockAdjustments',
    'Sale',
    'deletedSales',
    'Payment',
    'Backup',
    'requestedOrders',
    'approvedOrders',
    'sentOrders',
    'receivedOrders',
]
UserScalarFieldKeys = Literal[
    'id',
    'username',
    'email',
    'firstName',
    'lastName',
    'hashedPassword',
    'role',
    'isActive',
    'branchId',
    'createdAt',
    'updatedAt',
]
UserScalarFieldKeysT = TypeVar('UserScalarFieldKeysT', bound=UserScalarFieldKeys)

UserRelationalFieldKeys = Literal[
        'branch',
        'auditLogs',
        'permissions',
        'notifications',
        'revokedTokens',
        'stockAdjustments',
        'Sale',
        'deletedSales',
        'Payment',
        'Backup',
        'requestedOrders',
        'approvedOrders',
        'sentOrders',
        'receivedOrders',
    ]

# UserPermission types

class UserPermissionOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the UserPermission create method"""
    id: _int
    user: 'UserCreateNestedWithoutRelationsInput'
    userId: _int
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class UserPermissionCreateInput(UserPermissionOptionalCreateInput):
    """Required arguments to the UserPermission create method"""
    resource: _str
    actions: 'fields.Json'


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class UserPermissionOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the UserPermission create method, without relations"""
    id: _int
    userId: _int
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class UserPermissionCreateWithoutRelationsInput(UserPermissionOptionalCreateWithoutRelationsInput):
    """Required arguments to the UserPermission create method, without relations"""
    resource: _str
    actions: 'fields.Json'


class UserPermissionCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'UserPermissionCreateWithoutRelationsInput'
    connect: 'UserPermissionWhereUniqueInput'


class UserPermissionCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['UserPermissionCreateWithoutRelationsInput', List['UserPermissionCreateWithoutRelationsInput']]
    connect: Union['UserPermissionWhereUniqueInput', List['UserPermissionWhereUniqueInput']]


_UserPermissionWhereUnique_id_Input = TypedDict(
    '_UserPermissionWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

UserPermissionWhereUniqueInput = _UserPermissionWhereUnique_id_Input


class UserPermissionUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    user: 'UserUpdateOneWithoutRelationsInput'
    resource: _str
    actions: 'fields.Json'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class UserPermissionUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    resource: _str
    actions: 'fields.Json'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class UserPermissionUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['UserPermissionCreateWithoutRelationsInput']
    connect: List['UserPermissionWhereUniqueInput']
    set: List['UserPermissionWhereUniqueInput']
    disconnect: List['UserPermissionWhereUniqueInput']
    delete: List['UserPermissionWhereUniqueInput']

    # TODO
    # update: List['UserPermissionUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['UserPermissionUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['UserPermissionScalarWhereInput']
    # upsert: List['UserPermissionUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['UserPermissionCreateOrConnectWithoutRelationsInput']


class UserPermissionUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'UserPermissionCreateWithoutRelationsInput'
    connect: 'UserPermissionWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'UserPermissionUpdateInput'
    # upsert: 'UserPermissionUpsertWithoutRelationsInput'
    # connectOrCreate: 'UserPermissionCreateOrConnectWithoutRelationsInput'


class UserPermissionUpsertInput(TypedDict):
    create: 'UserPermissionCreateInput'
    update: 'UserPermissionUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_UserPermission_id_OrderByInput = TypedDict(
    '_UserPermission_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_UserPermission_userId_OrderByInput = TypedDict(
    '_UserPermission_userId_OrderByInput',
    {
        'userId': 'SortOrder',
    },
    total=True
)

_UserPermission_resource_OrderByInput = TypedDict(
    '_UserPermission_resource_OrderByInput',
    {
        'resource': 'SortOrder',
    },
    total=True
)

_UserPermission_actions_OrderByInput = TypedDict(
    '_UserPermission_actions_OrderByInput',
    {
        'actions': 'SortOrder',
    },
    total=True
)

_UserPermission_createdAt_OrderByInput = TypedDict(
    '_UserPermission_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_UserPermission_updatedAt_OrderByInput = TypedDict(
    '_UserPermission_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

UserPermissionOrderByInput = Union[
    '_UserPermission_id_OrderByInput',
    '_UserPermission_userId_OrderByInput',
    '_UserPermission_resource_OrderByInput',
    '_UserPermission_actions_OrderByInput',
    '_UserPermission_createdAt_OrderByInput',
    '_UserPermission_updatedAt_OrderByInput',
]



# recursive UserPermission types
# TODO: cleanup these types



UserPermissionRelationFilter = TypedDict(
    'UserPermissionRelationFilter',
    {
        'is': 'UserPermissionWhereInput',
        'is_not': 'UserPermissionWhereInput',
    },
    total=False,
)


class UserPermissionListRelationFilter(TypedDict, total=False):
    some: 'UserPermissionWhereInput'
    none: 'UserPermissionWhereInput'
    every: 'UserPermissionWhereInput'


class UserPermissionInclude(TypedDict, total=False):
    """UserPermission relational arguments"""
    user: Union[bool, 'UserArgsFromUserPermission']


class UserIncludeFromUserPermission(TypedDict, total=False):
    """Relational arguments for UserPermission"""
    branch: Union[bool, 'BranchArgsFromUserPermission']
    auditLogs: Union[bool, 'FindManyAuditLogArgsFromUserPermission']
    permissions: Union[bool, 'FindManyUserPermissionArgsFromUserPermission']
    notifications: Union[bool, 'FindManyNotificationArgsFromUserPermission']
    revokedTokens: Union[bool, 'FindManyRevokedTokenArgsFromUserPermission']
    stockAdjustments: Union[bool, 'FindManyStockAdjustmentArgsFromUserPermission']
    Sale: Union[bool, 'FindManySaleArgsFromUserPermission']
    deletedSales: Union[bool, 'FindManySaleArgsFromUserPermission']
    Payment: Union[bool, 'FindManyPaymentArgsFromUserPermission']
    Backup: Union[bool, 'FindManyBackupArgsFromUserPermission']
    requestedOrders: Union[bool, 'FindManyBranchOrderArgsFromUserPermission']
    approvedOrders: Union[bool, 'FindManyBranchOrderArgsFromUserPermission']
    sentOrders: Union[bool, 'FindManyBranchOrderArgsFromUserPermission']
    receivedOrders: Union[bool, 'FindManyBranchOrderArgsFromUserPermission']


class UserArgsFromUserPermission(TypedDict, total=False):
    """Arguments for UserPermission"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromUserPermission(TypedDict, total=False):
    """Arguments for UserPermission"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class UserPermissionIncludeFromUserPermission(TypedDict, total=False):
    """Relational arguments for UserPermission"""
    user: Union[bool, 'UserArgsFromUserPermission']


class UserPermissionArgsFromUserPermission(TypedDict, total=False):
    """Arguments for UserPermission"""
    include: 'UserPermissionIncludeFromUserPermission'


class FindManyUserPermissionArgsFromUserPermission(TypedDict, total=False):
    """Arguments for UserPermission"""
    take: int
    skip: int
    order_by: Union['UserPermissionOrderByInput', List['UserPermissionOrderByInput']]
    where: 'UserPermissionWhereInput'
    cursor: 'UserPermissionWhereUniqueInput'
    distinct: List['UserPermissionScalarFieldKeys']
    include: 'UserPermissionIncludeFromUserPermission'


class BranchIncludeFromUserPermission(TypedDict, total=False):
    """Relational arguments for UserPermission"""
    users: Union[bool, 'FindManyUserArgsFromUserPermission']
    Sale: Union[bool, 'FindManySaleArgsFromUserPermission']
    Account: Union[bool, 'FindManyAccountArgsFromUserPermission']
    BranchOrder: Union[bool, 'FindManyBranchOrderArgsFromUserPermission']


class BranchArgsFromUserPermission(TypedDict, total=False):
    """Arguments for UserPermission"""
    include: 'BranchIncludeFromBranch'


class FindManyBranchArgsFromUserPermission(TypedDict, total=False):
    """Arguments for UserPermission"""
    take: int
    skip: int
    order_by: Union['BranchOrderByInput', List['BranchOrderByInput']]
    where: 'BranchWhereInput'
    cursor: 'BranchWhereUniqueInput'
    distinct: List['BranchScalarFieldKeys']
    include: 'BranchIncludeFromBranch'


class ProductIncludeFromUserPermission(TypedDict, total=False):
    """Relational arguments for UserPermission"""
    category: Union[bool, 'CategoryArgsFromUserPermission']
    stocks: Union[bool, 'FindManyStockArgsFromUserPermission']
    stockAdjustments: Union[bool, 'FindManyStockAdjustmentArgsFromUserPermission']


class ProductArgsFromUserPermission(TypedDict, total=False):
    """Arguments for UserPermission"""
    include: 'ProductIncludeFromProduct'


class FindManyProductArgsFromUserPermission(TypedDict, total=False):
    """Arguments for UserPermission"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProduct'


class CategoryIncludeFromUserPermission(TypedDict, total=False):
    """Relational arguments for UserPermission"""
    products: Union[bool, 'FindManyProductArgsFromUserPermission']


class CategoryArgsFromUserPermission(TypedDict, total=False):
    """Arguments for UserPermission"""
    include: 'CategoryIncludeFromCategory'


class FindManyCategoryArgsFromUserPermission(TypedDict, total=False):
    """Arguments for UserPermission"""
    take: int
    skip: int
    order_by: Union['CategoryOrderByInput', List['CategoryOrderByInput']]
    where: 'CategoryWhereInput'
    cursor: 'CategoryWhereUniqueInput'
    distinct: List['CategoryScalarFieldKeys']
    include: 'CategoryIncludeFromCategory'


class StockIncludeFromUserPermission(TypedDict, total=False):
    """Relational arguments for UserPermission"""
    product: Union[bool, 'ProductArgsFromUserPermission']
    SaleItem: Union[bool, 'FindManySaleItemArgsFromUserPermission']
    BranchOrderItem: Union[bool, 'FindManyBranchOrderItemArgsFromUserPermission']


class StockArgsFromUserPermission(TypedDict, total=False):
    """Arguments for UserPermission"""
    include: 'StockIncludeFromStock'


class FindManyStockArgsFromUserPermission(TypedDict, total=False):
    """Arguments for UserPermission"""
    take: int
    skip: int
    order_by: Union['StockOrderByInput', List['StockOrderByInput']]
    where: 'StockWhereInput'
    cursor: 'StockWhereUniqueInput'
    distinct: List['StockScalarFieldKeys']
    include: 'StockIncludeFromStock'


class CustomerIncludeFromUserPermission(TypedDict, total=False):
    """Relational arguments for UserPermission"""
    Sale: Union[bool, 'FindManySaleArgsFromUserPermission']


class CustomerArgsFromUserPermission(TypedDict, total=False):
    """Arguments for UserPermission"""
    include: 'CustomerIncludeFromCustomer'


class FindManyCustomerArgsFromUserPermission(TypedDict, total=False):
    """Arguments for UserPermission"""
    take: int
    skip: int
    order_by: Union['CustomerOrderByInput', List['CustomerOrderByInput']]
    where: 'CustomerWhereInput'
    cursor: 'CustomerWhereUniqueInput'
    distinct: List['CustomerScalarFieldKeys']
    include: 'CustomerIncludeFromCustomer'


class SaleIncludeFromUserPermission(TypedDict, total=False):
    """Relational arguments for UserPermission"""
    branch: Union[bool, 'BranchArgsFromUserPermission']
    customer: Union[bool, 'CustomerArgsFromUserPermission']
    user: Union[bool, 'UserArgsFromUserPermission']
    items: Union[bool, 'FindManySaleItemArgsFromUserPermission']
    payments: Union[bool, 'FindManyPaymentArgsFromUserPermission']
    returns: Union[bool, 'FindManyReturnSaleArgsFromUserPermission']
    deletedBy: Union[bool, 'UserArgsFromUserPermission']


class SaleArgsFromUserPermission(TypedDict, total=False):
    """Arguments for UserPermission"""
    include: 'SaleIncludeFromSale'


class FindManySaleArgsFromUserPermission(TypedDict, total=False):
    """Arguments for UserPermission"""
    take: int
    skip: int
    order_by: Union['SaleOrderByInput', List['SaleOrderByInput']]
    where: 'SaleWhereInput'
    cursor: 'SaleWhereUniqueInput'
    distinct: List['SaleScalarFieldKeys']
    include: 'SaleIncludeFromSale'


class SaleItemIncludeFromUserPermission(TypedDict, total=False):
    """Relational arguments for UserPermission"""
    sale: Union[bool, 'SaleArgsFromUserPermission']
    stock: Union[bool, 'StockArgsFromUserPermission']
    ReturnItem: Union[bool, 'FindManyReturnItemArgsFromUserPermission']


class SaleItemArgsFromUserPermission(TypedDict, total=False):
    """Arguments for UserPermission"""
    include: 'SaleItemIncludeFromSaleItem'


class FindManySaleItemArgsFromUserPermission(TypedDict, total=False):
    """Arguments for UserPermission"""
    take: int
    skip: int
    order_by: Union['SaleItemOrderByInput', List['SaleItemOrderByInput']]
    where: 'SaleItemWhereInput'
    cursor: 'SaleItemWhereUniqueInput'
    distinct: List['SaleItemScalarFieldKeys']
    include: 'SaleItemIncludeFromSaleItem'


class ReturnSaleIncludeFromUserPermission(TypedDict, total=False):
    """Relational arguments for UserPermission"""
    original: Union[bool, 'SaleArgsFromUserPermission']
    items: Union[bool, 'FindManyReturnItemArgsFromUserPermission']
    refund: Union[bool, 'FindManyPaymentArgsFromUserPermission']


class ReturnSaleArgsFromUserPermission(TypedDict, total=False):
    """Arguments for UserPermission"""
    include: 'ReturnSaleIncludeFromReturnSale'


class FindManyReturnSaleArgsFromUserPermission(TypedDict, total=False):
    """Arguments for UserPermission"""
    take: int
    skip: int
    order_by: Union['ReturnSaleOrderByInput', List['ReturnSaleOrderByInput']]
    where: 'ReturnSaleWhereInput'
    cursor: 'ReturnSaleWhereUniqueInput'
    distinct: List['ReturnSaleScalarFieldKeys']
    include: 'ReturnSaleIncludeFromReturnSale'


class ReturnItemIncludeFromUserPermission(TypedDict, total=False):
    """Relational arguments for UserPermission"""
    returnSale: Union[bool, 'ReturnSaleArgsFromUserPermission']
    saleItem: Union[bool, 'SaleItemArgsFromUserPermission']


class ReturnItemArgsFromUserPermission(TypedDict, total=False):
    """Arguments for UserPermission"""
    include: 'ReturnItemIncludeFromReturnItem'


class FindManyReturnItemArgsFromUserPermission(TypedDict, total=False):
    """Arguments for UserPermission"""
    take: int
    skip: int
    order_by: Union['ReturnItemOrderByInput', List['ReturnItemOrderByInput']]
    where: 'ReturnItemWhereInput'
    cursor: 'ReturnItemWhereUniqueInput'
    distinct: List['ReturnItemScalarFieldKeys']
    include: 'ReturnItemIncludeFromReturnItem'


class PaymentIncludeFromUserPermission(TypedDict, total=False):
    """Relational arguments for UserPermission"""
    sale: Union[bool, 'SaleArgsFromUserPermission']
    account: Union[bool, 'AccountArgsFromUserPermission']
    returnSale: Union[bool, 'ReturnSaleArgsFromUserPermission']
    user: Union[bool, 'UserArgsFromUserPermission']


class PaymentArgsFromUserPermission(TypedDict, total=False):
    """Arguments for UserPermission"""
    include: 'PaymentIncludeFromPayment'


class FindManyPaymentArgsFromUserPermission(TypedDict, total=False):
    """Arguments for UserPermission"""
    take: int
    skip: int
    order_by: Union['PaymentOrderByInput', List['PaymentOrderByInput']]
    where: 'PaymentWhereInput'
    cursor: 'PaymentWhereUniqueInput'
    distinct: List['PaymentScalarFieldKeys']
    include: 'PaymentIncludeFromPayment'


class JournalEntryIncludeFromUserPermission(TypedDict, total=False):
    """Relational arguments for UserPermission"""
    lines: Union[bool, 'FindManyJournalEntryLineArgsFromUserPermission']


class JournalEntryArgsFromUserPermission(TypedDict, total=False):
    """Arguments for UserPermission"""
    include: 'JournalEntryIncludeFromJournalEntry'


class FindManyJournalEntryArgsFromUserPermission(TypedDict, total=False):
    """Arguments for UserPermission"""
    take: int
    skip: int
    order_by: Union['JournalEntryOrderByInput', List['JournalEntryOrderByInput']]
    where: 'JournalEntryWhereInput'
    cursor: 'JournalEntryWhereUniqueInput'
    distinct: List['JournalEntryScalarFieldKeys']
    include: 'JournalEntryIncludeFromJournalEntry'


class JournalEntryLineIncludeFromUserPermission(TypedDict, total=False):
    """Relational arguments for UserPermission"""
    entry: Union[bool, 'JournalEntryArgsFromUserPermission']
    account: Union[bool, 'AccountArgsFromUserPermission']


class JournalEntryLineArgsFromUserPermission(TypedDict, total=False):
    """Arguments for UserPermission"""
    include: 'JournalEntryLineIncludeFromJournalEntryLine'


class FindManyJournalEntryLineArgsFromUserPermission(TypedDict, total=False):
    """Arguments for UserPermission"""
    take: int
    skip: int
    order_by: Union['JournalEntryLineOrderByInput', List['JournalEntryLineOrderByInput']]
    where: 'JournalEntryLineWhereInput'
    cursor: 'JournalEntryLineWhereUniqueInput'
    distinct: List['JournalEntryLineScalarFieldKeys']
    include: 'JournalEntryLineIncludeFromJournalEntryLine'


class AccountIncludeFromUserPermission(TypedDict, total=False):
    """Relational arguments for UserPermission"""
    branch: Union[bool, 'BranchArgsFromUserPermission']
    entries: Union[bool, 'FindManyJournalEntryLineArgsFromUserPermission']
    payments: Union[bool, 'FindManyPaymentArgsFromUserPermission']
    outgoingTransfers: Union[bool, 'FindManyAccountTransferArgsFromUserPermission']
    incomingTransfers: Union[bool, 'FindManyAccountTransferArgsFromUserPermission']


class AccountArgsFromUserPermission(TypedDict, total=False):
    """Arguments for UserPermission"""
    include: 'AccountIncludeFromAccount'


class FindManyAccountArgsFromUserPermission(TypedDict, total=False):
    """Arguments for UserPermission"""
    take: int
    skip: int
    order_by: Union['AccountOrderByInput', List['AccountOrderByInput']]
    where: 'AccountWhereInput'
    cursor: 'AccountWhereUniqueInput'
    distinct: List['AccountScalarFieldKeys']
    include: 'AccountIncludeFromAccount'


class AccountTransferIncludeFromUserPermission(TypedDict, total=False):
    """Relational arguments for UserPermission"""
    fromAccount: Union[bool, 'AccountArgsFromUserPermission']
    toAccount: Union[bool, 'AccountArgsFromUserPermission']


class AccountTransferArgsFromUserPermission(TypedDict, total=False):
    """Arguments for UserPermission"""
    include: 'AccountTransferIncludeFromAccountTransfer'


class FindManyAccountTransferArgsFromUserPermission(TypedDict, total=False):
    """Arguments for UserPermission"""
    take: int
    skip: int
    order_by: Union['AccountTransferOrderByInput', List['AccountTransferOrderByInput']]
    where: 'AccountTransferWhereInput'
    cursor: 'AccountTransferWhereUniqueInput'
    distinct: List['AccountTransferScalarFieldKeys']
    include: 'AccountTransferIncludeFromAccountTransfer'


class BranchOrderIncludeFromUserPermission(TypedDict, total=False):
    """Relational arguments for UserPermission"""
    branch: Union[bool, 'BranchArgsFromUserPermission']
    requestedBy: Union[bool, 'UserArgsFromUserPermission']
    approvedBy: Union[bool, 'UserArgsFromUserPermission']
    sentBy: Union[bool, 'UserArgsFromUserPermission']
    receivedBy: Union[bool, 'UserArgsFromUserPermission']
    items: Union[bool, 'FindManyBranchOrderItemArgsFromUserPermission']


class BranchOrderArgsFromUserPermission(TypedDict, total=False):
    """Arguments for UserPermission"""
    include: 'BranchOrderIncludeFromBranchOrder'


class FindManyBranchOrderArgsFromUserPermission(TypedDict, total=False):
    """Arguments for UserPermission"""
    take: int
    skip: int
    order_by: Union['BranchOrderOrderByInput', List['BranchOrderOrderByInput']]
    where: 'BranchOrderWhereInput'
    cursor: 'BranchOrderWhereUniqueInput'
    distinct: List['BranchOrderScalarFieldKeys']
    include: 'BranchOrderIncludeFromBranchOrder'


class BranchOrderItemIncludeFromUserPermission(TypedDict, total=False):
    """Relational arguments for UserPermission"""
    branchOrder: Union[bool, 'BranchOrderArgsFromUserPermission']
    stock: Union[bool, 'StockArgsFromUserPermission']


class BranchOrderItemArgsFromUserPermission(TypedDict, total=False):
    """Arguments for UserPermission"""
    include: 'BranchOrderItemIncludeFromBranchOrderItem'


class FindManyBranchOrderItemArgsFromUserPermission(TypedDict, total=False):
    """Arguments for UserPermission"""
    take: int
    skip: int
    order_by: Union['BranchOrderItemOrderByInput', List['BranchOrderItemOrderByInput']]
    where: 'BranchOrderItemWhereInput'
    cursor: 'BranchOrderItemWhereUniqueInput'
    distinct: List['BranchOrderItemScalarFieldKeys']
    include: 'BranchOrderItemIncludeFromBranchOrderItem'


class AuditLogIncludeFromUserPermission(TypedDict, total=False):
    """Relational arguments for UserPermission"""
    user: Union[bool, 'UserArgsFromUserPermission']


class AuditLogArgsFromUserPermission(TypedDict, total=False):
    """Arguments for UserPermission"""
    include: 'AuditLogIncludeFromAuditLog'


class FindManyAuditLogArgsFromUserPermission(TypedDict, total=False):
    """Arguments for UserPermission"""
    take: int
    skip: int
    order_by: Union['AuditLogOrderByInput', List['AuditLogOrderByInput']]
    where: 'AuditLogWhereInput'
    cursor: 'AuditLogWhereUniqueInput'
    distinct: List['AuditLogScalarFieldKeys']
    include: 'AuditLogIncludeFromAuditLog'


class SystemInfoIncludeFromUserPermission(TypedDict, total=False):
    """Relational arguments for UserPermission"""


class SystemInfoArgsFromUserPermission(TypedDict, total=False):
    """Arguments for UserPermission"""
    include: 'SystemInfoIncludeFromSystemInfo'


class FindManySystemInfoArgsFromUserPermission(TypedDict, total=False):
    """Arguments for UserPermission"""
    take: int
    skip: int
    order_by: Union['SystemInfoOrderByInput', List['SystemInfoOrderByInput']]
    where: 'SystemInfoWhereInput'
    cursor: 'SystemInfoWhereUniqueInput'
    distinct: List['SystemInfoScalarFieldKeys']
    include: 'SystemInfoIncludeFromSystemInfo'


class BackupIncludeFromUserPermission(TypedDict, total=False):
    """Relational arguments for UserPermission"""
    createdBy: Union[bool, 'UserArgsFromUserPermission']


class BackupArgsFromUserPermission(TypedDict, total=False):
    """Arguments for UserPermission"""
    include: 'BackupIncludeFromBackup'


class FindManyBackupArgsFromUserPermission(TypedDict, total=False):
    """Arguments for UserPermission"""
    take: int
    skip: int
    order_by: Union['BackupOrderByInput', List['BackupOrderByInput']]
    where: 'BackupWhereInput'
    cursor: 'BackupWhereUniqueInput'
    distinct: List['BackupScalarFieldKeys']
    include: 'BackupIncludeFromBackup'


class RevokedTokenIncludeFromUserPermission(TypedDict, total=False):
    """Relational arguments for UserPermission"""
    user: Union[bool, 'UserArgsFromUserPermission']


class RevokedTokenArgsFromUserPermission(TypedDict, total=False):
    """Arguments for UserPermission"""
    include: 'RevokedTokenIncludeFromRevokedToken'


class FindManyRevokedTokenArgsFromUserPermission(TypedDict, total=False):
    """Arguments for UserPermission"""
    take: int
    skip: int
    order_by: Union['RevokedTokenOrderByInput', List['RevokedTokenOrderByInput']]
    where: 'RevokedTokenWhereInput'
    cursor: 'RevokedTokenWhereUniqueInput'
    distinct: List['RevokedTokenScalarFieldKeys']
    include: 'RevokedTokenIncludeFromRevokedToken'


class SystemSettingIncludeFromUserPermission(TypedDict, total=False):
    """Relational arguments for UserPermission"""


class SystemSettingArgsFromUserPermission(TypedDict, total=False):
    """Arguments for UserPermission"""
    include: 'SystemSettingIncludeFromSystemSetting'


class FindManySystemSettingArgsFromUserPermission(TypedDict, total=False):
    """Arguments for UserPermission"""
    take: int
    skip: int
    order_by: Union['SystemSettingOrderByInput', List['SystemSettingOrderByInput']]
    where: 'SystemSettingWhereInput'
    cursor: 'SystemSettingWhereUniqueInput'
    distinct: List['SystemSettingScalarFieldKeys']
    include: 'SystemSettingIncludeFromSystemSetting'


class NotificationIncludeFromUserPermission(TypedDict, total=False):
    """Relational arguments for UserPermission"""
    user: Union[bool, 'UserArgsFromUserPermission']


class NotificationArgsFromUserPermission(TypedDict, total=False):
    """Arguments for UserPermission"""
    include: 'NotificationIncludeFromNotification'


class FindManyNotificationArgsFromUserPermission(TypedDict, total=False):
    """Arguments for UserPermission"""
    take: int
    skip: int
    order_by: Union['NotificationOrderByInput', List['NotificationOrderByInput']]
    where: 'NotificationWhereInput'
    cursor: 'NotificationWhereUniqueInput'
    distinct: List['NotificationScalarFieldKeys']
    include: 'NotificationIncludeFromNotification'


class StockAdjustmentIncludeFromUserPermission(TypedDict, total=False):
    """Relational arguments for UserPermission"""
    product: Union[bool, 'ProductArgsFromUserPermission']
    createdBy: Union[bool, 'UserArgsFromUserPermission']


class StockAdjustmentArgsFromUserPermission(TypedDict, total=False):
    """Arguments for UserPermission"""
    include: 'StockAdjustmentIncludeFromStockAdjustment'


class FindManyStockAdjustmentArgsFromUserPermission(TypedDict, total=False):
    """Arguments for UserPermission"""
    take: int
    skip: int
    order_by: Union['StockAdjustmentOrderByInput', List['StockAdjustmentOrderByInput']]
    where: 'StockAdjustmentWhereInput'
    cursor: 'StockAdjustmentWhereUniqueInput'
    distinct: List['StockAdjustmentScalarFieldKeys']
    include: 'StockAdjustmentIncludeFromStockAdjustment'




FindManyUserPermissionArgs = FindManyUserPermissionArgsFromUserPermission
FindFirstUserPermissionArgs = FindManyUserPermissionArgsFromUserPermission


class UserPermissionWhereInput(TypedDict, total=False):
    """UserPermission arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    user: 'UserRelationFilter'
    userId: Union[_int, 'types.IntFilter']
    resource: Union[_str, 'types.StringFilter']
    actions: Union['fields.Json', 'types.JsonFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['UserPermissionWhereInput', List['UserPermissionWhereInput']]
    # but this causes mypy to hang :/
    AND: List['UserPermissionWhereInput']
    OR: List['UserPermissionWhereInput']
    NOT: List['UserPermissionWhereInput']



# aggregate UserPermission types


class UserPermissionScalarWhereWithAggregatesInput(TypedDict, total=False):
    """UserPermission arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    userId: Union[_int, 'types.IntWithAggregatesFilter']
    resource: Union[_str, 'types.StringWithAggregatesFilter']
    actions: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['UserPermissionScalarWhereWithAggregatesInput']
    OR: List['UserPermissionScalarWhereWithAggregatesInput']
    NOT: List['UserPermissionScalarWhereWithAggregatesInput']



class UserPermissionGroupByOutput(TypedDict, total=False):
    id: _int
    userId: _int
    resource: _str
    actions: 'fields.Json'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'UserPermissionSumAggregateOutput'
    _avg: 'UserPermissionAvgAggregateOutput'
    _min: 'UserPermissionMinAggregateOutput'
    _max: 'UserPermissionMaxAggregateOutput'
    _count: 'UserPermissionCountAggregateOutput'


class UserPermissionAvgAggregateOutput(TypedDict, total=False):
    """UserPermission output for aggregating averages"""
    id: float
    userId: float


class UserPermissionSumAggregateOutput(TypedDict, total=False):
    """UserPermission output for aggregating sums"""
    id: _int
    userId: _int


class UserPermissionScalarAggregateOutput(TypedDict, total=False):
    """UserPermission output including scalar fields"""
    id: _int
    userId: _int
    resource: _str
    actions: 'fields.Json'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


UserPermissionMinAggregateOutput = UserPermissionScalarAggregateOutput
UserPermissionMaxAggregateOutput = UserPermissionScalarAggregateOutput


class UserPermissionMaxAggregateInput(TypedDict, total=False):
    """UserPermission input for aggregating by max"""
    id: bool
    userId: bool
    resource: bool
    actions: bool
    createdAt: bool
    updatedAt: bool


class UserPermissionMinAggregateInput(TypedDict, total=False):
    """UserPermission input for aggregating by min"""
    id: bool
    userId: bool
    resource: bool
    actions: bool
    createdAt: bool
    updatedAt: bool


class UserPermissionNumberAggregateInput(TypedDict, total=False):
    """UserPermission input for aggregating numbers"""
    id: bool
    userId: bool


UserPermissionAvgAggregateInput = UserPermissionNumberAggregateInput
UserPermissionSumAggregateInput = UserPermissionNumberAggregateInput


UserPermissionCountAggregateInput = TypedDict(
    'UserPermissionCountAggregateInput',
    {
        'id': bool,
        'userId': bool,
        'resource': bool,
        'actions': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

UserPermissionCountAggregateOutput = TypedDict(
    'UserPermissionCountAggregateOutput',
    {
        'id': int,
        'userId': int,
        'resource': int,
        'actions': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


UserPermissionKeys = Literal[
    'id',
    'user',
    'userId',
    'resource',
    'actions',
    'createdAt',
    'updatedAt',
]
UserPermissionScalarFieldKeys = Literal[
    'id',
    'userId',
    'resource',
    'actions',
    'createdAt',
    'updatedAt',
]
UserPermissionScalarFieldKeysT = TypeVar('UserPermissionScalarFieldKeysT', bound=UserPermissionScalarFieldKeys)

UserPermissionRelationalFieldKeys = Literal[
        'user',
    ]

# Branch types

class BranchOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Branch create method"""
    id: _int
    address: Optional[_str]
    phone: Optional[_str]
    isActive: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    users: 'UserCreateManyNestedWithoutRelationsInput'
    Sale: 'SaleCreateManyNestedWithoutRelationsInput'
    Account: 'AccountCreateManyNestedWithoutRelationsInput'
    BranchOrder: 'BranchOrderCreateManyNestedWithoutRelationsInput'


class BranchCreateInput(BranchOptionalCreateInput):
    """Required arguments to the Branch create method"""
    name: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class BranchOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Branch create method, without relations"""
    id: _int
    address: Optional[_str]
    phone: Optional[_str]
    isActive: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class BranchCreateWithoutRelationsInput(BranchOptionalCreateWithoutRelationsInput):
    """Required arguments to the Branch create method, without relations"""
    name: _str


class BranchCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'BranchCreateWithoutRelationsInput'
    connect: 'BranchWhereUniqueInput'


class BranchCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['BranchCreateWithoutRelationsInput', List['BranchCreateWithoutRelationsInput']]
    connect: Union['BranchWhereUniqueInput', List['BranchWhereUniqueInput']]


_BranchWhereUnique_id_Input = TypedDict(
    '_BranchWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

_BranchWhereUnique_name_Input = TypedDict(
    '_BranchWhereUnique_name_Input',
    {
        'name': '_str',
    },
    total=True
)

BranchWhereUniqueInput = Union[
    '_BranchWhereUnique_id_Input',
    '_BranchWhereUnique_name_Input',
]


class BranchUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    name: _str
    address: Optional[_str]
    phone: Optional[_str]
    isActive: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    users: 'UserUpdateManyWithoutRelationsInput'
    Sale: 'SaleUpdateManyWithoutRelationsInput'
    Account: 'AccountUpdateManyWithoutRelationsInput'
    BranchOrder: 'BranchOrderUpdateManyWithoutRelationsInput'


class BranchUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    name: _str
    address: Optional[_str]
    phone: Optional[_str]
    isActive: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class BranchUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['BranchCreateWithoutRelationsInput']
    connect: List['BranchWhereUniqueInput']
    set: List['BranchWhereUniqueInput']
    disconnect: List['BranchWhereUniqueInput']
    delete: List['BranchWhereUniqueInput']

    # TODO
    # update: List['BranchUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['BranchUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['BranchScalarWhereInput']
    # upsert: List['BranchUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['BranchCreateOrConnectWithoutRelationsInput']


class BranchUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'BranchCreateWithoutRelationsInput'
    connect: 'BranchWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'BranchUpdateInput'
    # upsert: 'BranchUpsertWithoutRelationsInput'
    # connectOrCreate: 'BranchCreateOrConnectWithoutRelationsInput'


class BranchUpsertInput(TypedDict):
    create: 'BranchCreateInput'
    update: 'BranchUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Branch_id_OrderByInput = TypedDict(
    '_Branch_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Branch_name_OrderByInput = TypedDict(
    '_Branch_name_OrderByInput',
    {
        'name': 'SortOrder',
    },
    total=True
)

_Branch_address_OrderByInput = TypedDict(
    '_Branch_address_OrderByInput',
    {
        'address': 'SortOrder',
    },
    total=True
)

_Branch_phone_OrderByInput = TypedDict(
    '_Branch_phone_OrderByInput',
    {
        'phone': 'SortOrder',
    },
    total=True
)

_Branch_isActive_OrderByInput = TypedDict(
    '_Branch_isActive_OrderByInput',
    {
        'isActive': 'SortOrder',
    },
    total=True
)

_Branch_createdAt_OrderByInput = TypedDict(
    '_Branch_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Branch_updatedAt_OrderByInput = TypedDict(
    '_Branch_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

BranchOrderByInput = Union[
    '_Branch_id_OrderByInput',
    '_Branch_name_OrderByInput',
    '_Branch_address_OrderByInput',
    '_Branch_phone_OrderByInput',
    '_Branch_isActive_OrderByInput',
    '_Branch_createdAt_OrderByInput',
    '_Branch_updatedAt_OrderByInput',
]



# recursive Branch types
# TODO: cleanup these types



BranchRelationFilter = TypedDict(
    'BranchRelationFilter',
    {
        'is': 'BranchWhereInput',
        'is_not': 'BranchWhereInput',
    },
    total=False,
)


class BranchListRelationFilter(TypedDict, total=False):
    some: 'BranchWhereInput'
    none: 'BranchWhereInput'
    every: 'BranchWhereInput'


class BranchInclude(TypedDict, total=False):
    """Branch relational arguments"""
    users: Union[bool, 'FindManyUserArgsFromBranch']
    Sale: Union[bool, 'FindManySaleArgsFromBranch']
    Account: Union[bool, 'FindManyAccountArgsFromBranch']
    BranchOrder: Union[bool, 'FindManyBranchOrderArgsFromBranch']


class UserIncludeFromBranch(TypedDict, total=False):
    """Relational arguments for Branch"""
    branch: Union[bool, 'BranchArgsFromBranch']
    auditLogs: Union[bool, 'FindManyAuditLogArgsFromBranch']
    permissions: Union[bool, 'FindManyUserPermissionArgsFromBranch']
    notifications: Union[bool, 'FindManyNotificationArgsFromBranch']
    revokedTokens: Union[bool, 'FindManyRevokedTokenArgsFromBranch']
    stockAdjustments: Union[bool, 'FindManyStockAdjustmentArgsFromBranch']
    Sale: Union[bool, 'FindManySaleArgsFromBranch']
    deletedSales: Union[bool, 'FindManySaleArgsFromBranch']
    Payment: Union[bool, 'FindManyPaymentArgsFromBranch']
    Backup: Union[bool, 'FindManyBackupArgsFromBranch']
    requestedOrders: Union[bool, 'FindManyBranchOrderArgsFromBranch']
    approvedOrders: Union[bool, 'FindManyBranchOrderArgsFromBranch']
    sentOrders: Union[bool, 'FindManyBranchOrderArgsFromBranch']
    receivedOrders: Union[bool, 'FindManyBranchOrderArgsFromBranch']


class UserArgsFromBranch(TypedDict, total=False):
    """Arguments for Branch"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromBranch(TypedDict, total=False):
    """Arguments for Branch"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class UserPermissionIncludeFromBranch(TypedDict, total=False):
    """Relational arguments for Branch"""
    user: Union[bool, 'UserArgsFromBranch']


class UserPermissionArgsFromBranch(TypedDict, total=False):
    """Arguments for Branch"""
    include: 'UserPermissionIncludeFromUserPermission'


class FindManyUserPermissionArgsFromBranch(TypedDict, total=False):
    """Arguments for Branch"""
    take: int
    skip: int
    order_by: Union['UserPermissionOrderByInput', List['UserPermissionOrderByInput']]
    where: 'UserPermissionWhereInput'
    cursor: 'UserPermissionWhereUniqueInput'
    distinct: List['UserPermissionScalarFieldKeys']
    include: 'UserPermissionIncludeFromUserPermission'


class BranchIncludeFromBranch(TypedDict, total=False):
    """Relational arguments for Branch"""
    users: Union[bool, 'FindManyUserArgsFromBranch']
    Sale: Union[bool, 'FindManySaleArgsFromBranch']
    Account: Union[bool, 'FindManyAccountArgsFromBranch']
    BranchOrder: Union[bool, 'FindManyBranchOrderArgsFromBranch']


class BranchArgsFromBranch(TypedDict, total=False):
    """Arguments for Branch"""
    include: 'BranchIncludeFromBranch'


class FindManyBranchArgsFromBranch(TypedDict, total=False):
    """Arguments for Branch"""
    take: int
    skip: int
    order_by: Union['BranchOrderByInput', List['BranchOrderByInput']]
    where: 'BranchWhereInput'
    cursor: 'BranchWhereUniqueInput'
    distinct: List['BranchScalarFieldKeys']
    include: 'BranchIncludeFromBranch'


class ProductIncludeFromBranch(TypedDict, total=False):
    """Relational arguments for Branch"""
    category: Union[bool, 'CategoryArgsFromBranch']
    stocks: Union[bool, 'FindManyStockArgsFromBranch']
    stockAdjustments: Union[bool, 'FindManyStockAdjustmentArgsFromBranch']


class ProductArgsFromBranch(TypedDict, total=False):
    """Arguments for Branch"""
    include: 'ProductIncludeFromProduct'


class FindManyProductArgsFromBranch(TypedDict, total=False):
    """Arguments for Branch"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProduct'


class CategoryIncludeFromBranch(TypedDict, total=False):
    """Relational arguments for Branch"""
    products: Union[bool, 'FindManyProductArgsFromBranch']


class CategoryArgsFromBranch(TypedDict, total=False):
    """Arguments for Branch"""
    include: 'CategoryIncludeFromCategory'


class FindManyCategoryArgsFromBranch(TypedDict, total=False):
    """Arguments for Branch"""
    take: int
    skip: int
    order_by: Union['CategoryOrderByInput', List['CategoryOrderByInput']]
    where: 'CategoryWhereInput'
    cursor: 'CategoryWhereUniqueInput'
    distinct: List['CategoryScalarFieldKeys']
    include: 'CategoryIncludeFromCategory'


class StockIncludeFromBranch(TypedDict, total=False):
    """Relational arguments for Branch"""
    product: Union[bool, 'ProductArgsFromBranch']
    SaleItem: Union[bool, 'FindManySaleItemArgsFromBranch']
    BranchOrderItem: Union[bool, 'FindManyBranchOrderItemArgsFromBranch']


class StockArgsFromBranch(TypedDict, total=False):
    """Arguments for Branch"""
    include: 'StockIncludeFromStock'


class FindManyStockArgsFromBranch(TypedDict, total=False):
    """Arguments for Branch"""
    take: int
    skip: int
    order_by: Union['StockOrderByInput', List['StockOrderByInput']]
    where: 'StockWhereInput'
    cursor: 'StockWhereUniqueInput'
    distinct: List['StockScalarFieldKeys']
    include: 'StockIncludeFromStock'


class CustomerIncludeFromBranch(TypedDict, total=False):
    """Relational arguments for Branch"""
    Sale: Union[bool, 'FindManySaleArgsFromBranch']


class CustomerArgsFromBranch(TypedDict, total=False):
    """Arguments for Branch"""
    include: 'CustomerIncludeFromCustomer'


class FindManyCustomerArgsFromBranch(TypedDict, total=False):
    """Arguments for Branch"""
    take: int
    skip: int
    order_by: Union['CustomerOrderByInput', List['CustomerOrderByInput']]
    where: 'CustomerWhereInput'
    cursor: 'CustomerWhereUniqueInput'
    distinct: List['CustomerScalarFieldKeys']
    include: 'CustomerIncludeFromCustomer'


class SaleIncludeFromBranch(TypedDict, total=False):
    """Relational arguments for Branch"""
    branch: Union[bool, 'BranchArgsFromBranch']
    customer: Union[bool, 'CustomerArgsFromBranch']
    user: Union[bool, 'UserArgsFromBranch']
    items: Union[bool, 'FindManySaleItemArgsFromBranch']
    payments: Union[bool, 'FindManyPaymentArgsFromBranch']
    returns: Union[bool, 'FindManyReturnSaleArgsFromBranch']
    deletedBy: Union[bool, 'UserArgsFromBranch']


class SaleArgsFromBranch(TypedDict, total=False):
    """Arguments for Branch"""
    include: 'SaleIncludeFromSale'


class FindManySaleArgsFromBranch(TypedDict, total=False):
    """Arguments for Branch"""
    take: int
    skip: int
    order_by: Union['SaleOrderByInput', List['SaleOrderByInput']]
    where: 'SaleWhereInput'
    cursor: 'SaleWhereUniqueInput'
    distinct: List['SaleScalarFieldKeys']
    include: 'SaleIncludeFromSale'


class SaleItemIncludeFromBranch(TypedDict, total=False):
    """Relational arguments for Branch"""
    sale: Union[bool, 'SaleArgsFromBranch']
    stock: Union[bool, 'StockArgsFromBranch']
    ReturnItem: Union[bool, 'FindManyReturnItemArgsFromBranch']


class SaleItemArgsFromBranch(TypedDict, total=False):
    """Arguments for Branch"""
    include: 'SaleItemIncludeFromSaleItem'


class FindManySaleItemArgsFromBranch(TypedDict, total=False):
    """Arguments for Branch"""
    take: int
    skip: int
    order_by: Union['SaleItemOrderByInput', List['SaleItemOrderByInput']]
    where: 'SaleItemWhereInput'
    cursor: 'SaleItemWhereUniqueInput'
    distinct: List['SaleItemScalarFieldKeys']
    include: 'SaleItemIncludeFromSaleItem'


class ReturnSaleIncludeFromBranch(TypedDict, total=False):
    """Relational arguments for Branch"""
    original: Union[bool, 'SaleArgsFromBranch']
    items: Union[bool, 'FindManyReturnItemArgsFromBranch']
    refund: Union[bool, 'FindManyPaymentArgsFromBranch']


class ReturnSaleArgsFromBranch(TypedDict, total=False):
    """Arguments for Branch"""
    include: 'ReturnSaleIncludeFromReturnSale'


class FindManyReturnSaleArgsFromBranch(TypedDict, total=False):
    """Arguments for Branch"""
    take: int
    skip: int
    order_by: Union['ReturnSaleOrderByInput', List['ReturnSaleOrderByInput']]
    where: 'ReturnSaleWhereInput'
    cursor: 'ReturnSaleWhereUniqueInput'
    distinct: List['ReturnSaleScalarFieldKeys']
    include: 'ReturnSaleIncludeFromReturnSale'


class ReturnItemIncludeFromBranch(TypedDict, total=False):
    """Relational arguments for Branch"""
    returnSale: Union[bool, 'ReturnSaleArgsFromBranch']
    saleItem: Union[bool, 'SaleItemArgsFromBranch']


class ReturnItemArgsFromBranch(TypedDict, total=False):
    """Arguments for Branch"""
    include: 'ReturnItemIncludeFromReturnItem'


class FindManyReturnItemArgsFromBranch(TypedDict, total=False):
    """Arguments for Branch"""
    take: int
    skip: int
    order_by: Union['ReturnItemOrderByInput', List['ReturnItemOrderByInput']]
    where: 'ReturnItemWhereInput'
    cursor: 'ReturnItemWhereUniqueInput'
    distinct: List['ReturnItemScalarFieldKeys']
    include: 'ReturnItemIncludeFromReturnItem'


class PaymentIncludeFromBranch(TypedDict, total=False):
    """Relational arguments for Branch"""
    sale: Union[bool, 'SaleArgsFromBranch']
    account: Union[bool, 'AccountArgsFromBranch']
    returnSale: Union[bool, 'ReturnSaleArgsFromBranch']
    user: Union[bool, 'UserArgsFromBranch']


class PaymentArgsFromBranch(TypedDict, total=False):
    """Arguments for Branch"""
    include: 'PaymentIncludeFromPayment'


class FindManyPaymentArgsFromBranch(TypedDict, total=False):
    """Arguments for Branch"""
    take: int
    skip: int
    order_by: Union['PaymentOrderByInput', List['PaymentOrderByInput']]
    where: 'PaymentWhereInput'
    cursor: 'PaymentWhereUniqueInput'
    distinct: List['PaymentScalarFieldKeys']
    include: 'PaymentIncludeFromPayment'


class JournalEntryIncludeFromBranch(TypedDict, total=False):
    """Relational arguments for Branch"""
    lines: Union[bool, 'FindManyJournalEntryLineArgsFromBranch']


class JournalEntryArgsFromBranch(TypedDict, total=False):
    """Arguments for Branch"""
    include: 'JournalEntryIncludeFromJournalEntry'


class FindManyJournalEntryArgsFromBranch(TypedDict, total=False):
    """Arguments for Branch"""
    take: int
    skip: int
    order_by: Union['JournalEntryOrderByInput', List['JournalEntryOrderByInput']]
    where: 'JournalEntryWhereInput'
    cursor: 'JournalEntryWhereUniqueInput'
    distinct: List['JournalEntryScalarFieldKeys']
    include: 'JournalEntryIncludeFromJournalEntry'


class JournalEntryLineIncludeFromBranch(TypedDict, total=False):
    """Relational arguments for Branch"""
    entry: Union[bool, 'JournalEntryArgsFromBranch']
    account: Union[bool, 'AccountArgsFromBranch']


class JournalEntryLineArgsFromBranch(TypedDict, total=False):
    """Arguments for Branch"""
    include: 'JournalEntryLineIncludeFromJournalEntryLine'


class FindManyJournalEntryLineArgsFromBranch(TypedDict, total=False):
    """Arguments for Branch"""
    take: int
    skip: int
    order_by: Union['JournalEntryLineOrderByInput', List['JournalEntryLineOrderByInput']]
    where: 'JournalEntryLineWhereInput'
    cursor: 'JournalEntryLineWhereUniqueInput'
    distinct: List['JournalEntryLineScalarFieldKeys']
    include: 'JournalEntryLineIncludeFromJournalEntryLine'


class AccountIncludeFromBranch(TypedDict, total=False):
    """Relational arguments for Branch"""
    branch: Union[bool, 'BranchArgsFromBranch']
    entries: Union[bool, 'FindManyJournalEntryLineArgsFromBranch']
    payments: Union[bool, 'FindManyPaymentArgsFromBranch']
    outgoingTransfers: Union[bool, 'FindManyAccountTransferArgsFromBranch']
    incomingTransfers: Union[bool, 'FindManyAccountTransferArgsFromBranch']


class AccountArgsFromBranch(TypedDict, total=False):
    """Arguments for Branch"""
    include: 'AccountIncludeFromAccount'


class FindManyAccountArgsFromBranch(TypedDict, total=False):
    """Arguments for Branch"""
    take: int
    skip: int
    order_by: Union['AccountOrderByInput', List['AccountOrderByInput']]
    where: 'AccountWhereInput'
    cursor: 'AccountWhereUniqueInput'
    distinct: List['AccountScalarFieldKeys']
    include: 'AccountIncludeFromAccount'


class AccountTransferIncludeFromBranch(TypedDict, total=False):
    """Relational arguments for Branch"""
    fromAccount: Union[bool, 'AccountArgsFromBranch']
    toAccount: Union[bool, 'AccountArgsFromBranch']


class AccountTransferArgsFromBranch(TypedDict, total=False):
    """Arguments for Branch"""
    include: 'AccountTransferIncludeFromAccountTransfer'


class FindManyAccountTransferArgsFromBranch(TypedDict, total=False):
    """Arguments for Branch"""
    take: int
    skip: int
    order_by: Union['AccountTransferOrderByInput', List['AccountTransferOrderByInput']]
    where: 'AccountTransferWhereInput'
    cursor: 'AccountTransferWhereUniqueInput'
    distinct: List['AccountTransferScalarFieldKeys']
    include: 'AccountTransferIncludeFromAccountTransfer'


class BranchOrderIncludeFromBranch(TypedDict, total=False):
    """Relational arguments for Branch"""
    branch: Union[bool, 'BranchArgsFromBranch']
    requestedBy: Union[bool, 'UserArgsFromBranch']
    approvedBy: Union[bool, 'UserArgsFromBranch']
    sentBy: Union[bool, 'UserArgsFromBranch']
    receivedBy: Union[bool, 'UserArgsFromBranch']
    items: Union[bool, 'FindManyBranchOrderItemArgsFromBranch']


class BranchOrderArgsFromBranch(TypedDict, total=False):
    """Arguments for Branch"""
    include: 'BranchOrderIncludeFromBranchOrder'


class FindManyBranchOrderArgsFromBranch(TypedDict, total=False):
    """Arguments for Branch"""
    take: int
    skip: int
    order_by: Union['BranchOrderOrderByInput', List['BranchOrderOrderByInput']]
    where: 'BranchOrderWhereInput'
    cursor: 'BranchOrderWhereUniqueInput'
    distinct: List['BranchOrderScalarFieldKeys']
    include: 'BranchOrderIncludeFromBranchOrder'


class BranchOrderItemIncludeFromBranch(TypedDict, total=False):
    """Relational arguments for Branch"""
    branchOrder: Union[bool, 'BranchOrderArgsFromBranch']
    stock: Union[bool, 'StockArgsFromBranch']


class BranchOrderItemArgsFromBranch(TypedDict, total=False):
    """Arguments for Branch"""
    include: 'BranchOrderItemIncludeFromBranchOrderItem'


class FindManyBranchOrderItemArgsFromBranch(TypedDict, total=False):
    """Arguments for Branch"""
    take: int
    skip: int
    order_by: Union['BranchOrderItemOrderByInput', List['BranchOrderItemOrderByInput']]
    where: 'BranchOrderItemWhereInput'
    cursor: 'BranchOrderItemWhereUniqueInput'
    distinct: List['BranchOrderItemScalarFieldKeys']
    include: 'BranchOrderItemIncludeFromBranchOrderItem'


class AuditLogIncludeFromBranch(TypedDict, total=False):
    """Relational arguments for Branch"""
    user: Union[bool, 'UserArgsFromBranch']


class AuditLogArgsFromBranch(TypedDict, total=False):
    """Arguments for Branch"""
    include: 'AuditLogIncludeFromAuditLog'


class FindManyAuditLogArgsFromBranch(TypedDict, total=False):
    """Arguments for Branch"""
    take: int
    skip: int
    order_by: Union['AuditLogOrderByInput', List['AuditLogOrderByInput']]
    where: 'AuditLogWhereInput'
    cursor: 'AuditLogWhereUniqueInput'
    distinct: List['AuditLogScalarFieldKeys']
    include: 'AuditLogIncludeFromAuditLog'


class SystemInfoIncludeFromBranch(TypedDict, total=False):
    """Relational arguments for Branch"""


class SystemInfoArgsFromBranch(TypedDict, total=False):
    """Arguments for Branch"""
    include: 'SystemInfoIncludeFromSystemInfo'


class FindManySystemInfoArgsFromBranch(TypedDict, total=False):
    """Arguments for Branch"""
    take: int
    skip: int
    order_by: Union['SystemInfoOrderByInput', List['SystemInfoOrderByInput']]
    where: 'SystemInfoWhereInput'
    cursor: 'SystemInfoWhereUniqueInput'
    distinct: List['SystemInfoScalarFieldKeys']
    include: 'SystemInfoIncludeFromSystemInfo'


class BackupIncludeFromBranch(TypedDict, total=False):
    """Relational arguments for Branch"""
    createdBy: Union[bool, 'UserArgsFromBranch']


class BackupArgsFromBranch(TypedDict, total=False):
    """Arguments for Branch"""
    include: 'BackupIncludeFromBackup'


class FindManyBackupArgsFromBranch(TypedDict, total=False):
    """Arguments for Branch"""
    take: int
    skip: int
    order_by: Union['BackupOrderByInput', List['BackupOrderByInput']]
    where: 'BackupWhereInput'
    cursor: 'BackupWhereUniqueInput'
    distinct: List['BackupScalarFieldKeys']
    include: 'BackupIncludeFromBackup'


class RevokedTokenIncludeFromBranch(TypedDict, total=False):
    """Relational arguments for Branch"""
    user: Union[bool, 'UserArgsFromBranch']


class RevokedTokenArgsFromBranch(TypedDict, total=False):
    """Arguments for Branch"""
    include: 'RevokedTokenIncludeFromRevokedToken'


class FindManyRevokedTokenArgsFromBranch(TypedDict, total=False):
    """Arguments for Branch"""
    take: int
    skip: int
    order_by: Union['RevokedTokenOrderByInput', List['RevokedTokenOrderByInput']]
    where: 'RevokedTokenWhereInput'
    cursor: 'RevokedTokenWhereUniqueInput'
    distinct: List['RevokedTokenScalarFieldKeys']
    include: 'RevokedTokenIncludeFromRevokedToken'


class SystemSettingIncludeFromBranch(TypedDict, total=False):
    """Relational arguments for Branch"""


class SystemSettingArgsFromBranch(TypedDict, total=False):
    """Arguments for Branch"""
    include: 'SystemSettingIncludeFromSystemSetting'


class FindManySystemSettingArgsFromBranch(TypedDict, total=False):
    """Arguments for Branch"""
    take: int
    skip: int
    order_by: Union['SystemSettingOrderByInput', List['SystemSettingOrderByInput']]
    where: 'SystemSettingWhereInput'
    cursor: 'SystemSettingWhereUniqueInput'
    distinct: List['SystemSettingScalarFieldKeys']
    include: 'SystemSettingIncludeFromSystemSetting'


class NotificationIncludeFromBranch(TypedDict, total=False):
    """Relational arguments for Branch"""
    user: Union[bool, 'UserArgsFromBranch']


class NotificationArgsFromBranch(TypedDict, total=False):
    """Arguments for Branch"""
    include: 'NotificationIncludeFromNotification'


class FindManyNotificationArgsFromBranch(TypedDict, total=False):
    """Arguments for Branch"""
    take: int
    skip: int
    order_by: Union['NotificationOrderByInput', List['NotificationOrderByInput']]
    where: 'NotificationWhereInput'
    cursor: 'NotificationWhereUniqueInput'
    distinct: List['NotificationScalarFieldKeys']
    include: 'NotificationIncludeFromNotification'


class StockAdjustmentIncludeFromBranch(TypedDict, total=False):
    """Relational arguments for Branch"""
    product: Union[bool, 'ProductArgsFromBranch']
    createdBy: Union[bool, 'UserArgsFromBranch']


class StockAdjustmentArgsFromBranch(TypedDict, total=False):
    """Arguments for Branch"""
    include: 'StockAdjustmentIncludeFromStockAdjustment'


class FindManyStockAdjustmentArgsFromBranch(TypedDict, total=False):
    """Arguments for Branch"""
    take: int
    skip: int
    order_by: Union['StockAdjustmentOrderByInput', List['StockAdjustmentOrderByInput']]
    where: 'StockAdjustmentWhereInput'
    cursor: 'StockAdjustmentWhereUniqueInput'
    distinct: List['StockAdjustmentScalarFieldKeys']
    include: 'StockAdjustmentIncludeFromStockAdjustment'




FindManyBranchArgs = FindManyBranchArgsFromBranch
FindFirstBranchArgs = FindManyBranchArgsFromBranch


class BranchWhereInput(TypedDict, total=False):
    """Branch arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    name: Union[_str, 'types.StringFilter']
    address: Union[None, _str, 'types.StringFilter']
    phone: Union[None, _str, 'types.StringFilter']
    isActive: Union[_bool, 'types.BooleanFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    users: 'UserListRelationFilter'
    Sale: 'SaleListRelationFilter'
    Account: 'AccountListRelationFilter'
    BranchOrder: 'BranchOrderListRelationFilter'

    # should be noted that AND and NOT should be Union['BranchWhereInput', List['BranchWhereInput']]
    # but this causes mypy to hang :/
    AND: List['BranchWhereInput']
    OR: List['BranchWhereInput']
    NOT: List['BranchWhereInput']



# aggregate Branch types


class BranchScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Branch arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    address: Union[_str, 'types.StringWithAggregatesFilter']
    phone: Union[_str, 'types.StringWithAggregatesFilter']
    isActive: Union[_bool, 'types.BooleanWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['BranchScalarWhereWithAggregatesInput']
    OR: List['BranchScalarWhereWithAggregatesInput']
    NOT: List['BranchScalarWhereWithAggregatesInput']



class BranchGroupByOutput(TypedDict, total=False):
    id: _int
    name: _str
    address: _str
    phone: _str
    isActive: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'BranchSumAggregateOutput'
    _avg: 'BranchAvgAggregateOutput'
    _min: 'BranchMinAggregateOutput'
    _max: 'BranchMaxAggregateOutput'
    _count: 'BranchCountAggregateOutput'


class BranchAvgAggregateOutput(TypedDict, total=False):
    """Branch output for aggregating averages"""
    id: float


class BranchSumAggregateOutput(TypedDict, total=False):
    """Branch output for aggregating sums"""
    id: _int


class BranchScalarAggregateOutput(TypedDict, total=False):
    """Branch output including scalar fields"""
    id: _int
    name: _str
    address: _str
    phone: _str
    isActive: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


BranchMinAggregateOutput = BranchScalarAggregateOutput
BranchMaxAggregateOutput = BranchScalarAggregateOutput


class BranchMaxAggregateInput(TypedDict, total=False):
    """Branch input for aggregating by max"""
    id: bool
    name: bool
    address: bool
    phone: bool
    isActive: bool
    createdAt: bool
    updatedAt: bool


class BranchMinAggregateInput(TypedDict, total=False):
    """Branch input for aggregating by min"""
    id: bool
    name: bool
    address: bool
    phone: bool
    isActive: bool
    createdAt: bool
    updatedAt: bool


class BranchNumberAggregateInput(TypedDict, total=False):
    """Branch input for aggregating numbers"""
    id: bool


BranchAvgAggregateInput = BranchNumberAggregateInput
BranchSumAggregateInput = BranchNumberAggregateInput


BranchCountAggregateInput = TypedDict(
    'BranchCountAggregateInput',
    {
        'id': bool,
        'name': bool,
        'address': bool,
        'phone': bool,
        'isActive': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

BranchCountAggregateOutput = TypedDict(
    'BranchCountAggregateOutput',
    {
        'id': int,
        'name': int,
        'address': int,
        'phone': int,
        'isActive': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


BranchKeys = Literal[
    'id',
    'name',
    'address',
    'phone',
    'isActive',
    'createdAt',
    'updatedAt',
    'users',
    'Sale',
    'Account',
    'BranchOrder',
]
BranchScalarFieldKeys = Literal[
    'id',
    'name',
    'address',
    'phone',
    'isActive',
    'createdAt',
    'updatedAt',
]
BranchScalarFieldKeysT = TypeVar('BranchScalarFieldKeysT', bound=BranchScalarFieldKeys)

BranchRelationalFieldKeys = Literal[
        'users',
        'Sale',
        'Account',
        'BranchOrder',
    ]

# Product types

class ProductOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Product create method"""
    id: _int
    barcode: Optional[_str]
    description: Optional[_str]
    categoryId: Optional[_int]
    category: 'CategoryCreateNestedWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    stocks: 'StockCreateManyNestedWithoutRelationsInput'
    stockAdjustments: 'StockAdjustmentCreateManyNestedWithoutRelationsInput'


class ProductCreateInput(ProductOptionalCreateInput):
    """Required arguments to the Product create method"""
    sku: _str
    name: _str
    costPrice: decimal.Decimal
    sellingPrice: decimal.Decimal


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class ProductOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Product create method, without relations"""
    id: _int
    barcode: Optional[_str]
    description: Optional[_str]
    categoryId: Optional[_int]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class ProductCreateWithoutRelationsInput(ProductOptionalCreateWithoutRelationsInput):
    """Required arguments to the Product create method, without relations"""
    sku: _str
    name: _str
    costPrice: decimal.Decimal
    sellingPrice: decimal.Decimal


class ProductCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'ProductCreateWithoutRelationsInput'
    connect: 'ProductWhereUniqueInput'


class ProductCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['ProductCreateWithoutRelationsInput', List['ProductCreateWithoutRelationsInput']]
    connect: Union['ProductWhereUniqueInput', List['ProductWhereUniqueInput']]


_ProductWhereUnique_id_Input = TypedDict(
    '_ProductWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

_ProductWhereUnique_sku_Input = TypedDict(
    '_ProductWhereUnique_sku_Input',
    {
        'sku': '_str',
    },
    total=True
)

_ProductWhereUnique_barcode_Input = TypedDict(
    '_ProductWhereUnique_barcode_Input',
    {
        'barcode': '_str',
    },
    total=True
)

ProductWhereUniqueInput = Union[
    '_ProductWhereUnique_id_Input',
    '_ProductWhereUnique_sku_Input',
    '_ProductWhereUnique_barcode_Input',
]


class ProductUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    sku: _str
    name: _str
    barcode: Optional[_str]
    description: Optional[_str]
    costPrice: decimal.Decimal
    sellingPrice: decimal.Decimal
    category: 'CategoryUpdateOneWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    stocks: 'StockUpdateManyWithoutRelationsInput'
    stockAdjustments: 'StockAdjustmentUpdateManyWithoutRelationsInput'


class ProductUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    sku: _str
    name: _str
    barcode: Optional[_str]
    description: Optional[_str]
    costPrice: decimal.Decimal
    sellingPrice: decimal.Decimal
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class ProductUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['ProductCreateWithoutRelationsInput']
    connect: List['ProductWhereUniqueInput']
    set: List['ProductWhereUniqueInput']
    disconnect: List['ProductWhereUniqueInput']
    delete: List['ProductWhereUniqueInput']

    # TODO
    # update: List['ProductUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['ProductUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['ProductScalarWhereInput']
    # upsert: List['ProductUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['ProductCreateOrConnectWithoutRelationsInput']


class ProductUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'ProductCreateWithoutRelationsInput'
    connect: 'ProductWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'ProductUpdateInput'
    # upsert: 'ProductUpsertWithoutRelationsInput'
    # connectOrCreate: 'ProductCreateOrConnectWithoutRelationsInput'


class ProductUpsertInput(TypedDict):
    create: 'ProductCreateInput'
    update: 'ProductUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Product_id_OrderByInput = TypedDict(
    '_Product_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Product_sku_OrderByInput = TypedDict(
    '_Product_sku_OrderByInput',
    {
        'sku': 'SortOrder',
    },
    total=True
)

_Product_name_OrderByInput = TypedDict(
    '_Product_name_OrderByInput',
    {
        'name': 'SortOrder',
    },
    total=True
)

_Product_barcode_OrderByInput = TypedDict(
    '_Product_barcode_OrderByInput',
    {
        'barcode': 'SortOrder',
    },
    total=True
)

_Product_description_OrderByInput = TypedDict(
    '_Product_description_OrderByInput',
    {
        'description': 'SortOrder',
    },
    total=True
)

_Product_costPrice_OrderByInput = TypedDict(
    '_Product_costPrice_OrderByInput',
    {
        'costPrice': 'SortOrder',
    },
    total=True
)

_Product_sellingPrice_OrderByInput = TypedDict(
    '_Product_sellingPrice_OrderByInput',
    {
        'sellingPrice': 'SortOrder',
    },
    total=True
)

_Product_categoryId_OrderByInput = TypedDict(
    '_Product_categoryId_OrderByInput',
    {
        'categoryId': 'SortOrder',
    },
    total=True
)

_Product_createdAt_OrderByInput = TypedDict(
    '_Product_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Product_updatedAt_OrderByInput = TypedDict(
    '_Product_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

ProductOrderByInput = Union[
    '_Product_id_OrderByInput',
    '_Product_sku_OrderByInput',
    '_Product_name_OrderByInput',
    '_Product_barcode_OrderByInput',
    '_Product_description_OrderByInput',
    '_Product_costPrice_OrderByInput',
    '_Product_sellingPrice_OrderByInput',
    '_Product_categoryId_OrderByInput',
    '_Product_createdAt_OrderByInput',
    '_Product_updatedAt_OrderByInput',
]



# recursive Product types
# TODO: cleanup these types



ProductRelationFilter = TypedDict(
    'ProductRelationFilter',
    {
        'is': 'ProductWhereInput',
        'is_not': 'ProductWhereInput',
    },
    total=False,
)


class ProductListRelationFilter(TypedDict, total=False):
    some: 'ProductWhereInput'
    none: 'ProductWhereInput'
    every: 'ProductWhereInput'


class ProductInclude(TypedDict, total=False):
    """Product relational arguments"""
    category: Union[bool, 'CategoryArgsFromProduct']
    stocks: Union[bool, 'FindManyStockArgsFromProduct']
    stockAdjustments: Union[bool, 'FindManyStockAdjustmentArgsFromProduct']


class UserIncludeFromProduct(TypedDict, total=False):
    """Relational arguments for Product"""
    branch: Union[bool, 'BranchArgsFromProduct']
    auditLogs: Union[bool, 'FindManyAuditLogArgsFromProduct']
    permissions: Union[bool, 'FindManyUserPermissionArgsFromProduct']
    notifications: Union[bool, 'FindManyNotificationArgsFromProduct']
    revokedTokens: Union[bool, 'FindManyRevokedTokenArgsFromProduct']
    stockAdjustments: Union[bool, 'FindManyStockAdjustmentArgsFromProduct']
    Sale: Union[bool, 'FindManySaleArgsFromProduct']
    deletedSales: Union[bool, 'FindManySaleArgsFromProduct']
    Payment: Union[bool, 'FindManyPaymentArgsFromProduct']
    Backup: Union[bool, 'FindManyBackupArgsFromProduct']
    requestedOrders: Union[bool, 'FindManyBranchOrderArgsFromProduct']
    approvedOrders: Union[bool, 'FindManyBranchOrderArgsFromProduct']
    sentOrders: Union[bool, 'FindManyBranchOrderArgsFromProduct']
    receivedOrders: Union[bool, 'FindManyBranchOrderArgsFromProduct']


class UserArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class UserPermissionIncludeFromProduct(TypedDict, total=False):
    """Relational arguments for Product"""
    user: Union[bool, 'UserArgsFromProduct']


class UserPermissionArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    include: 'UserPermissionIncludeFromUserPermission'


class FindManyUserPermissionArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['UserPermissionOrderByInput', List['UserPermissionOrderByInput']]
    where: 'UserPermissionWhereInput'
    cursor: 'UserPermissionWhereUniqueInput'
    distinct: List['UserPermissionScalarFieldKeys']
    include: 'UserPermissionIncludeFromUserPermission'


class BranchIncludeFromProduct(TypedDict, total=False):
    """Relational arguments for Product"""
    users: Union[bool, 'FindManyUserArgsFromProduct']
    Sale: Union[bool, 'FindManySaleArgsFromProduct']
    Account: Union[bool, 'FindManyAccountArgsFromProduct']
    BranchOrder: Union[bool, 'FindManyBranchOrderArgsFromProduct']


class BranchArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    include: 'BranchIncludeFromBranch'


class FindManyBranchArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['BranchOrderByInput', List['BranchOrderByInput']]
    where: 'BranchWhereInput'
    cursor: 'BranchWhereUniqueInput'
    distinct: List['BranchScalarFieldKeys']
    include: 'BranchIncludeFromBranch'


class ProductIncludeFromProduct(TypedDict, total=False):
    """Relational arguments for Product"""
    category: Union[bool, 'CategoryArgsFromProduct']
    stocks: Union[bool, 'FindManyStockArgsFromProduct']
    stockAdjustments: Union[bool, 'FindManyStockAdjustmentArgsFromProduct']


class ProductArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    include: 'ProductIncludeFromProduct'


class FindManyProductArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProduct'


class CategoryIncludeFromProduct(TypedDict, total=False):
    """Relational arguments for Product"""
    products: Union[bool, 'FindManyProductArgsFromProduct']


class CategoryArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    include: 'CategoryIncludeFromCategory'


class FindManyCategoryArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['CategoryOrderByInput', List['CategoryOrderByInput']]
    where: 'CategoryWhereInput'
    cursor: 'CategoryWhereUniqueInput'
    distinct: List['CategoryScalarFieldKeys']
    include: 'CategoryIncludeFromCategory'


class StockIncludeFromProduct(TypedDict, total=False):
    """Relational arguments for Product"""
    product: Union[bool, 'ProductArgsFromProduct']
    SaleItem: Union[bool, 'FindManySaleItemArgsFromProduct']
    BranchOrderItem: Union[bool, 'FindManyBranchOrderItemArgsFromProduct']


class StockArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    include: 'StockIncludeFromStock'


class FindManyStockArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['StockOrderByInput', List['StockOrderByInput']]
    where: 'StockWhereInput'
    cursor: 'StockWhereUniqueInput'
    distinct: List['StockScalarFieldKeys']
    include: 'StockIncludeFromStock'


class CustomerIncludeFromProduct(TypedDict, total=False):
    """Relational arguments for Product"""
    Sale: Union[bool, 'FindManySaleArgsFromProduct']


class CustomerArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    include: 'CustomerIncludeFromCustomer'


class FindManyCustomerArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['CustomerOrderByInput', List['CustomerOrderByInput']]
    where: 'CustomerWhereInput'
    cursor: 'CustomerWhereUniqueInput'
    distinct: List['CustomerScalarFieldKeys']
    include: 'CustomerIncludeFromCustomer'


class SaleIncludeFromProduct(TypedDict, total=False):
    """Relational arguments for Product"""
    branch: Union[bool, 'BranchArgsFromProduct']
    customer: Union[bool, 'CustomerArgsFromProduct']
    user: Union[bool, 'UserArgsFromProduct']
    items: Union[bool, 'FindManySaleItemArgsFromProduct']
    payments: Union[bool, 'FindManyPaymentArgsFromProduct']
    returns: Union[bool, 'FindManyReturnSaleArgsFromProduct']
    deletedBy: Union[bool, 'UserArgsFromProduct']


class SaleArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    include: 'SaleIncludeFromSale'


class FindManySaleArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['SaleOrderByInput', List['SaleOrderByInput']]
    where: 'SaleWhereInput'
    cursor: 'SaleWhereUniqueInput'
    distinct: List['SaleScalarFieldKeys']
    include: 'SaleIncludeFromSale'


class SaleItemIncludeFromProduct(TypedDict, total=False):
    """Relational arguments for Product"""
    sale: Union[bool, 'SaleArgsFromProduct']
    stock: Union[bool, 'StockArgsFromProduct']
    ReturnItem: Union[bool, 'FindManyReturnItemArgsFromProduct']


class SaleItemArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    include: 'SaleItemIncludeFromSaleItem'


class FindManySaleItemArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['SaleItemOrderByInput', List['SaleItemOrderByInput']]
    where: 'SaleItemWhereInput'
    cursor: 'SaleItemWhereUniqueInput'
    distinct: List['SaleItemScalarFieldKeys']
    include: 'SaleItemIncludeFromSaleItem'


class ReturnSaleIncludeFromProduct(TypedDict, total=False):
    """Relational arguments for Product"""
    original: Union[bool, 'SaleArgsFromProduct']
    items: Union[bool, 'FindManyReturnItemArgsFromProduct']
    refund: Union[bool, 'FindManyPaymentArgsFromProduct']


class ReturnSaleArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    include: 'ReturnSaleIncludeFromReturnSale'


class FindManyReturnSaleArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['ReturnSaleOrderByInput', List['ReturnSaleOrderByInput']]
    where: 'ReturnSaleWhereInput'
    cursor: 'ReturnSaleWhereUniqueInput'
    distinct: List['ReturnSaleScalarFieldKeys']
    include: 'ReturnSaleIncludeFromReturnSale'


class ReturnItemIncludeFromProduct(TypedDict, total=False):
    """Relational arguments for Product"""
    returnSale: Union[bool, 'ReturnSaleArgsFromProduct']
    saleItem: Union[bool, 'SaleItemArgsFromProduct']


class ReturnItemArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    include: 'ReturnItemIncludeFromReturnItem'


class FindManyReturnItemArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['ReturnItemOrderByInput', List['ReturnItemOrderByInput']]
    where: 'ReturnItemWhereInput'
    cursor: 'ReturnItemWhereUniqueInput'
    distinct: List['ReturnItemScalarFieldKeys']
    include: 'ReturnItemIncludeFromReturnItem'


class PaymentIncludeFromProduct(TypedDict, total=False):
    """Relational arguments for Product"""
    sale: Union[bool, 'SaleArgsFromProduct']
    account: Union[bool, 'AccountArgsFromProduct']
    returnSale: Union[bool, 'ReturnSaleArgsFromProduct']
    user: Union[bool, 'UserArgsFromProduct']


class PaymentArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    include: 'PaymentIncludeFromPayment'


class FindManyPaymentArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['PaymentOrderByInput', List['PaymentOrderByInput']]
    where: 'PaymentWhereInput'
    cursor: 'PaymentWhereUniqueInput'
    distinct: List['PaymentScalarFieldKeys']
    include: 'PaymentIncludeFromPayment'


class JournalEntryIncludeFromProduct(TypedDict, total=False):
    """Relational arguments for Product"""
    lines: Union[bool, 'FindManyJournalEntryLineArgsFromProduct']


class JournalEntryArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    include: 'JournalEntryIncludeFromJournalEntry'


class FindManyJournalEntryArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['JournalEntryOrderByInput', List['JournalEntryOrderByInput']]
    where: 'JournalEntryWhereInput'
    cursor: 'JournalEntryWhereUniqueInput'
    distinct: List['JournalEntryScalarFieldKeys']
    include: 'JournalEntryIncludeFromJournalEntry'


class JournalEntryLineIncludeFromProduct(TypedDict, total=False):
    """Relational arguments for Product"""
    entry: Union[bool, 'JournalEntryArgsFromProduct']
    account: Union[bool, 'AccountArgsFromProduct']


class JournalEntryLineArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    include: 'JournalEntryLineIncludeFromJournalEntryLine'


class FindManyJournalEntryLineArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['JournalEntryLineOrderByInput', List['JournalEntryLineOrderByInput']]
    where: 'JournalEntryLineWhereInput'
    cursor: 'JournalEntryLineWhereUniqueInput'
    distinct: List['JournalEntryLineScalarFieldKeys']
    include: 'JournalEntryLineIncludeFromJournalEntryLine'


class AccountIncludeFromProduct(TypedDict, total=False):
    """Relational arguments for Product"""
    branch: Union[bool, 'BranchArgsFromProduct']
    entries: Union[bool, 'FindManyJournalEntryLineArgsFromProduct']
    payments: Union[bool, 'FindManyPaymentArgsFromProduct']
    outgoingTransfers: Union[bool, 'FindManyAccountTransferArgsFromProduct']
    incomingTransfers: Union[bool, 'FindManyAccountTransferArgsFromProduct']


class AccountArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    include: 'AccountIncludeFromAccount'


class FindManyAccountArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['AccountOrderByInput', List['AccountOrderByInput']]
    where: 'AccountWhereInput'
    cursor: 'AccountWhereUniqueInput'
    distinct: List['AccountScalarFieldKeys']
    include: 'AccountIncludeFromAccount'


class AccountTransferIncludeFromProduct(TypedDict, total=False):
    """Relational arguments for Product"""
    fromAccount: Union[bool, 'AccountArgsFromProduct']
    toAccount: Union[bool, 'AccountArgsFromProduct']


class AccountTransferArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    include: 'AccountTransferIncludeFromAccountTransfer'


class FindManyAccountTransferArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['AccountTransferOrderByInput', List['AccountTransferOrderByInput']]
    where: 'AccountTransferWhereInput'
    cursor: 'AccountTransferWhereUniqueInput'
    distinct: List['AccountTransferScalarFieldKeys']
    include: 'AccountTransferIncludeFromAccountTransfer'


class BranchOrderIncludeFromProduct(TypedDict, total=False):
    """Relational arguments for Product"""
    branch: Union[bool, 'BranchArgsFromProduct']
    requestedBy: Union[bool, 'UserArgsFromProduct']
    approvedBy: Union[bool, 'UserArgsFromProduct']
    sentBy: Union[bool, 'UserArgsFromProduct']
    receivedBy: Union[bool, 'UserArgsFromProduct']
    items: Union[bool, 'FindManyBranchOrderItemArgsFromProduct']


class BranchOrderArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    include: 'BranchOrderIncludeFromBranchOrder'


class FindManyBranchOrderArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['BranchOrderOrderByInput', List['BranchOrderOrderByInput']]
    where: 'BranchOrderWhereInput'
    cursor: 'BranchOrderWhereUniqueInput'
    distinct: List['BranchOrderScalarFieldKeys']
    include: 'BranchOrderIncludeFromBranchOrder'


class BranchOrderItemIncludeFromProduct(TypedDict, total=False):
    """Relational arguments for Product"""
    branchOrder: Union[bool, 'BranchOrderArgsFromProduct']
    stock: Union[bool, 'StockArgsFromProduct']


class BranchOrderItemArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    include: 'BranchOrderItemIncludeFromBranchOrderItem'


class FindManyBranchOrderItemArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['BranchOrderItemOrderByInput', List['BranchOrderItemOrderByInput']]
    where: 'BranchOrderItemWhereInput'
    cursor: 'BranchOrderItemWhereUniqueInput'
    distinct: List['BranchOrderItemScalarFieldKeys']
    include: 'BranchOrderItemIncludeFromBranchOrderItem'


class AuditLogIncludeFromProduct(TypedDict, total=False):
    """Relational arguments for Product"""
    user: Union[bool, 'UserArgsFromProduct']


class AuditLogArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    include: 'AuditLogIncludeFromAuditLog'


class FindManyAuditLogArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['AuditLogOrderByInput', List['AuditLogOrderByInput']]
    where: 'AuditLogWhereInput'
    cursor: 'AuditLogWhereUniqueInput'
    distinct: List['AuditLogScalarFieldKeys']
    include: 'AuditLogIncludeFromAuditLog'


class SystemInfoIncludeFromProduct(TypedDict, total=False):
    """Relational arguments for Product"""


class SystemInfoArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    include: 'SystemInfoIncludeFromSystemInfo'


class FindManySystemInfoArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['SystemInfoOrderByInput', List['SystemInfoOrderByInput']]
    where: 'SystemInfoWhereInput'
    cursor: 'SystemInfoWhereUniqueInput'
    distinct: List['SystemInfoScalarFieldKeys']
    include: 'SystemInfoIncludeFromSystemInfo'


class BackupIncludeFromProduct(TypedDict, total=False):
    """Relational arguments for Product"""
    createdBy: Union[bool, 'UserArgsFromProduct']


class BackupArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    include: 'BackupIncludeFromBackup'


class FindManyBackupArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['BackupOrderByInput', List['BackupOrderByInput']]
    where: 'BackupWhereInput'
    cursor: 'BackupWhereUniqueInput'
    distinct: List['BackupScalarFieldKeys']
    include: 'BackupIncludeFromBackup'


class RevokedTokenIncludeFromProduct(TypedDict, total=False):
    """Relational arguments for Product"""
    user: Union[bool, 'UserArgsFromProduct']


class RevokedTokenArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    include: 'RevokedTokenIncludeFromRevokedToken'


class FindManyRevokedTokenArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['RevokedTokenOrderByInput', List['RevokedTokenOrderByInput']]
    where: 'RevokedTokenWhereInput'
    cursor: 'RevokedTokenWhereUniqueInput'
    distinct: List['RevokedTokenScalarFieldKeys']
    include: 'RevokedTokenIncludeFromRevokedToken'


class SystemSettingIncludeFromProduct(TypedDict, total=False):
    """Relational arguments for Product"""


class SystemSettingArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    include: 'SystemSettingIncludeFromSystemSetting'


class FindManySystemSettingArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['SystemSettingOrderByInput', List['SystemSettingOrderByInput']]
    where: 'SystemSettingWhereInput'
    cursor: 'SystemSettingWhereUniqueInput'
    distinct: List['SystemSettingScalarFieldKeys']
    include: 'SystemSettingIncludeFromSystemSetting'


class NotificationIncludeFromProduct(TypedDict, total=False):
    """Relational arguments for Product"""
    user: Union[bool, 'UserArgsFromProduct']


class NotificationArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    include: 'NotificationIncludeFromNotification'


class FindManyNotificationArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['NotificationOrderByInput', List['NotificationOrderByInput']]
    where: 'NotificationWhereInput'
    cursor: 'NotificationWhereUniqueInput'
    distinct: List['NotificationScalarFieldKeys']
    include: 'NotificationIncludeFromNotification'


class StockAdjustmentIncludeFromProduct(TypedDict, total=False):
    """Relational arguments for Product"""
    product: Union[bool, 'ProductArgsFromProduct']
    createdBy: Union[bool, 'UserArgsFromProduct']


class StockAdjustmentArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    include: 'StockAdjustmentIncludeFromStockAdjustment'


class FindManyStockAdjustmentArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['StockAdjustmentOrderByInput', List['StockAdjustmentOrderByInput']]
    where: 'StockAdjustmentWhereInput'
    cursor: 'StockAdjustmentWhereUniqueInput'
    distinct: List['StockAdjustmentScalarFieldKeys']
    include: 'StockAdjustmentIncludeFromStockAdjustment'




FindManyProductArgs = FindManyProductArgsFromProduct
FindFirstProductArgs = FindManyProductArgsFromProduct


class ProductWhereInput(TypedDict, total=False):
    """Product arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    sku: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    barcode: Union[None, _str, 'types.StringFilter']
    description: Union[None, _str, 'types.StringFilter']
    costPrice: Union[decimal.Decimal, 'types.DecimalFilter']
    sellingPrice: Union[decimal.Decimal, 'types.DecimalFilter']
    categoryId: Union[None, _int, 'types.IntFilter']
    category: 'CategoryRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    stocks: 'StockListRelationFilter'
    stockAdjustments: 'StockAdjustmentListRelationFilter'

    # should be noted that AND and NOT should be Union['ProductWhereInput', List['ProductWhereInput']]
    # but this causes mypy to hang :/
    AND: List['ProductWhereInput']
    OR: List['ProductWhereInput']
    NOT: List['ProductWhereInput']



# aggregate Product types


class ProductScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Product arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    sku: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    barcode: Union[_str, 'types.StringWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']
    costPrice: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    sellingPrice: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    categoryId: Union[_int, 'types.IntWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['ProductScalarWhereWithAggregatesInput']
    OR: List['ProductScalarWhereWithAggregatesInput']
    NOT: List['ProductScalarWhereWithAggregatesInput']



class ProductGroupByOutput(TypedDict, total=False):
    id: _int
    sku: _str
    name: _str
    barcode: _str
    description: _str
    costPrice: decimal.Decimal
    sellingPrice: decimal.Decimal
    categoryId: _int
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'ProductSumAggregateOutput'
    _avg: 'ProductAvgAggregateOutput'
    _min: 'ProductMinAggregateOutput'
    _max: 'ProductMaxAggregateOutput'
    _count: 'ProductCountAggregateOutput'


class ProductAvgAggregateOutput(TypedDict, total=False):
    """Product output for aggregating averages"""
    id: float
    categoryId: float


class ProductSumAggregateOutput(TypedDict, total=False):
    """Product output for aggregating sums"""
    id: _int
    categoryId: _int


class ProductScalarAggregateOutput(TypedDict, total=False):
    """Product output including scalar fields"""
    id: _int
    sku: _str
    name: _str
    barcode: _str
    description: _str
    costPrice: decimal.Decimal
    sellingPrice: decimal.Decimal
    categoryId: _int
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


ProductMinAggregateOutput = ProductScalarAggregateOutput
ProductMaxAggregateOutput = ProductScalarAggregateOutput


class ProductMaxAggregateInput(TypedDict, total=False):
    """Product input for aggregating by max"""
    id: bool
    sku: bool
    name: bool
    barcode: bool
    description: bool
    costPrice: bool
    sellingPrice: bool
    categoryId: bool
    createdAt: bool
    updatedAt: bool


class ProductMinAggregateInput(TypedDict, total=False):
    """Product input for aggregating by min"""
    id: bool
    sku: bool
    name: bool
    barcode: bool
    description: bool
    costPrice: bool
    sellingPrice: bool
    categoryId: bool
    createdAt: bool
    updatedAt: bool


class ProductNumberAggregateInput(TypedDict, total=False):
    """Product input for aggregating numbers"""
    id: bool
    categoryId: bool


ProductAvgAggregateInput = ProductNumberAggregateInput
ProductSumAggregateInput = ProductNumberAggregateInput


ProductCountAggregateInput = TypedDict(
    'ProductCountAggregateInput',
    {
        'id': bool,
        'sku': bool,
        'name': bool,
        'barcode': bool,
        'description': bool,
        'costPrice': bool,
        'sellingPrice': bool,
        'categoryId': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

ProductCountAggregateOutput = TypedDict(
    'ProductCountAggregateOutput',
    {
        'id': int,
        'sku': int,
        'name': int,
        'barcode': int,
        'description': int,
        'costPrice': int,
        'sellingPrice': int,
        'categoryId': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


ProductKeys = Literal[
    'id',
    'sku',
    'name',
    'barcode',
    'description',
    'costPrice',
    'sellingPrice',
    'categoryId',
    'category',
    'createdAt',
    'updatedAt',
    'stocks',
    'stockAdjustments',
]
ProductScalarFieldKeys = Literal[
    'id',
    'sku',
    'name',
    'barcode',
    'description',
    'costPrice',
    'sellingPrice',
    'categoryId',
    'createdAt',
    'updatedAt',
]
ProductScalarFieldKeysT = TypeVar('ProductScalarFieldKeysT', bound=ProductScalarFieldKeys)

ProductRelationalFieldKeys = Literal[
        'category',
        'stocks',
        'stockAdjustments',
    ]

# Category types

class CategoryOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Category create method"""
    id: _int
    description: Optional[_str]
    status: 'enums.CategoryStatus'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    products: 'ProductCreateManyNestedWithoutRelationsInput'


class CategoryCreateInput(CategoryOptionalCreateInput):
    """Required arguments to the Category create method"""
    name: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class CategoryOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Category create method, without relations"""
    id: _int
    description: Optional[_str]
    status: 'enums.CategoryStatus'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class CategoryCreateWithoutRelationsInput(CategoryOptionalCreateWithoutRelationsInput):
    """Required arguments to the Category create method, without relations"""
    name: _str


class CategoryCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'CategoryCreateWithoutRelationsInput'
    connect: 'CategoryWhereUniqueInput'


class CategoryCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['CategoryCreateWithoutRelationsInput', List['CategoryCreateWithoutRelationsInput']]
    connect: Union['CategoryWhereUniqueInput', List['CategoryWhereUniqueInput']]


_CategoryWhereUnique_id_Input = TypedDict(
    '_CategoryWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

_CategoryWhereUnique_name_Input = TypedDict(
    '_CategoryWhereUnique_name_Input',
    {
        'name': '_str',
    },
    total=True
)

CategoryWhereUniqueInput = Union[
    '_CategoryWhereUnique_id_Input',
    '_CategoryWhereUnique_name_Input',
]


class CategoryUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    name: _str
    description: Optional[_str]
    status: 'enums.CategoryStatus'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    products: 'ProductUpdateManyWithoutRelationsInput'


class CategoryUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    name: _str
    description: Optional[_str]
    status: 'enums.CategoryStatus'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class CategoryUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['CategoryCreateWithoutRelationsInput']
    connect: List['CategoryWhereUniqueInput']
    set: List['CategoryWhereUniqueInput']
    disconnect: List['CategoryWhereUniqueInput']
    delete: List['CategoryWhereUniqueInput']

    # TODO
    # update: List['CategoryUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['CategoryUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['CategoryScalarWhereInput']
    # upsert: List['CategoryUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['CategoryCreateOrConnectWithoutRelationsInput']


class CategoryUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'CategoryCreateWithoutRelationsInput'
    connect: 'CategoryWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'CategoryUpdateInput'
    # upsert: 'CategoryUpsertWithoutRelationsInput'
    # connectOrCreate: 'CategoryCreateOrConnectWithoutRelationsInput'


class CategoryUpsertInput(TypedDict):
    create: 'CategoryCreateInput'
    update: 'CategoryUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Category_id_OrderByInput = TypedDict(
    '_Category_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Category_name_OrderByInput = TypedDict(
    '_Category_name_OrderByInput',
    {
        'name': 'SortOrder',
    },
    total=True
)

_Category_description_OrderByInput = TypedDict(
    '_Category_description_OrderByInput',
    {
        'description': 'SortOrder',
    },
    total=True
)

_Category_status_OrderByInput = TypedDict(
    '_Category_status_OrderByInput',
    {
        'status': 'SortOrder',
    },
    total=True
)

_Category_createdAt_OrderByInput = TypedDict(
    '_Category_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Category_updatedAt_OrderByInput = TypedDict(
    '_Category_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

CategoryOrderByInput = Union[
    '_Category_id_OrderByInput',
    '_Category_name_OrderByInput',
    '_Category_description_OrderByInput',
    '_Category_status_OrderByInput',
    '_Category_createdAt_OrderByInput',
    '_Category_updatedAt_OrderByInput',
]



# recursive Category types
# TODO: cleanup these types



CategoryRelationFilter = TypedDict(
    'CategoryRelationFilter',
    {
        'is': 'CategoryWhereInput',
        'is_not': 'CategoryWhereInput',
    },
    total=False,
)


class CategoryListRelationFilter(TypedDict, total=False):
    some: 'CategoryWhereInput'
    none: 'CategoryWhereInput'
    every: 'CategoryWhereInput'


class CategoryInclude(TypedDict, total=False):
    """Category relational arguments"""
    products: Union[bool, 'FindManyProductArgsFromCategory']


class UserIncludeFromCategory(TypedDict, total=False):
    """Relational arguments for Category"""
    branch: Union[bool, 'BranchArgsFromCategory']
    auditLogs: Union[bool, 'FindManyAuditLogArgsFromCategory']
    permissions: Union[bool, 'FindManyUserPermissionArgsFromCategory']
    notifications: Union[bool, 'FindManyNotificationArgsFromCategory']
    revokedTokens: Union[bool, 'FindManyRevokedTokenArgsFromCategory']
    stockAdjustments: Union[bool, 'FindManyStockAdjustmentArgsFromCategory']
    Sale: Union[bool, 'FindManySaleArgsFromCategory']
    deletedSales: Union[bool, 'FindManySaleArgsFromCategory']
    Payment: Union[bool, 'FindManyPaymentArgsFromCategory']
    Backup: Union[bool, 'FindManyBackupArgsFromCategory']
    requestedOrders: Union[bool, 'FindManyBranchOrderArgsFromCategory']
    approvedOrders: Union[bool, 'FindManyBranchOrderArgsFromCategory']
    sentOrders: Union[bool, 'FindManyBranchOrderArgsFromCategory']
    receivedOrders: Union[bool, 'FindManyBranchOrderArgsFromCategory']


class UserArgsFromCategory(TypedDict, total=False):
    """Arguments for Category"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromCategory(TypedDict, total=False):
    """Arguments for Category"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class UserPermissionIncludeFromCategory(TypedDict, total=False):
    """Relational arguments for Category"""
    user: Union[bool, 'UserArgsFromCategory']


class UserPermissionArgsFromCategory(TypedDict, total=False):
    """Arguments for Category"""
    include: 'UserPermissionIncludeFromUserPermission'


class FindManyUserPermissionArgsFromCategory(TypedDict, total=False):
    """Arguments for Category"""
    take: int
    skip: int
    order_by: Union['UserPermissionOrderByInput', List['UserPermissionOrderByInput']]
    where: 'UserPermissionWhereInput'
    cursor: 'UserPermissionWhereUniqueInput'
    distinct: List['UserPermissionScalarFieldKeys']
    include: 'UserPermissionIncludeFromUserPermission'


class BranchIncludeFromCategory(TypedDict, total=False):
    """Relational arguments for Category"""
    users: Union[bool, 'FindManyUserArgsFromCategory']
    Sale: Union[bool, 'FindManySaleArgsFromCategory']
    Account: Union[bool, 'FindManyAccountArgsFromCategory']
    BranchOrder: Union[bool, 'FindManyBranchOrderArgsFromCategory']


class BranchArgsFromCategory(TypedDict, total=False):
    """Arguments for Category"""
    include: 'BranchIncludeFromBranch'


class FindManyBranchArgsFromCategory(TypedDict, total=False):
    """Arguments for Category"""
    take: int
    skip: int
    order_by: Union['BranchOrderByInput', List['BranchOrderByInput']]
    where: 'BranchWhereInput'
    cursor: 'BranchWhereUniqueInput'
    distinct: List['BranchScalarFieldKeys']
    include: 'BranchIncludeFromBranch'


class ProductIncludeFromCategory(TypedDict, total=False):
    """Relational arguments for Category"""
    category: Union[bool, 'CategoryArgsFromCategory']
    stocks: Union[bool, 'FindManyStockArgsFromCategory']
    stockAdjustments: Union[bool, 'FindManyStockAdjustmentArgsFromCategory']


class ProductArgsFromCategory(TypedDict, total=False):
    """Arguments for Category"""
    include: 'ProductIncludeFromProduct'


class FindManyProductArgsFromCategory(TypedDict, total=False):
    """Arguments for Category"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProduct'


class CategoryIncludeFromCategory(TypedDict, total=False):
    """Relational arguments for Category"""
    products: Union[bool, 'FindManyProductArgsFromCategory']


class CategoryArgsFromCategory(TypedDict, total=False):
    """Arguments for Category"""
    include: 'CategoryIncludeFromCategory'


class FindManyCategoryArgsFromCategory(TypedDict, total=False):
    """Arguments for Category"""
    take: int
    skip: int
    order_by: Union['CategoryOrderByInput', List['CategoryOrderByInput']]
    where: 'CategoryWhereInput'
    cursor: 'CategoryWhereUniqueInput'
    distinct: List['CategoryScalarFieldKeys']
    include: 'CategoryIncludeFromCategory'


class StockIncludeFromCategory(TypedDict, total=False):
    """Relational arguments for Category"""
    product: Union[bool, 'ProductArgsFromCategory']
    SaleItem: Union[bool, 'FindManySaleItemArgsFromCategory']
    BranchOrderItem: Union[bool, 'FindManyBranchOrderItemArgsFromCategory']


class StockArgsFromCategory(TypedDict, total=False):
    """Arguments for Category"""
    include: 'StockIncludeFromStock'


class FindManyStockArgsFromCategory(TypedDict, total=False):
    """Arguments for Category"""
    take: int
    skip: int
    order_by: Union['StockOrderByInput', List['StockOrderByInput']]
    where: 'StockWhereInput'
    cursor: 'StockWhereUniqueInput'
    distinct: List['StockScalarFieldKeys']
    include: 'StockIncludeFromStock'


class CustomerIncludeFromCategory(TypedDict, total=False):
    """Relational arguments for Category"""
    Sale: Union[bool, 'FindManySaleArgsFromCategory']


class CustomerArgsFromCategory(TypedDict, total=False):
    """Arguments for Category"""
    include: 'CustomerIncludeFromCustomer'


class FindManyCustomerArgsFromCategory(TypedDict, total=False):
    """Arguments for Category"""
    take: int
    skip: int
    order_by: Union['CustomerOrderByInput', List['CustomerOrderByInput']]
    where: 'CustomerWhereInput'
    cursor: 'CustomerWhereUniqueInput'
    distinct: List['CustomerScalarFieldKeys']
    include: 'CustomerIncludeFromCustomer'


class SaleIncludeFromCategory(TypedDict, total=False):
    """Relational arguments for Category"""
    branch: Union[bool, 'BranchArgsFromCategory']
    customer: Union[bool, 'CustomerArgsFromCategory']
    user: Union[bool, 'UserArgsFromCategory']
    items: Union[bool, 'FindManySaleItemArgsFromCategory']
    payments: Union[bool, 'FindManyPaymentArgsFromCategory']
    returns: Union[bool, 'FindManyReturnSaleArgsFromCategory']
    deletedBy: Union[bool, 'UserArgsFromCategory']


class SaleArgsFromCategory(TypedDict, total=False):
    """Arguments for Category"""
    include: 'SaleIncludeFromSale'


class FindManySaleArgsFromCategory(TypedDict, total=False):
    """Arguments for Category"""
    take: int
    skip: int
    order_by: Union['SaleOrderByInput', List['SaleOrderByInput']]
    where: 'SaleWhereInput'
    cursor: 'SaleWhereUniqueInput'
    distinct: List['SaleScalarFieldKeys']
    include: 'SaleIncludeFromSale'


class SaleItemIncludeFromCategory(TypedDict, total=False):
    """Relational arguments for Category"""
    sale: Union[bool, 'SaleArgsFromCategory']
    stock: Union[bool, 'StockArgsFromCategory']
    ReturnItem: Union[bool, 'FindManyReturnItemArgsFromCategory']


class SaleItemArgsFromCategory(TypedDict, total=False):
    """Arguments for Category"""
    include: 'SaleItemIncludeFromSaleItem'


class FindManySaleItemArgsFromCategory(TypedDict, total=False):
    """Arguments for Category"""
    take: int
    skip: int
    order_by: Union['SaleItemOrderByInput', List['SaleItemOrderByInput']]
    where: 'SaleItemWhereInput'
    cursor: 'SaleItemWhereUniqueInput'
    distinct: List['SaleItemScalarFieldKeys']
    include: 'SaleItemIncludeFromSaleItem'


class ReturnSaleIncludeFromCategory(TypedDict, total=False):
    """Relational arguments for Category"""
    original: Union[bool, 'SaleArgsFromCategory']
    items: Union[bool, 'FindManyReturnItemArgsFromCategory']
    refund: Union[bool, 'FindManyPaymentArgsFromCategory']


class ReturnSaleArgsFromCategory(TypedDict, total=False):
    """Arguments for Category"""
    include: 'ReturnSaleIncludeFromReturnSale'


class FindManyReturnSaleArgsFromCategory(TypedDict, total=False):
    """Arguments for Category"""
    take: int
    skip: int
    order_by: Union['ReturnSaleOrderByInput', List['ReturnSaleOrderByInput']]
    where: 'ReturnSaleWhereInput'
    cursor: 'ReturnSaleWhereUniqueInput'
    distinct: List['ReturnSaleScalarFieldKeys']
    include: 'ReturnSaleIncludeFromReturnSale'


class ReturnItemIncludeFromCategory(TypedDict, total=False):
    """Relational arguments for Category"""
    returnSale: Union[bool, 'ReturnSaleArgsFromCategory']
    saleItem: Union[bool, 'SaleItemArgsFromCategory']


class ReturnItemArgsFromCategory(TypedDict, total=False):
    """Arguments for Category"""
    include: 'ReturnItemIncludeFromReturnItem'


class FindManyReturnItemArgsFromCategory(TypedDict, total=False):
    """Arguments for Category"""
    take: int
    skip: int
    order_by: Union['ReturnItemOrderByInput', List['ReturnItemOrderByInput']]
    where: 'ReturnItemWhereInput'
    cursor: 'ReturnItemWhereUniqueInput'
    distinct: List['ReturnItemScalarFieldKeys']
    include: 'ReturnItemIncludeFromReturnItem'


class PaymentIncludeFromCategory(TypedDict, total=False):
    """Relational arguments for Category"""
    sale: Union[bool, 'SaleArgsFromCategory']
    account: Union[bool, 'AccountArgsFromCategory']
    returnSale: Union[bool, 'ReturnSaleArgsFromCategory']
    user: Union[bool, 'UserArgsFromCategory']


class PaymentArgsFromCategory(TypedDict, total=False):
    """Arguments for Category"""
    include: 'PaymentIncludeFromPayment'


class FindManyPaymentArgsFromCategory(TypedDict, total=False):
    """Arguments for Category"""
    take: int
    skip: int
    order_by: Union['PaymentOrderByInput', List['PaymentOrderByInput']]
    where: 'PaymentWhereInput'
    cursor: 'PaymentWhereUniqueInput'
    distinct: List['PaymentScalarFieldKeys']
    include: 'PaymentIncludeFromPayment'


class JournalEntryIncludeFromCategory(TypedDict, total=False):
    """Relational arguments for Category"""
    lines: Union[bool, 'FindManyJournalEntryLineArgsFromCategory']


class JournalEntryArgsFromCategory(TypedDict, total=False):
    """Arguments for Category"""
    include: 'JournalEntryIncludeFromJournalEntry'


class FindManyJournalEntryArgsFromCategory(TypedDict, total=False):
    """Arguments for Category"""
    take: int
    skip: int
    order_by: Union['JournalEntryOrderByInput', List['JournalEntryOrderByInput']]
    where: 'JournalEntryWhereInput'
    cursor: 'JournalEntryWhereUniqueInput'
    distinct: List['JournalEntryScalarFieldKeys']
    include: 'JournalEntryIncludeFromJournalEntry'


class JournalEntryLineIncludeFromCategory(TypedDict, total=False):
    """Relational arguments for Category"""
    entry: Union[bool, 'JournalEntryArgsFromCategory']
    account: Union[bool, 'AccountArgsFromCategory']


class JournalEntryLineArgsFromCategory(TypedDict, total=False):
    """Arguments for Category"""
    include: 'JournalEntryLineIncludeFromJournalEntryLine'


class FindManyJournalEntryLineArgsFromCategory(TypedDict, total=False):
    """Arguments for Category"""
    take: int
    skip: int
    order_by: Union['JournalEntryLineOrderByInput', List['JournalEntryLineOrderByInput']]
    where: 'JournalEntryLineWhereInput'
    cursor: 'JournalEntryLineWhereUniqueInput'
    distinct: List['JournalEntryLineScalarFieldKeys']
    include: 'JournalEntryLineIncludeFromJournalEntryLine'


class AccountIncludeFromCategory(TypedDict, total=False):
    """Relational arguments for Category"""
    branch: Union[bool, 'BranchArgsFromCategory']
    entries: Union[bool, 'FindManyJournalEntryLineArgsFromCategory']
    payments: Union[bool, 'FindManyPaymentArgsFromCategory']
    outgoingTransfers: Union[bool, 'FindManyAccountTransferArgsFromCategory']
    incomingTransfers: Union[bool, 'FindManyAccountTransferArgsFromCategory']


class AccountArgsFromCategory(TypedDict, total=False):
    """Arguments for Category"""
    include: 'AccountIncludeFromAccount'


class FindManyAccountArgsFromCategory(TypedDict, total=False):
    """Arguments for Category"""
    take: int
    skip: int
    order_by: Union['AccountOrderByInput', List['AccountOrderByInput']]
    where: 'AccountWhereInput'
    cursor: 'AccountWhereUniqueInput'
    distinct: List['AccountScalarFieldKeys']
    include: 'AccountIncludeFromAccount'


class AccountTransferIncludeFromCategory(TypedDict, total=False):
    """Relational arguments for Category"""
    fromAccount: Union[bool, 'AccountArgsFromCategory']
    toAccount: Union[bool, 'AccountArgsFromCategory']


class AccountTransferArgsFromCategory(TypedDict, total=False):
    """Arguments for Category"""
    include: 'AccountTransferIncludeFromAccountTransfer'


class FindManyAccountTransferArgsFromCategory(TypedDict, total=False):
    """Arguments for Category"""
    take: int
    skip: int
    order_by: Union['AccountTransferOrderByInput', List['AccountTransferOrderByInput']]
    where: 'AccountTransferWhereInput'
    cursor: 'AccountTransferWhereUniqueInput'
    distinct: List['AccountTransferScalarFieldKeys']
    include: 'AccountTransferIncludeFromAccountTransfer'


class BranchOrderIncludeFromCategory(TypedDict, total=False):
    """Relational arguments for Category"""
    branch: Union[bool, 'BranchArgsFromCategory']
    requestedBy: Union[bool, 'UserArgsFromCategory']
    approvedBy: Union[bool, 'UserArgsFromCategory']
    sentBy: Union[bool, 'UserArgsFromCategory']
    receivedBy: Union[bool, 'UserArgsFromCategory']
    items: Union[bool, 'FindManyBranchOrderItemArgsFromCategory']


class BranchOrderArgsFromCategory(TypedDict, total=False):
    """Arguments for Category"""
    include: 'BranchOrderIncludeFromBranchOrder'


class FindManyBranchOrderArgsFromCategory(TypedDict, total=False):
    """Arguments for Category"""
    take: int
    skip: int
    order_by: Union['BranchOrderOrderByInput', List['BranchOrderOrderByInput']]
    where: 'BranchOrderWhereInput'
    cursor: 'BranchOrderWhereUniqueInput'
    distinct: List['BranchOrderScalarFieldKeys']
    include: 'BranchOrderIncludeFromBranchOrder'


class BranchOrderItemIncludeFromCategory(TypedDict, total=False):
    """Relational arguments for Category"""
    branchOrder: Union[bool, 'BranchOrderArgsFromCategory']
    stock: Union[bool, 'StockArgsFromCategory']


class BranchOrderItemArgsFromCategory(TypedDict, total=False):
    """Arguments for Category"""
    include: 'BranchOrderItemIncludeFromBranchOrderItem'


class FindManyBranchOrderItemArgsFromCategory(TypedDict, total=False):
    """Arguments for Category"""
    take: int
    skip: int
    order_by: Union['BranchOrderItemOrderByInput', List['BranchOrderItemOrderByInput']]
    where: 'BranchOrderItemWhereInput'
    cursor: 'BranchOrderItemWhereUniqueInput'
    distinct: List['BranchOrderItemScalarFieldKeys']
    include: 'BranchOrderItemIncludeFromBranchOrderItem'


class AuditLogIncludeFromCategory(TypedDict, total=False):
    """Relational arguments for Category"""
    user: Union[bool, 'UserArgsFromCategory']


class AuditLogArgsFromCategory(TypedDict, total=False):
    """Arguments for Category"""
    include: 'AuditLogIncludeFromAuditLog'


class FindManyAuditLogArgsFromCategory(TypedDict, total=False):
    """Arguments for Category"""
    take: int
    skip: int
    order_by: Union['AuditLogOrderByInput', List['AuditLogOrderByInput']]
    where: 'AuditLogWhereInput'
    cursor: 'AuditLogWhereUniqueInput'
    distinct: List['AuditLogScalarFieldKeys']
    include: 'AuditLogIncludeFromAuditLog'


class SystemInfoIncludeFromCategory(TypedDict, total=False):
    """Relational arguments for Category"""


class SystemInfoArgsFromCategory(TypedDict, total=False):
    """Arguments for Category"""
    include: 'SystemInfoIncludeFromSystemInfo'


class FindManySystemInfoArgsFromCategory(TypedDict, total=False):
    """Arguments for Category"""
    take: int
    skip: int
    order_by: Union['SystemInfoOrderByInput', List['SystemInfoOrderByInput']]
    where: 'SystemInfoWhereInput'
    cursor: 'SystemInfoWhereUniqueInput'
    distinct: List['SystemInfoScalarFieldKeys']
    include: 'SystemInfoIncludeFromSystemInfo'


class BackupIncludeFromCategory(TypedDict, total=False):
    """Relational arguments for Category"""
    createdBy: Union[bool, 'UserArgsFromCategory']


class BackupArgsFromCategory(TypedDict, total=False):
    """Arguments for Category"""
    include: 'BackupIncludeFromBackup'


class FindManyBackupArgsFromCategory(TypedDict, total=False):
    """Arguments for Category"""
    take: int
    skip: int
    order_by: Union['BackupOrderByInput', List['BackupOrderByInput']]
    where: 'BackupWhereInput'
    cursor: 'BackupWhereUniqueInput'
    distinct: List['BackupScalarFieldKeys']
    include: 'BackupIncludeFromBackup'


class RevokedTokenIncludeFromCategory(TypedDict, total=False):
    """Relational arguments for Category"""
    user: Union[bool, 'UserArgsFromCategory']


class RevokedTokenArgsFromCategory(TypedDict, total=False):
    """Arguments for Category"""
    include: 'RevokedTokenIncludeFromRevokedToken'


class FindManyRevokedTokenArgsFromCategory(TypedDict, total=False):
    """Arguments for Category"""
    take: int
    skip: int
    order_by: Union['RevokedTokenOrderByInput', List['RevokedTokenOrderByInput']]
    where: 'RevokedTokenWhereInput'
    cursor: 'RevokedTokenWhereUniqueInput'
    distinct: List['RevokedTokenScalarFieldKeys']
    include: 'RevokedTokenIncludeFromRevokedToken'


class SystemSettingIncludeFromCategory(TypedDict, total=False):
    """Relational arguments for Category"""


class SystemSettingArgsFromCategory(TypedDict, total=False):
    """Arguments for Category"""
    include: 'SystemSettingIncludeFromSystemSetting'


class FindManySystemSettingArgsFromCategory(TypedDict, total=False):
    """Arguments for Category"""
    take: int
    skip: int
    order_by: Union['SystemSettingOrderByInput', List['SystemSettingOrderByInput']]
    where: 'SystemSettingWhereInput'
    cursor: 'SystemSettingWhereUniqueInput'
    distinct: List['SystemSettingScalarFieldKeys']
    include: 'SystemSettingIncludeFromSystemSetting'


class NotificationIncludeFromCategory(TypedDict, total=False):
    """Relational arguments for Category"""
    user: Union[bool, 'UserArgsFromCategory']


class NotificationArgsFromCategory(TypedDict, total=False):
    """Arguments for Category"""
    include: 'NotificationIncludeFromNotification'


class FindManyNotificationArgsFromCategory(TypedDict, total=False):
    """Arguments for Category"""
    take: int
    skip: int
    order_by: Union['NotificationOrderByInput', List['NotificationOrderByInput']]
    where: 'NotificationWhereInput'
    cursor: 'NotificationWhereUniqueInput'
    distinct: List['NotificationScalarFieldKeys']
    include: 'NotificationIncludeFromNotification'


class StockAdjustmentIncludeFromCategory(TypedDict, total=False):
    """Relational arguments for Category"""
    product: Union[bool, 'ProductArgsFromCategory']
    createdBy: Union[bool, 'UserArgsFromCategory']


class StockAdjustmentArgsFromCategory(TypedDict, total=False):
    """Arguments for Category"""
    include: 'StockAdjustmentIncludeFromStockAdjustment'


class FindManyStockAdjustmentArgsFromCategory(TypedDict, total=False):
    """Arguments for Category"""
    take: int
    skip: int
    order_by: Union['StockAdjustmentOrderByInput', List['StockAdjustmentOrderByInput']]
    where: 'StockAdjustmentWhereInput'
    cursor: 'StockAdjustmentWhereUniqueInput'
    distinct: List['StockAdjustmentScalarFieldKeys']
    include: 'StockAdjustmentIncludeFromStockAdjustment'




FindManyCategoryArgs = FindManyCategoryArgsFromCategory
FindFirstCategoryArgs = FindManyCategoryArgsFromCategory


class CategoryWhereInput(TypedDict, total=False):
    """Category arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    name: Union[_str, 'types.StringFilter']
    description: Union[None, _str, 'types.StringFilter']
    status: 'enums.CategoryStatus'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    products: 'ProductListRelationFilter'

    # should be noted that AND and NOT should be Union['CategoryWhereInput', List['CategoryWhereInput']]
    # but this causes mypy to hang :/
    AND: List['CategoryWhereInput']
    OR: List['CategoryWhereInput']
    NOT: List['CategoryWhereInput']



# aggregate Category types


class CategoryScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Category arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']
    status: 'enums.CategoryStatus'
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['CategoryScalarWhereWithAggregatesInput']
    OR: List['CategoryScalarWhereWithAggregatesInput']
    NOT: List['CategoryScalarWhereWithAggregatesInput']



class CategoryGroupByOutput(TypedDict, total=False):
    id: _int
    name: _str
    description: _str
    status: 'enums.CategoryStatus'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'CategorySumAggregateOutput'
    _avg: 'CategoryAvgAggregateOutput'
    _min: 'CategoryMinAggregateOutput'
    _max: 'CategoryMaxAggregateOutput'
    _count: 'CategoryCountAggregateOutput'


class CategoryAvgAggregateOutput(TypedDict, total=False):
    """Category output for aggregating averages"""
    id: float


class CategorySumAggregateOutput(TypedDict, total=False):
    """Category output for aggregating sums"""
    id: _int


class CategoryScalarAggregateOutput(TypedDict, total=False):
    """Category output including scalar fields"""
    id: _int
    name: _str
    description: _str
    status: 'enums.CategoryStatus'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


CategoryMinAggregateOutput = CategoryScalarAggregateOutput
CategoryMaxAggregateOutput = CategoryScalarAggregateOutput


class CategoryMaxAggregateInput(TypedDict, total=False):
    """Category input for aggregating by max"""
    id: bool
    name: bool
    description: bool
    status: bool
    createdAt: bool
    updatedAt: bool


class CategoryMinAggregateInput(TypedDict, total=False):
    """Category input for aggregating by min"""
    id: bool
    name: bool
    description: bool
    status: bool
    createdAt: bool
    updatedAt: bool


class CategoryNumberAggregateInput(TypedDict, total=False):
    """Category input for aggregating numbers"""
    id: bool


CategoryAvgAggregateInput = CategoryNumberAggregateInput
CategorySumAggregateInput = CategoryNumberAggregateInput


CategoryCountAggregateInput = TypedDict(
    'CategoryCountAggregateInput',
    {
        'id': bool,
        'name': bool,
        'description': bool,
        'status': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

CategoryCountAggregateOutput = TypedDict(
    'CategoryCountAggregateOutput',
    {
        'id': int,
        'name': int,
        'description': int,
        'status': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


CategoryKeys = Literal[
    'id',
    'name',
    'description',
    'status',
    'createdAt',
    'updatedAt',
    'products',
]
CategoryScalarFieldKeys = Literal[
    'id',
    'name',
    'description',
    'status',
    'createdAt',
    'updatedAt',
]
CategoryScalarFieldKeysT = TypeVar('CategoryScalarFieldKeysT', bound=CategoryScalarFieldKeys)

CategoryRelationalFieldKeys = Literal[
        'products',
    ]

# Stock types

class StockOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Stock create method"""
    id: _int
    productId: _int
    product: 'ProductCreateNestedWithoutRelationsInput'
    quantity: _int
    lastRestocked: Optional[datetime.datetime]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    SaleItem: 'SaleItemCreateManyNestedWithoutRelationsInput'
    BranchOrderItem: 'BranchOrderItemCreateManyNestedWithoutRelationsInput'


class StockCreateInput(StockOptionalCreateInput):
    """Required arguments to the Stock create method"""


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class StockOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Stock create method, without relations"""
    id: _int
    productId: _int
    quantity: _int
    lastRestocked: Optional[datetime.datetime]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class StockCreateWithoutRelationsInput(StockOptionalCreateWithoutRelationsInput):
    """Required arguments to the Stock create method, without relations"""


class StockCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'StockCreateWithoutRelationsInput'
    connect: 'StockWhereUniqueInput'


class StockCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['StockCreateWithoutRelationsInput', List['StockCreateWithoutRelationsInput']]
    connect: Union['StockWhereUniqueInput', List['StockWhereUniqueInput']]


_StockWhereUnique_id_Input = TypedDict(
    '_StockWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

StockWhereUniqueInput = _StockWhereUnique_id_Input


class StockUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    product: 'ProductUpdateOneWithoutRelationsInput'
    quantity: Union[AtomicIntInput, _int]
    lastRestocked: Optional[datetime.datetime]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    SaleItem: 'SaleItemUpdateManyWithoutRelationsInput'
    BranchOrderItem: 'BranchOrderItemUpdateManyWithoutRelationsInput'


class StockUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    quantity: Union[AtomicIntInput, _int]
    lastRestocked: Optional[datetime.datetime]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class StockUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['StockCreateWithoutRelationsInput']
    connect: List['StockWhereUniqueInput']
    set: List['StockWhereUniqueInput']
    disconnect: List['StockWhereUniqueInput']
    delete: List['StockWhereUniqueInput']

    # TODO
    # update: List['StockUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['StockUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['StockScalarWhereInput']
    # upsert: List['StockUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['StockCreateOrConnectWithoutRelationsInput']


class StockUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'StockCreateWithoutRelationsInput'
    connect: 'StockWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'StockUpdateInput'
    # upsert: 'StockUpsertWithoutRelationsInput'
    # connectOrCreate: 'StockCreateOrConnectWithoutRelationsInput'


class StockUpsertInput(TypedDict):
    create: 'StockCreateInput'
    update: 'StockUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Stock_id_OrderByInput = TypedDict(
    '_Stock_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Stock_productId_OrderByInput = TypedDict(
    '_Stock_productId_OrderByInput',
    {
        'productId': 'SortOrder',
    },
    total=True
)

_Stock_quantity_OrderByInput = TypedDict(
    '_Stock_quantity_OrderByInput',
    {
        'quantity': 'SortOrder',
    },
    total=True
)

_Stock_lastRestocked_OrderByInput = TypedDict(
    '_Stock_lastRestocked_OrderByInput',
    {
        'lastRestocked': 'SortOrder',
    },
    total=True
)

_Stock_createdAt_OrderByInput = TypedDict(
    '_Stock_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Stock_updatedAt_OrderByInput = TypedDict(
    '_Stock_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

StockOrderByInput = Union[
    '_Stock_id_OrderByInput',
    '_Stock_productId_OrderByInput',
    '_Stock_quantity_OrderByInput',
    '_Stock_lastRestocked_OrderByInput',
    '_Stock_createdAt_OrderByInput',
    '_Stock_updatedAt_OrderByInput',
]



# recursive Stock types
# TODO: cleanup these types



StockRelationFilter = TypedDict(
    'StockRelationFilter',
    {
        'is': 'StockWhereInput',
        'is_not': 'StockWhereInput',
    },
    total=False,
)


class StockListRelationFilter(TypedDict, total=False):
    some: 'StockWhereInput'
    none: 'StockWhereInput'
    every: 'StockWhereInput'


class StockInclude(TypedDict, total=False):
    """Stock relational arguments"""
    product: Union[bool, 'ProductArgsFromStock']
    SaleItem: Union[bool, 'FindManySaleItemArgsFromStock']
    BranchOrderItem: Union[bool, 'FindManyBranchOrderItemArgsFromStock']


class UserIncludeFromStock(TypedDict, total=False):
    """Relational arguments for Stock"""
    branch: Union[bool, 'BranchArgsFromStock']
    auditLogs: Union[bool, 'FindManyAuditLogArgsFromStock']
    permissions: Union[bool, 'FindManyUserPermissionArgsFromStock']
    notifications: Union[bool, 'FindManyNotificationArgsFromStock']
    revokedTokens: Union[bool, 'FindManyRevokedTokenArgsFromStock']
    stockAdjustments: Union[bool, 'FindManyStockAdjustmentArgsFromStock']
    Sale: Union[bool, 'FindManySaleArgsFromStock']
    deletedSales: Union[bool, 'FindManySaleArgsFromStock']
    Payment: Union[bool, 'FindManyPaymentArgsFromStock']
    Backup: Union[bool, 'FindManyBackupArgsFromStock']
    requestedOrders: Union[bool, 'FindManyBranchOrderArgsFromStock']
    approvedOrders: Union[bool, 'FindManyBranchOrderArgsFromStock']
    sentOrders: Union[bool, 'FindManyBranchOrderArgsFromStock']
    receivedOrders: Union[bool, 'FindManyBranchOrderArgsFromStock']


class UserArgsFromStock(TypedDict, total=False):
    """Arguments for Stock"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromStock(TypedDict, total=False):
    """Arguments for Stock"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class UserPermissionIncludeFromStock(TypedDict, total=False):
    """Relational arguments for Stock"""
    user: Union[bool, 'UserArgsFromStock']


class UserPermissionArgsFromStock(TypedDict, total=False):
    """Arguments for Stock"""
    include: 'UserPermissionIncludeFromUserPermission'


class FindManyUserPermissionArgsFromStock(TypedDict, total=False):
    """Arguments for Stock"""
    take: int
    skip: int
    order_by: Union['UserPermissionOrderByInput', List['UserPermissionOrderByInput']]
    where: 'UserPermissionWhereInput'
    cursor: 'UserPermissionWhereUniqueInput'
    distinct: List['UserPermissionScalarFieldKeys']
    include: 'UserPermissionIncludeFromUserPermission'


class BranchIncludeFromStock(TypedDict, total=False):
    """Relational arguments for Stock"""
    users: Union[bool, 'FindManyUserArgsFromStock']
    Sale: Union[bool, 'FindManySaleArgsFromStock']
    Account: Union[bool, 'FindManyAccountArgsFromStock']
    BranchOrder: Union[bool, 'FindManyBranchOrderArgsFromStock']


class BranchArgsFromStock(TypedDict, total=False):
    """Arguments for Stock"""
    include: 'BranchIncludeFromBranch'


class FindManyBranchArgsFromStock(TypedDict, total=False):
    """Arguments for Stock"""
    take: int
    skip: int
    order_by: Union['BranchOrderByInput', List['BranchOrderByInput']]
    where: 'BranchWhereInput'
    cursor: 'BranchWhereUniqueInput'
    distinct: List['BranchScalarFieldKeys']
    include: 'BranchIncludeFromBranch'


class ProductIncludeFromStock(TypedDict, total=False):
    """Relational arguments for Stock"""
    category: Union[bool, 'CategoryArgsFromStock']
    stocks: Union[bool, 'FindManyStockArgsFromStock']
    stockAdjustments: Union[bool, 'FindManyStockAdjustmentArgsFromStock']


class ProductArgsFromStock(TypedDict, total=False):
    """Arguments for Stock"""
    include: 'ProductIncludeFromProduct'


class FindManyProductArgsFromStock(TypedDict, total=False):
    """Arguments for Stock"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProduct'


class CategoryIncludeFromStock(TypedDict, total=False):
    """Relational arguments for Stock"""
    products: Union[bool, 'FindManyProductArgsFromStock']


class CategoryArgsFromStock(TypedDict, total=False):
    """Arguments for Stock"""
    include: 'CategoryIncludeFromCategory'


class FindManyCategoryArgsFromStock(TypedDict, total=False):
    """Arguments for Stock"""
    take: int
    skip: int
    order_by: Union['CategoryOrderByInput', List['CategoryOrderByInput']]
    where: 'CategoryWhereInput'
    cursor: 'CategoryWhereUniqueInput'
    distinct: List['CategoryScalarFieldKeys']
    include: 'CategoryIncludeFromCategory'


class StockIncludeFromStock(TypedDict, total=False):
    """Relational arguments for Stock"""
    product: Union[bool, 'ProductArgsFromStock']
    SaleItem: Union[bool, 'FindManySaleItemArgsFromStock']
    BranchOrderItem: Union[bool, 'FindManyBranchOrderItemArgsFromStock']


class StockArgsFromStock(TypedDict, total=False):
    """Arguments for Stock"""
    include: 'StockIncludeFromStock'


class FindManyStockArgsFromStock(TypedDict, total=False):
    """Arguments for Stock"""
    take: int
    skip: int
    order_by: Union['StockOrderByInput', List['StockOrderByInput']]
    where: 'StockWhereInput'
    cursor: 'StockWhereUniqueInput'
    distinct: List['StockScalarFieldKeys']
    include: 'StockIncludeFromStock'


class CustomerIncludeFromStock(TypedDict, total=False):
    """Relational arguments for Stock"""
    Sale: Union[bool, 'FindManySaleArgsFromStock']


class CustomerArgsFromStock(TypedDict, total=False):
    """Arguments for Stock"""
    include: 'CustomerIncludeFromCustomer'


class FindManyCustomerArgsFromStock(TypedDict, total=False):
    """Arguments for Stock"""
    take: int
    skip: int
    order_by: Union['CustomerOrderByInput', List['CustomerOrderByInput']]
    where: 'CustomerWhereInput'
    cursor: 'CustomerWhereUniqueInput'
    distinct: List['CustomerScalarFieldKeys']
    include: 'CustomerIncludeFromCustomer'


class SaleIncludeFromStock(TypedDict, total=False):
    """Relational arguments for Stock"""
    branch: Union[bool, 'BranchArgsFromStock']
    customer: Union[bool, 'CustomerArgsFromStock']
    user: Union[bool, 'UserArgsFromStock']
    items: Union[bool, 'FindManySaleItemArgsFromStock']
    payments: Union[bool, 'FindManyPaymentArgsFromStock']
    returns: Union[bool, 'FindManyReturnSaleArgsFromStock']
    deletedBy: Union[bool, 'UserArgsFromStock']


class SaleArgsFromStock(TypedDict, total=False):
    """Arguments for Stock"""
    include: 'SaleIncludeFromSale'


class FindManySaleArgsFromStock(TypedDict, total=False):
    """Arguments for Stock"""
    take: int
    skip: int
    order_by: Union['SaleOrderByInput', List['SaleOrderByInput']]
    where: 'SaleWhereInput'
    cursor: 'SaleWhereUniqueInput'
    distinct: List['SaleScalarFieldKeys']
    include: 'SaleIncludeFromSale'


class SaleItemIncludeFromStock(TypedDict, total=False):
    """Relational arguments for Stock"""
    sale: Union[bool, 'SaleArgsFromStock']
    stock: Union[bool, 'StockArgsFromStock']
    ReturnItem: Union[bool, 'FindManyReturnItemArgsFromStock']


class SaleItemArgsFromStock(TypedDict, total=False):
    """Arguments for Stock"""
    include: 'SaleItemIncludeFromSaleItem'


class FindManySaleItemArgsFromStock(TypedDict, total=False):
    """Arguments for Stock"""
    take: int
    skip: int
    order_by: Union['SaleItemOrderByInput', List['SaleItemOrderByInput']]
    where: 'SaleItemWhereInput'
    cursor: 'SaleItemWhereUniqueInput'
    distinct: List['SaleItemScalarFieldKeys']
    include: 'SaleItemIncludeFromSaleItem'


class ReturnSaleIncludeFromStock(TypedDict, total=False):
    """Relational arguments for Stock"""
    original: Union[bool, 'SaleArgsFromStock']
    items: Union[bool, 'FindManyReturnItemArgsFromStock']
    refund: Union[bool, 'FindManyPaymentArgsFromStock']


class ReturnSaleArgsFromStock(TypedDict, total=False):
    """Arguments for Stock"""
    include: 'ReturnSaleIncludeFromReturnSale'


class FindManyReturnSaleArgsFromStock(TypedDict, total=False):
    """Arguments for Stock"""
    take: int
    skip: int
    order_by: Union['ReturnSaleOrderByInput', List['ReturnSaleOrderByInput']]
    where: 'ReturnSaleWhereInput'
    cursor: 'ReturnSaleWhereUniqueInput'
    distinct: List['ReturnSaleScalarFieldKeys']
    include: 'ReturnSaleIncludeFromReturnSale'


class ReturnItemIncludeFromStock(TypedDict, total=False):
    """Relational arguments for Stock"""
    returnSale: Union[bool, 'ReturnSaleArgsFromStock']
    saleItem: Union[bool, 'SaleItemArgsFromStock']


class ReturnItemArgsFromStock(TypedDict, total=False):
    """Arguments for Stock"""
    include: 'ReturnItemIncludeFromReturnItem'


class FindManyReturnItemArgsFromStock(TypedDict, total=False):
    """Arguments for Stock"""
    take: int
    skip: int
    order_by: Union['ReturnItemOrderByInput', List['ReturnItemOrderByInput']]
    where: 'ReturnItemWhereInput'
    cursor: 'ReturnItemWhereUniqueInput'
    distinct: List['ReturnItemScalarFieldKeys']
    include: 'ReturnItemIncludeFromReturnItem'


class PaymentIncludeFromStock(TypedDict, total=False):
    """Relational arguments for Stock"""
    sale: Union[bool, 'SaleArgsFromStock']
    account: Union[bool, 'AccountArgsFromStock']
    returnSale: Union[bool, 'ReturnSaleArgsFromStock']
    user: Union[bool, 'UserArgsFromStock']


class PaymentArgsFromStock(TypedDict, total=False):
    """Arguments for Stock"""
    include: 'PaymentIncludeFromPayment'


class FindManyPaymentArgsFromStock(TypedDict, total=False):
    """Arguments for Stock"""
    take: int
    skip: int
    order_by: Union['PaymentOrderByInput', List['PaymentOrderByInput']]
    where: 'PaymentWhereInput'
    cursor: 'PaymentWhereUniqueInput'
    distinct: List['PaymentScalarFieldKeys']
    include: 'PaymentIncludeFromPayment'


class JournalEntryIncludeFromStock(TypedDict, total=False):
    """Relational arguments for Stock"""
    lines: Union[bool, 'FindManyJournalEntryLineArgsFromStock']


class JournalEntryArgsFromStock(TypedDict, total=False):
    """Arguments for Stock"""
    include: 'JournalEntryIncludeFromJournalEntry'


class FindManyJournalEntryArgsFromStock(TypedDict, total=False):
    """Arguments for Stock"""
    take: int
    skip: int
    order_by: Union['JournalEntryOrderByInput', List['JournalEntryOrderByInput']]
    where: 'JournalEntryWhereInput'
    cursor: 'JournalEntryWhereUniqueInput'
    distinct: List['JournalEntryScalarFieldKeys']
    include: 'JournalEntryIncludeFromJournalEntry'


class JournalEntryLineIncludeFromStock(TypedDict, total=False):
    """Relational arguments for Stock"""
    entry: Union[bool, 'JournalEntryArgsFromStock']
    account: Union[bool, 'AccountArgsFromStock']


class JournalEntryLineArgsFromStock(TypedDict, total=False):
    """Arguments for Stock"""
    include: 'JournalEntryLineIncludeFromJournalEntryLine'


class FindManyJournalEntryLineArgsFromStock(TypedDict, total=False):
    """Arguments for Stock"""
    take: int
    skip: int
    order_by: Union['JournalEntryLineOrderByInput', List['JournalEntryLineOrderByInput']]
    where: 'JournalEntryLineWhereInput'
    cursor: 'JournalEntryLineWhereUniqueInput'
    distinct: List['JournalEntryLineScalarFieldKeys']
    include: 'JournalEntryLineIncludeFromJournalEntryLine'


class AccountIncludeFromStock(TypedDict, total=False):
    """Relational arguments for Stock"""
    branch: Union[bool, 'BranchArgsFromStock']
    entries: Union[bool, 'FindManyJournalEntryLineArgsFromStock']
    payments: Union[bool, 'FindManyPaymentArgsFromStock']
    outgoingTransfers: Union[bool, 'FindManyAccountTransferArgsFromStock']
    incomingTransfers: Union[bool, 'FindManyAccountTransferArgsFromStock']


class AccountArgsFromStock(TypedDict, total=False):
    """Arguments for Stock"""
    include: 'AccountIncludeFromAccount'


class FindManyAccountArgsFromStock(TypedDict, total=False):
    """Arguments for Stock"""
    take: int
    skip: int
    order_by: Union['AccountOrderByInput', List['AccountOrderByInput']]
    where: 'AccountWhereInput'
    cursor: 'AccountWhereUniqueInput'
    distinct: List['AccountScalarFieldKeys']
    include: 'AccountIncludeFromAccount'


class AccountTransferIncludeFromStock(TypedDict, total=False):
    """Relational arguments for Stock"""
    fromAccount: Union[bool, 'AccountArgsFromStock']
    toAccount: Union[bool, 'AccountArgsFromStock']


class AccountTransferArgsFromStock(TypedDict, total=False):
    """Arguments for Stock"""
    include: 'AccountTransferIncludeFromAccountTransfer'


class FindManyAccountTransferArgsFromStock(TypedDict, total=False):
    """Arguments for Stock"""
    take: int
    skip: int
    order_by: Union['AccountTransferOrderByInput', List['AccountTransferOrderByInput']]
    where: 'AccountTransferWhereInput'
    cursor: 'AccountTransferWhereUniqueInput'
    distinct: List['AccountTransferScalarFieldKeys']
    include: 'AccountTransferIncludeFromAccountTransfer'


class BranchOrderIncludeFromStock(TypedDict, total=False):
    """Relational arguments for Stock"""
    branch: Union[bool, 'BranchArgsFromStock']
    requestedBy: Union[bool, 'UserArgsFromStock']
    approvedBy: Union[bool, 'UserArgsFromStock']
    sentBy: Union[bool, 'UserArgsFromStock']
    receivedBy: Union[bool, 'UserArgsFromStock']
    items: Union[bool, 'FindManyBranchOrderItemArgsFromStock']


class BranchOrderArgsFromStock(TypedDict, total=False):
    """Arguments for Stock"""
    include: 'BranchOrderIncludeFromBranchOrder'


class FindManyBranchOrderArgsFromStock(TypedDict, total=False):
    """Arguments for Stock"""
    take: int
    skip: int
    order_by: Union['BranchOrderOrderByInput', List['BranchOrderOrderByInput']]
    where: 'BranchOrderWhereInput'
    cursor: 'BranchOrderWhereUniqueInput'
    distinct: List['BranchOrderScalarFieldKeys']
    include: 'BranchOrderIncludeFromBranchOrder'


class BranchOrderItemIncludeFromStock(TypedDict, total=False):
    """Relational arguments for Stock"""
    branchOrder: Union[bool, 'BranchOrderArgsFromStock']
    stock: Union[bool, 'StockArgsFromStock']


class BranchOrderItemArgsFromStock(TypedDict, total=False):
    """Arguments for Stock"""
    include: 'BranchOrderItemIncludeFromBranchOrderItem'


class FindManyBranchOrderItemArgsFromStock(TypedDict, total=False):
    """Arguments for Stock"""
    take: int
    skip: int
    order_by: Union['BranchOrderItemOrderByInput', List['BranchOrderItemOrderByInput']]
    where: 'BranchOrderItemWhereInput'
    cursor: 'BranchOrderItemWhereUniqueInput'
    distinct: List['BranchOrderItemScalarFieldKeys']
    include: 'BranchOrderItemIncludeFromBranchOrderItem'


class AuditLogIncludeFromStock(TypedDict, total=False):
    """Relational arguments for Stock"""
    user: Union[bool, 'UserArgsFromStock']


class AuditLogArgsFromStock(TypedDict, total=False):
    """Arguments for Stock"""
    include: 'AuditLogIncludeFromAuditLog'


class FindManyAuditLogArgsFromStock(TypedDict, total=False):
    """Arguments for Stock"""
    take: int
    skip: int
    order_by: Union['AuditLogOrderByInput', List['AuditLogOrderByInput']]
    where: 'AuditLogWhereInput'
    cursor: 'AuditLogWhereUniqueInput'
    distinct: List['AuditLogScalarFieldKeys']
    include: 'AuditLogIncludeFromAuditLog'


class SystemInfoIncludeFromStock(TypedDict, total=False):
    """Relational arguments for Stock"""


class SystemInfoArgsFromStock(TypedDict, total=False):
    """Arguments for Stock"""
    include: 'SystemInfoIncludeFromSystemInfo'


class FindManySystemInfoArgsFromStock(TypedDict, total=False):
    """Arguments for Stock"""
    take: int
    skip: int
    order_by: Union['SystemInfoOrderByInput', List['SystemInfoOrderByInput']]
    where: 'SystemInfoWhereInput'
    cursor: 'SystemInfoWhereUniqueInput'
    distinct: List['SystemInfoScalarFieldKeys']
    include: 'SystemInfoIncludeFromSystemInfo'


class BackupIncludeFromStock(TypedDict, total=False):
    """Relational arguments for Stock"""
    createdBy: Union[bool, 'UserArgsFromStock']


class BackupArgsFromStock(TypedDict, total=False):
    """Arguments for Stock"""
    include: 'BackupIncludeFromBackup'


class FindManyBackupArgsFromStock(TypedDict, total=False):
    """Arguments for Stock"""
    take: int
    skip: int
    order_by: Union['BackupOrderByInput', List['BackupOrderByInput']]
    where: 'BackupWhereInput'
    cursor: 'BackupWhereUniqueInput'
    distinct: List['BackupScalarFieldKeys']
    include: 'BackupIncludeFromBackup'


class RevokedTokenIncludeFromStock(TypedDict, total=False):
    """Relational arguments for Stock"""
    user: Union[bool, 'UserArgsFromStock']


class RevokedTokenArgsFromStock(TypedDict, total=False):
    """Arguments for Stock"""
    include: 'RevokedTokenIncludeFromRevokedToken'


class FindManyRevokedTokenArgsFromStock(TypedDict, total=False):
    """Arguments for Stock"""
    take: int
    skip: int
    order_by: Union['RevokedTokenOrderByInput', List['RevokedTokenOrderByInput']]
    where: 'RevokedTokenWhereInput'
    cursor: 'RevokedTokenWhereUniqueInput'
    distinct: List['RevokedTokenScalarFieldKeys']
    include: 'RevokedTokenIncludeFromRevokedToken'


class SystemSettingIncludeFromStock(TypedDict, total=False):
    """Relational arguments for Stock"""


class SystemSettingArgsFromStock(TypedDict, total=False):
    """Arguments for Stock"""
    include: 'SystemSettingIncludeFromSystemSetting'


class FindManySystemSettingArgsFromStock(TypedDict, total=False):
    """Arguments for Stock"""
    take: int
    skip: int
    order_by: Union['SystemSettingOrderByInput', List['SystemSettingOrderByInput']]
    where: 'SystemSettingWhereInput'
    cursor: 'SystemSettingWhereUniqueInput'
    distinct: List['SystemSettingScalarFieldKeys']
    include: 'SystemSettingIncludeFromSystemSetting'


class NotificationIncludeFromStock(TypedDict, total=False):
    """Relational arguments for Stock"""
    user: Union[bool, 'UserArgsFromStock']


class NotificationArgsFromStock(TypedDict, total=False):
    """Arguments for Stock"""
    include: 'NotificationIncludeFromNotification'


class FindManyNotificationArgsFromStock(TypedDict, total=False):
    """Arguments for Stock"""
    take: int
    skip: int
    order_by: Union['NotificationOrderByInput', List['NotificationOrderByInput']]
    where: 'NotificationWhereInput'
    cursor: 'NotificationWhereUniqueInput'
    distinct: List['NotificationScalarFieldKeys']
    include: 'NotificationIncludeFromNotification'


class StockAdjustmentIncludeFromStock(TypedDict, total=False):
    """Relational arguments for Stock"""
    product: Union[bool, 'ProductArgsFromStock']
    createdBy: Union[bool, 'UserArgsFromStock']


class StockAdjustmentArgsFromStock(TypedDict, total=False):
    """Arguments for Stock"""
    include: 'StockAdjustmentIncludeFromStockAdjustment'


class FindManyStockAdjustmentArgsFromStock(TypedDict, total=False):
    """Arguments for Stock"""
    take: int
    skip: int
    order_by: Union['StockAdjustmentOrderByInput', List['StockAdjustmentOrderByInput']]
    where: 'StockAdjustmentWhereInput'
    cursor: 'StockAdjustmentWhereUniqueInput'
    distinct: List['StockAdjustmentScalarFieldKeys']
    include: 'StockAdjustmentIncludeFromStockAdjustment'




FindManyStockArgs = FindManyStockArgsFromStock
FindFirstStockArgs = FindManyStockArgsFromStock


class StockWhereInput(TypedDict, total=False):
    """Stock arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    productId: Union[_int, 'types.IntFilter']
    product: 'ProductRelationFilter'
    quantity: Union[_int, 'types.IntFilter']
    lastRestocked: Union[None, datetime.datetime, 'types.DateTimeFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    SaleItem: 'SaleItemListRelationFilter'
    BranchOrderItem: 'BranchOrderItemListRelationFilter'

    # should be noted that AND and NOT should be Union['StockWhereInput', List['StockWhereInput']]
    # but this causes mypy to hang :/
    AND: List['StockWhereInput']
    OR: List['StockWhereInput']
    NOT: List['StockWhereInput']



# aggregate Stock types


class StockScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Stock arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    productId: Union[_int, 'types.IntWithAggregatesFilter']
    quantity: Union[_int, 'types.IntWithAggregatesFilter']
    lastRestocked: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['StockScalarWhereWithAggregatesInput']
    OR: List['StockScalarWhereWithAggregatesInput']
    NOT: List['StockScalarWhereWithAggregatesInput']



class StockGroupByOutput(TypedDict, total=False):
    id: _int
    productId: _int
    quantity: _int
    lastRestocked: datetime.datetime
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'StockSumAggregateOutput'
    _avg: 'StockAvgAggregateOutput'
    _min: 'StockMinAggregateOutput'
    _max: 'StockMaxAggregateOutput'
    _count: 'StockCountAggregateOutput'


class StockAvgAggregateOutput(TypedDict, total=False):
    """Stock output for aggregating averages"""
    id: float
    productId: float
    quantity: float


class StockSumAggregateOutput(TypedDict, total=False):
    """Stock output for aggregating sums"""
    id: _int
    productId: _int
    quantity: _int


class StockScalarAggregateOutput(TypedDict, total=False):
    """Stock output including scalar fields"""
    id: _int
    productId: _int
    quantity: _int
    lastRestocked: datetime.datetime
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


StockMinAggregateOutput = StockScalarAggregateOutput
StockMaxAggregateOutput = StockScalarAggregateOutput


class StockMaxAggregateInput(TypedDict, total=False):
    """Stock input for aggregating by max"""
    id: bool
    productId: bool
    quantity: bool
    lastRestocked: bool
    createdAt: bool
    updatedAt: bool


class StockMinAggregateInput(TypedDict, total=False):
    """Stock input for aggregating by min"""
    id: bool
    productId: bool
    quantity: bool
    lastRestocked: bool
    createdAt: bool
    updatedAt: bool


class StockNumberAggregateInput(TypedDict, total=False):
    """Stock input for aggregating numbers"""
    id: bool
    productId: bool
    quantity: bool


StockAvgAggregateInput = StockNumberAggregateInput
StockSumAggregateInput = StockNumberAggregateInput


StockCountAggregateInput = TypedDict(
    'StockCountAggregateInput',
    {
        'id': bool,
        'productId': bool,
        'quantity': bool,
        'lastRestocked': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

StockCountAggregateOutput = TypedDict(
    'StockCountAggregateOutput',
    {
        'id': int,
        'productId': int,
        'quantity': int,
        'lastRestocked': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


StockKeys = Literal[
    'id',
    'productId',
    'product',
    'quantity',
    'lastRestocked',
    'createdAt',
    'updatedAt',
    'SaleItem',
    'BranchOrderItem',
]
StockScalarFieldKeys = Literal[
    'id',
    'productId',
    'quantity',
    'lastRestocked',
    'createdAt',
    'updatedAt',
]
StockScalarFieldKeysT = TypeVar('StockScalarFieldKeysT', bound=StockScalarFieldKeys)

StockRelationalFieldKeys = Literal[
        'product',
        'SaleItem',
        'BranchOrderItem',
    ]

# Customer types

class CustomerOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Customer create method"""
    id: _int
    email: Optional[_str]
    phone: Optional[_str]
    address: Optional[_str]
    type: 'enums.CustomerType'
    creditLimit: decimal.Decimal
    balance: decimal.Decimal
    totalPurchases: decimal.Decimal
    status: 'enums.CustomerStatus'
    notes: Optional[_str]
    Sale: 'SaleCreateManyNestedWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class CustomerCreateInput(CustomerOptionalCreateInput):
    """Required arguments to the Customer create method"""
    name: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class CustomerOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Customer create method, without relations"""
    id: _int
    email: Optional[_str]
    phone: Optional[_str]
    address: Optional[_str]
    type: 'enums.CustomerType'
    creditLimit: decimal.Decimal
    balance: decimal.Decimal
    totalPurchases: decimal.Decimal
    status: 'enums.CustomerStatus'
    notes: Optional[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class CustomerCreateWithoutRelationsInput(CustomerOptionalCreateWithoutRelationsInput):
    """Required arguments to the Customer create method, without relations"""
    name: _str


class CustomerCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'CustomerCreateWithoutRelationsInput'
    connect: 'CustomerWhereUniqueInput'


class CustomerCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['CustomerCreateWithoutRelationsInput', List['CustomerCreateWithoutRelationsInput']]
    connect: Union['CustomerWhereUniqueInput', List['CustomerWhereUniqueInput']]


_CustomerWhereUnique_id_Input = TypedDict(
    '_CustomerWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

_CustomerWhereUnique_email_Input = TypedDict(
    '_CustomerWhereUnique_email_Input',
    {
        'email': '_str',
    },
    total=True
)

_CustomerWhereUnique_phone_Input = TypedDict(
    '_CustomerWhereUnique_phone_Input',
    {
        'phone': '_str',
    },
    total=True
)

CustomerWhereUniqueInput = Union[
    '_CustomerWhereUnique_id_Input',
    '_CustomerWhereUnique_email_Input',
    '_CustomerWhereUnique_phone_Input',
]


class CustomerUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    name: _str
    email: Optional[_str]
    phone: Optional[_str]
    address: Optional[_str]
    type: 'enums.CustomerType'
    creditLimit: decimal.Decimal
    balance: decimal.Decimal
    totalPurchases: decimal.Decimal
    status: 'enums.CustomerStatus'
    notes: Optional[_str]
    Sale: 'SaleUpdateManyWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class CustomerUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    name: _str
    email: Optional[_str]
    phone: Optional[_str]
    address: Optional[_str]
    type: 'enums.CustomerType'
    creditLimit: decimal.Decimal
    balance: decimal.Decimal
    totalPurchases: decimal.Decimal
    status: 'enums.CustomerStatus'
    notes: Optional[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class CustomerUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['CustomerCreateWithoutRelationsInput']
    connect: List['CustomerWhereUniqueInput']
    set: List['CustomerWhereUniqueInput']
    disconnect: List['CustomerWhereUniqueInput']
    delete: List['CustomerWhereUniqueInput']

    # TODO
    # update: List['CustomerUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['CustomerUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['CustomerScalarWhereInput']
    # upsert: List['CustomerUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['CustomerCreateOrConnectWithoutRelationsInput']


class CustomerUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'CustomerCreateWithoutRelationsInput'
    connect: 'CustomerWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'CustomerUpdateInput'
    # upsert: 'CustomerUpsertWithoutRelationsInput'
    # connectOrCreate: 'CustomerCreateOrConnectWithoutRelationsInput'


class CustomerUpsertInput(TypedDict):
    create: 'CustomerCreateInput'
    update: 'CustomerUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Customer_id_OrderByInput = TypedDict(
    '_Customer_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Customer_name_OrderByInput = TypedDict(
    '_Customer_name_OrderByInput',
    {
        'name': 'SortOrder',
    },
    total=True
)

_Customer_email_OrderByInput = TypedDict(
    '_Customer_email_OrderByInput',
    {
        'email': 'SortOrder',
    },
    total=True
)

_Customer_phone_OrderByInput = TypedDict(
    '_Customer_phone_OrderByInput',
    {
        'phone': 'SortOrder',
    },
    total=True
)

_Customer_address_OrderByInput = TypedDict(
    '_Customer_address_OrderByInput',
    {
        'address': 'SortOrder',
    },
    total=True
)

_Customer_type_OrderByInput = TypedDict(
    '_Customer_type_OrderByInput',
    {
        'type': 'SortOrder',
    },
    total=True
)

_Customer_creditLimit_OrderByInput = TypedDict(
    '_Customer_creditLimit_OrderByInput',
    {
        'creditLimit': 'SortOrder',
    },
    total=True
)

_Customer_balance_OrderByInput = TypedDict(
    '_Customer_balance_OrderByInput',
    {
        'balance': 'SortOrder',
    },
    total=True
)

_Customer_totalPurchases_OrderByInput = TypedDict(
    '_Customer_totalPurchases_OrderByInput',
    {
        'totalPurchases': 'SortOrder',
    },
    total=True
)

_Customer_status_OrderByInput = TypedDict(
    '_Customer_status_OrderByInput',
    {
        'status': 'SortOrder',
    },
    total=True
)

_Customer_notes_OrderByInput = TypedDict(
    '_Customer_notes_OrderByInput',
    {
        'notes': 'SortOrder',
    },
    total=True
)

_Customer_createdAt_OrderByInput = TypedDict(
    '_Customer_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Customer_updatedAt_OrderByInput = TypedDict(
    '_Customer_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

CustomerOrderByInput = Union[
    '_Customer_id_OrderByInput',
    '_Customer_name_OrderByInput',
    '_Customer_email_OrderByInput',
    '_Customer_phone_OrderByInput',
    '_Customer_address_OrderByInput',
    '_Customer_type_OrderByInput',
    '_Customer_creditLimit_OrderByInput',
    '_Customer_balance_OrderByInput',
    '_Customer_totalPurchases_OrderByInput',
    '_Customer_status_OrderByInput',
    '_Customer_notes_OrderByInput',
    '_Customer_createdAt_OrderByInput',
    '_Customer_updatedAt_OrderByInput',
]



# recursive Customer types
# TODO: cleanup these types



CustomerRelationFilter = TypedDict(
    'CustomerRelationFilter',
    {
        'is': 'CustomerWhereInput',
        'is_not': 'CustomerWhereInput',
    },
    total=False,
)


class CustomerListRelationFilter(TypedDict, total=False):
    some: 'CustomerWhereInput'
    none: 'CustomerWhereInput'
    every: 'CustomerWhereInput'


class CustomerInclude(TypedDict, total=False):
    """Customer relational arguments"""
    Sale: Union[bool, 'FindManySaleArgsFromCustomer']


class UserIncludeFromCustomer(TypedDict, total=False):
    """Relational arguments for Customer"""
    branch: Union[bool, 'BranchArgsFromCustomer']
    auditLogs: Union[bool, 'FindManyAuditLogArgsFromCustomer']
    permissions: Union[bool, 'FindManyUserPermissionArgsFromCustomer']
    notifications: Union[bool, 'FindManyNotificationArgsFromCustomer']
    revokedTokens: Union[bool, 'FindManyRevokedTokenArgsFromCustomer']
    stockAdjustments: Union[bool, 'FindManyStockAdjustmentArgsFromCustomer']
    Sale: Union[bool, 'FindManySaleArgsFromCustomer']
    deletedSales: Union[bool, 'FindManySaleArgsFromCustomer']
    Payment: Union[bool, 'FindManyPaymentArgsFromCustomer']
    Backup: Union[bool, 'FindManyBackupArgsFromCustomer']
    requestedOrders: Union[bool, 'FindManyBranchOrderArgsFromCustomer']
    approvedOrders: Union[bool, 'FindManyBranchOrderArgsFromCustomer']
    sentOrders: Union[bool, 'FindManyBranchOrderArgsFromCustomer']
    receivedOrders: Union[bool, 'FindManyBranchOrderArgsFromCustomer']


class UserArgsFromCustomer(TypedDict, total=False):
    """Arguments for Customer"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromCustomer(TypedDict, total=False):
    """Arguments for Customer"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class UserPermissionIncludeFromCustomer(TypedDict, total=False):
    """Relational arguments for Customer"""
    user: Union[bool, 'UserArgsFromCustomer']


class UserPermissionArgsFromCustomer(TypedDict, total=False):
    """Arguments for Customer"""
    include: 'UserPermissionIncludeFromUserPermission'


class FindManyUserPermissionArgsFromCustomer(TypedDict, total=False):
    """Arguments for Customer"""
    take: int
    skip: int
    order_by: Union['UserPermissionOrderByInput', List['UserPermissionOrderByInput']]
    where: 'UserPermissionWhereInput'
    cursor: 'UserPermissionWhereUniqueInput'
    distinct: List['UserPermissionScalarFieldKeys']
    include: 'UserPermissionIncludeFromUserPermission'


class BranchIncludeFromCustomer(TypedDict, total=False):
    """Relational arguments for Customer"""
    users: Union[bool, 'FindManyUserArgsFromCustomer']
    Sale: Union[bool, 'FindManySaleArgsFromCustomer']
    Account: Union[bool, 'FindManyAccountArgsFromCustomer']
    BranchOrder: Union[bool, 'FindManyBranchOrderArgsFromCustomer']


class BranchArgsFromCustomer(TypedDict, total=False):
    """Arguments for Customer"""
    include: 'BranchIncludeFromBranch'


class FindManyBranchArgsFromCustomer(TypedDict, total=False):
    """Arguments for Customer"""
    take: int
    skip: int
    order_by: Union['BranchOrderByInput', List['BranchOrderByInput']]
    where: 'BranchWhereInput'
    cursor: 'BranchWhereUniqueInput'
    distinct: List['BranchScalarFieldKeys']
    include: 'BranchIncludeFromBranch'


class ProductIncludeFromCustomer(TypedDict, total=False):
    """Relational arguments for Customer"""
    category: Union[bool, 'CategoryArgsFromCustomer']
    stocks: Union[bool, 'FindManyStockArgsFromCustomer']
    stockAdjustments: Union[bool, 'FindManyStockAdjustmentArgsFromCustomer']


class ProductArgsFromCustomer(TypedDict, total=False):
    """Arguments for Customer"""
    include: 'ProductIncludeFromProduct'


class FindManyProductArgsFromCustomer(TypedDict, total=False):
    """Arguments for Customer"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProduct'


class CategoryIncludeFromCustomer(TypedDict, total=False):
    """Relational arguments for Customer"""
    products: Union[bool, 'FindManyProductArgsFromCustomer']


class CategoryArgsFromCustomer(TypedDict, total=False):
    """Arguments for Customer"""
    include: 'CategoryIncludeFromCategory'


class FindManyCategoryArgsFromCustomer(TypedDict, total=False):
    """Arguments for Customer"""
    take: int
    skip: int
    order_by: Union['CategoryOrderByInput', List['CategoryOrderByInput']]
    where: 'CategoryWhereInput'
    cursor: 'CategoryWhereUniqueInput'
    distinct: List['CategoryScalarFieldKeys']
    include: 'CategoryIncludeFromCategory'


class StockIncludeFromCustomer(TypedDict, total=False):
    """Relational arguments for Customer"""
    product: Union[bool, 'ProductArgsFromCustomer']
    SaleItem: Union[bool, 'FindManySaleItemArgsFromCustomer']
    BranchOrderItem: Union[bool, 'FindManyBranchOrderItemArgsFromCustomer']


class StockArgsFromCustomer(TypedDict, total=False):
    """Arguments for Customer"""
    include: 'StockIncludeFromStock'


class FindManyStockArgsFromCustomer(TypedDict, total=False):
    """Arguments for Customer"""
    take: int
    skip: int
    order_by: Union['StockOrderByInput', List['StockOrderByInput']]
    where: 'StockWhereInput'
    cursor: 'StockWhereUniqueInput'
    distinct: List['StockScalarFieldKeys']
    include: 'StockIncludeFromStock'


class CustomerIncludeFromCustomer(TypedDict, total=False):
    """Relational arguments for Customer"""
    Sale: Union[bool, 'FindManySaleArgsFromCustomer']


class CustomerArgsFromCustomer(TypedDict, total=False):
    """Arguments for Customer"""
    include: 'CustomerIncludeFromCustomer'


class FindManyCustomerArgsFromCustomer(TypedDict, total=False):
    """Arguments for Customer"""
    take: int
    skip: int
    order_by: Union['CustomerOrderByInput', List['CustomerOrderByInput']]
    where: 'CustomerWhereInput'
    cursor: 'CustomerWhereUniqueInput'
    distinct: List['CustomerScalarFieldKeys']
    include: 'CustomerIncludeFromCustomer'


class SaleIncludeFromCustomer(TypedDict, total=False):
    """Relational arguments for Customer"""
    branch: Union[bool, 'BranchArgsFromCustomer']
    customer: Union[bool, 'CustomerArgsFromCustomer']
    user: Union[bool, 'UserArgsFromCustomer']
    items: Union[bool, 'FindManySaleItemArgsFromCustomer']
    payments: Union[bool, 'FindManyPaymentArgsFromCustomer']
    returns: Union[bool, 'FindManyReturnSaleArgsFromCustomer']
    deletedBy: Union[bool, 'UserArgsFromCustomer']


class SaleArgsFromCustomer(TypedDict, total=False):
    """Arguments for Customer"""
    include: 'SaleIncludeFromSale'


class FindManySaleArgsFromCustomer(TypedDict, total=False):
    """Arguments for Customer"""
    take: int
    skip: int
    order_by: Union['SaleOrderByInput', List['SaleOrderByInput']]
    where: 'SaleWhereInput'
    cursor: 'SaleWhereUniqueInput'
    distinct: List['SaleScalarFieldKeys']
    include: 'SaleIncludeFromSale'


class SaleItemIncludeFromCustomer(TypedDict, total=False):
    """Relational arguments for Customer"""
    sale: Union[bool, 'SaleArgsFromCustomer']
    stock: Union[bool, 'StockArgsFromCustomer']
    ReturnItem: Union[bool, 'FindManyReturnItemArgsFromCustomer']


class SaleItemArgsFromCustomer(TypedDict, total=False):
    """Arguments for Customer"""
    include: 'SaleItemIncludeFromSaleItem'


class FindManySaleItemArgsFromCustomer(TypedDict, total=False):
    """Arguments for Customer"""
    take: int
    skip: int
    order_by: Union['SaleItemOrderByInput', List['SaleItemOrderByInput']]
    where: 'SaleItemWhereInput'
    cursor: 'SaleItemWhereUniqueInput'
    distinct: List['SaleItemScalarFieldKeys']
    include: 'SaleItemIncludeFromSaleItem'


class ReturnSaleIncludeFromCustomer(TypedDict, total=False):
    """Relational arguments for Customer"""
    original: Union[bool, 'SaleArgsFromCustomer']
    items: Union[bool, 'FindManyReturnItemArgsFromCustomer']
    refund: Union[bool, 'FindManyPaymentArgsFromCustomer']


class ReturnSaleArgsFromCustomer(TypedDict, total=False):
    """Arguments for Customer"""
    include: 'ReturnSaleIncludeFromReturnSale'


class FindManyReturnSaleArgsFromCustomer(TypedDict, total=False):
    """Arguments for Customer"""
    take: int
    skip: int
    order_by: Union['ReturnSaleOrderByInput', List['ReturnSaleOrderByInput']]
    where: 'ReturnSaleWhereInput'
    cursor: 'ReturnSaleWhereUniqueInput'
    distinct: List['ReturnSaleScalarFieldKeys']
    include: 'ReturnSaleIncludeFromReturnSale'


class ReturnItemIncludeFromCustomer(TypedDict, total=False):
    """Relational arguments for Customer"""
    returnSale: Union[bool, 'ReturnSaleArgsFromCustomer']
    saleItem: Union[bool, 'SaleItemArgsFromCustomer']


class ReturnItemArgsFromCustomer(TypedDict, total=False):
    """Arguments for Customer"""
    include: 'ReturnItemIncludeFromReturnItem'


class FindManyReturnItemArgsFromCustomer(TypedDict, total=False):
    """Arguments for Customer"""
    take: int
    skip: int
    order_by: Union['ReturnItemOrderByInput', List['ReturnItemOrderByInput']]
    where: 'ReturnItemWhereInput'
    cursor: 'ReturnItemWhereUniqueInput'
    distinct: List['ReturnItemScalarFieldKeys']
    include: 'ReturnItemIncludeFromReturnItem'


class PaymentIncludeFromCustomer(TypedDict, total=False):
    """Relational arguments for Customer"""
    sale: Union[bool, 'SaleArgsFromCustomer']
    account: Union[bool, 'AccountArgsFromCustomer']
    returnSale: Union[bool, 'ReturnSaleArgsFromCustomer']
    user: Union[bool, 'UserArgsFromCustomer']


class PaymentArgsFromCustomer(TypedDict, total=False):
    """Arguments for Customer"""
    include: 'PaymentIncludeFromPayment'


class FindManyPaymentArgsFromCustomer(TypedDict, total=False):
    """Arguments for Customer"""
    take: int
    skip: int
    order_by: Union['PaymentOrderByInput', List['PaymentOrderByInput']]
    where: 'PaymentWhereInput'
    cursor: 'PaymentWhereUniqueInput'
    distinct: List['PaymentScalarFieldKeys']
    include: 'PaymentIncludeFromPayment'


class JournalEntryIncludeFromCustomer(TypedDict, total=False):
    """Relational arguments for Customer"""
    lines: Union[bool, 'FindManyJournalEntryLineArgsFromCustomer']


class JournalEntryArgsFromCustomer(TypedDict, total=False):
    """Arguments for Customer"""
    include: 'JournalEntryIncludeFromJournalEntry'


class FindManyJournalEntryArgsFromCustomer(TypedDict, total=False):
    """Arguments for Customer"""
    take: int
    skip: int
    order_by: Union['JournalEntryOrderByInput', List['JournalEntryOrderByInput']]
    where: 'JournalEntryWhereInput'
    cursor: 'JournalEntryWhereUniqueInput'
    distinct: List['JournalEntryScalarFieldKeys']
    include: 'JournalEntryIncludeFromJournalEntry'


class JournalEntryLineIncludeFromCustomer(TypedDict, total=False):
    """Relational arguments for Customer"""
    entry: Union[bool, 'JournalEntryArgsFromCustomer']
    account: Union[bool, 'AccountArgsFromCustomer']


class JournalEntryLineArgsFromCustomer(TypedDict, total=False):
    """Arguments for Customer"""
    include: 'JournalEntryLineIncludeFromJournalEntryLine'


class FindManyJournalEntryLineArgsFromCustomer(TypedDict, total=False):
    """Arguments for Customer"""
    take: int
    skip: int
    order_by: Union['JournalEntryLineOrderByInput', List['JournalEntryLineOrderByInput']]
    where: 'JournalEntryLineWhereInput'
    cursor: 'JournalEntryLineWhereUniqueInput'
    distinct: List['JournalEntryLineScalarFieldKeys']
    include: 'JournalEntryLineIncludeFromJournalEntryLine'


class AccountIncludeFromCustomer(TypedDict, total=False):
    """Relational arguments for Customer"""
    branch: Union[bool, 'BranchArgsFromCustomer']
    entries: Union[bool, 'FindManyJournalEntryLineArgsFromCustomer']
    payments: Union[bool, 'FindManyPaymentArgsFromCustomer']
    outgoingTransfers: Union[bool, 'FindManyAccountTransferArgsFromCustomer']
    incomingTransfers: Union[bool, 'FindManyAccountTransferArgsFromCustomer']


class AccountArgsFromCustomer(TypedDict, total=False):
    """Arguments for Customer"""
    include: 'AccountIncludeFromAccount'


class FindManyAccountArgsFromCustomer(TypedDict, total=False):
    """Arguments for Customer"""
    take: int
    skip: int
    order_by: Union['AccountOrderByInput', List['AccountOrderByInput']]
    where: 'AccountWhereInput'
    cursor: 'AccountWhereUniqueInput'
    distinct: List['AccountScalarFieldKeys']
    include: 'AccountIncludeFromAccount'


class AccountTransferIncludeFromCustomer(TypedDict, total=False):
    """Relational arguments for Customer"""
    fromAccount: Union[bool, 'AccountArgsFromCustomer']
    toAccount: Union[bool, 'AccountArgsFromCustomer']


class AccountTransferArgsFromCustomer(TypedDict, total=False):
    """Arguments for Customer"""
    include: 'AccountTransferIncludeFromAccountTransfer'


class FindManyAccountTransferArgsFromCustomer(TypedDict, total=False):
    """Arguments for Customer"""
    take: int
    skip: int
    order_by: Union['AccountTransferOrderByInput', List['AccountTransferOrderByInput']]
    where: 'AccountTransferWhereInput'
    cursor: 'AccountTransferWhereUniqueInput'
    distinct: List['AccountTransferScalarFieldKeys']
    include: 'AccountTransferIncludeFromAccountTransfer'


class BranchOrderIncludeFromCustomer(TypedDict, total=False):
    """Relational arguments for Customer"""
    branch: Union[bool, 'BranchArgsFromCustomer']
    requestedBy: Union[bool, 'UserArgsFromCustomer']
    approvedBy: Union[bool, 'UserArgsFromCustomer']
    sentBy: Union[bool, 'UserArgsFromCustomer']
    receivedBy: Union[bool, 'UserArgsFromCustomer']
    items: Union[bool, 'FindManyBranchOrderItemArgsFromCustomer']


class BranchOrderArgsFromCustomer(TypedDict, total=False):
    """Arguments for Customer"""
    include: 'BranchOrderIncludeFromBranchOrder'


class FindManyBranchOrderArgsFromCustomer(TypedDict, total=False):
    """Arguments for Customer"""
    take: int
    skip: int
    order_by: Union['BranchOrderOrderByInput', List['BranchOrderOrderByInput']]
    where: 'BranchOrderWhereInput'
    cursor: 'BranchOrderWhereUniqueInput'
    distinct: List['BranchOrderScalarFieldKeys']
    include: 'BranchOrderIncludeFromBranchOrder'


class BranchOrderItemIncludeFromCustomer(TypedDict, total=False):
    """Relational arguments for Customer"""
    branchOrder: Union[bool, 'BranchOrderArgsFromCustomer']
    stock: Union[bool, 'StockArgsFromCustomer']


class BranchOrderItemArgsFromCustomer(TypedDict, total=False):
    """Arguments for Customer"""
    include: 'BranchOrderItemIncludeFromBranchOrderItem'


class FindManyBranchOrderItemArgsFromCustomer(TypedDict, total=False):
    """Arguments for Customer"""
    take: int
    skip: int
    order_by: Union['BranchOrderItemOrderByInput', List['BranchOrderItemOrderByInput']]
    where: 'BranchOrderItemWhereInput'
    cursor: 'BranchOrderItemWhereUniqueInput'
    distinct: List['BranchOrderItemScalarFieldKeys']
    include: 'BranchOrderItemIncludeFromBranchOrderItem'


class AuditLogIncludeFromCustomer(TypedDict, total=False):
    """Relational arguments for Customer"""
    user: Union[bool, 'UserArgsFromCustomer']


class AuditLogArgsFromCustomer(TypedDict, total=False):
    """Arguments for Customer"""
    include: 'AuditLogIncludeFromAuditLog'


class FindManyAuditLogArgsFromCustomer(TypedDict, total=False):
    """Arguments for Customer"""
    take: int
    skip: int
    order_by: Union['AuditLogOrderByInput', List['AuditLogOrderByInput']]
    where: 'AuditLogWhereInput'
    cursor: 'AuditLogWhereUniqueInput'
    distinct: List['AuditLogScalarFieldKeys']
    include: 'AuditLogIncludeFromAuditLog'


class SystemInfoIncludeFromCustomer(TypedDict, total=False):
    """Relational arguments for Customer"""


class SystemInfoArgsFromCustomer(TypedDict, total=False):
    """Arguments for Customer"""
    include: 'SystemInfoIncludeFromSystemInfo'


class FindManySystemInfoArgsFromCustomer(TypedDict, total=False):
    """Arguments for Customer"""
    take: int
    skip: int
    order_by: Union['SystemInfoOrderByInput', List['SystemInfoOrderByInput']]
    where: 'SystemInfoWhereInput'
    cursor: 'SystemInfoWhereUniqueInput'
    distinct: List['SystemInfoScalarFieldKeys']
    include: 'SystemInfoIncludeFromSystemInfo'


class BackupIncludeFromCustomer(TypedDict, total=False):
    """Relational arguments for Customer"""
    createdBy: Union[bool, 'UserArgsFromCustomer']


class BackupArgsFromCustomer(TypedDict, total=False):
    """Arguments for Customer"""
    include: 'BackupIncludeFromBackup'


class FindManyBackupArgsFromCustomer(TypedDict, total=False):
    """Arguments for Customer"""
    take: int
    skip: int
    order_by: Union['BackupOrderByInput', List['BackupOrderByInput']]
    where: 'BackupWhereInput'
    cursor: 'BackupWhereUniqueInput'
    distinct: List['BackupScalarFieldKeys']
    include: 'BackupIncludeFromBackup'


class RevokedTokenIncludeFromCustomer(TypedDict, total=False):
    """Relational arguments for Customer"""
    user: Union[bool, 'UserArgsFromCustomer']


class RevokedTokenArgsFromCustomer(TypedDict, total=False):
    """Arguments for Customer"""
    include: 'RevokedTokenIncludeFromRevokedToken'


class FindManyRevokedTokenArgsFromCustomer(TypedDict, total=False):
    """Arguments for Customer"""
    take: int
    skip: int
    order_by: Union['RevokedTokenOrderByInput', List['RevokedTokenOrderByInput']]
    where: 'RevokedTokenWhereInput'
    cursor: 'RevokedTokenWhereUniqueInput'
    distinct: List['RevokedTokenScalarFieldKeys']
    include: 'RevokedTokenIncludeFromRevokedToken'


class SystemSettingIncludeFromCustomer(TypedDict, total=False):
    """Relational arguments for Customer"""


class SystemSettingArgsFromCustomer(TypedDict, total=False):
    """Arguments for Customer"""
    include: 'SystemSettingIncludeFromSystemSetting'


class FindManySystemSettingArgsFromCustomer(TypedDict, total=False):
    """Arguments for Customer"""
    take: int
    skip: int
    order_by: Union['SystemSettingOrderByInput', List['SystemSettingOrderByInput']]
    where: 'SystemSettingWhereInput'
    cursor: 'SystemSettingWhereUniqueInput'
    distinct: List['SystemSettingScalarFieldKeys']
    include: 'SystemSettingIncludeFromSystemSetting'


class NotificationIncludeFromCustomer(TypedDict, total=False):
    """Relational arguments for Customer"""
    user: Union[bool, 'UserArgsFromCustomer']


class NotificationArgsFromCustomer(TypedDict, total=False):
    """Arguments for Customer"""
    include: 'NotificationIncludeFromNotification'


class FindManyNotificationArgsFromCustomer(TypedDict, total=False):
    """Arguments for Customer"""
    take: int
    skip: int
    order_by: Union['NotificationOrderByInput', List['NotificationOrderByInput']]
    where: 'NotificationWhereInput'
    cursor: 'NotificationWhereUniqueInput'
    distinct: List['NotificationScalarFieldKeys']
    include: 'NotificationIncludeFromNotification'


class StockAdjustmentIncludeFromCustomer(TypedDict, total=False):
    """Relational arguments for Customer"""
    product: Union[bool, 'ProductArgsFromCustomer']
    createdBy: Union[bool, 'UserArgsFromCustomer']


class StockAdjustmentArgsFromCustomer(TypedDict, total=False):
    """Arguments for Customer"""
    include: 'StockAdjustmentIncludeFromStockAdjustment'


class FindManyStockAdjustmentArgsFromCustomer(TypedDict, total=False):
    """Arguments for Customer"""
    take: int
    skip: int
    order_by: Union['StockAdjustmentOrderByInput', List['StockAdjustmentOrderByInput']]
    where: 'StockAdjustmentWhereInput'
    cursor: 'StockAdjustmentWhereUniqueInput'
    distinct: List['StockAdjustmentScalarFieldKeys']
    include: 'StockAdjustmentIncludeFromStockAdjustment'




FindManyCustomerArgs = FindManyCustomerArgsFromCustomer
FindFirstCustomerArgs = FindManyCustomerArgsFromCustomer


class CustomerWhereInput(TypedDict, total=False):
    """Customer arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    name: Union[_str, 'types.StringFilter']
    email: Union[None, _str, 'types.StringFilter']
    phone: Union[None, _str, 'types.StringFilter']
    address: Union[None, _str, 'types.StringFilter']
    type: 'enums.CustomerType'
    creditLimit: Union[decimal.Decimal, 'types.DecimalFilter']
    balance: Union[decimal.Decimal, 'types.DecimalFilter']
    totalPurchases: Union[decimal.Decimal, 'types.DecimalFilter']
    status: 'enums.CustomerStatus'
    notes: Union[None, _str, 'types.StringFilter']
    Sale: 'SaleListRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['CustomerWhereInput', List['CustomerWhereInput']]
    # but this causes mypy to hang :/
    AND: List['CustomerWhereInput']
    OR: List['CustomerWhereInput']
    NOT: List['CustomerWhereInput']



# aggregate Customer types


class CustomerScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Customer arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    phone: Union[_str, 'types.StringWithAggregatesFilter']
    address: Union[_str, 'types.StringWithAggregatesFilter']
    type: 'enums.CustomerType'
    creditLimit: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    balance: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    totalPurchases: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    status: 'enums.CustomerStatus'
    notes: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['CustomerScalarWhereWithAggregatesInput']
    OR: List['CustomerScalarWhereWithAggregatesInput']
    NOT: List['CustomerScalarWhereWithAggregatesInput']



class CustomerGroupByOutput(TypedDict, total=False):
    id: _int
    name: _str
    email: _str
    phone: _str
    address: _str
    type: 'enums.CustomerType'
    creditLimit: decimal.Decimal
    balance: decimal.Decimal
    totalPurchases: decimal.Decimal
    status: 'enums.CustomerStatus'
    notes: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'CustomerSumAggregateOutput'
    _avg: 'CustomerAvgAggregateOutput'
    _min: 'CustomerMinAggregateOutput'
    _max: 'CustomerMaxAggregateOutput'
    _count: 'CustomerCountAggregateOutput'


class CustomerAvgAggregateOutput(TypedDict, total=False):
    """Customer output for aggregating averages"""
    id: float


class CustomerSumAggregateOutput(TypedDict, total=False):
    """Customer output for aggregating sums"""
    id: _int


class CustomerScalarAggregateOutput(TypedDict, total=False):
    """Customer output including scalar fields"""
    id: _int
    name: _str
    email: _str
    phone: _str
    address: _str
    type: 'enums.CustomerType'
    creditLimit: decimal.Decimal
    balance: decimal.Decimal
    totalPurchases: decimal.Decimal
    status: 'enums.CustomerStatus'
    notes: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


CustomerMinAggregateOutput = CustomerScalarAggregateOutput
CustomerMaxAggregateOutput = CustomerScalarAggregateOutput


class CustomerMaxAggregateInput(TypedDict, total=False):
    """Customer input for aggregating by max"""
    id: bool
    name: bool
    email: bool
    phone: bool
    address: bool
    type: bool
    creditLimit: bool
    balance: bool
    totalPurchases: bool
    status: bool
    notes: bool
    createdAt: bool
    updatedAt: bool


class CustomerMinAggregateInput(TypedDict, total=False):
    """Customer input for aggregating by min"""
    id: bool
    name: bool
    email: bool
    phone: bool
    address: bool
    type: bool
    creditLimit: bool
    balance: bool
    totalPurchases: bool
    status: bool
    notes: bool
    createdAt: bool
    updatedAt: bool


class CustomerNumberAggregateInput(TypedDict, total=False):
    """Customer input for aggregating numbers"""
    id: bool


CustomerAvgAggregateInput = CustomerNumberAggregateInput
CustomerSumAggregateInput = CustomerNumberAggregateInput


CustomerCountAggregateInput = TypedDict(
    'CustomerCountAggregateInput',
    {
        'id': bool,
        'name': bool,
        'email': bool,
        'phone': bool,
        'address': bool,
        'type': bool,
        'creditLimit': bool,
        'balance': bool,
        'totalPurchases': bool,
        'status': bool,
        'notes': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

CustomerCountAggregateOutput = TypedDict(
    'CustomerCountAggregateOutput',
    {
        'id': int,
        'name': int,
        'email': int,
        'phone': int,
        'address': int,
        'type': int,
        'creditLimit': int,
        'balance': int,
        'totalPurchases': int,
        'status': int,
        'notes': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


CustomerKeys = Literal[
    'id',
    'name',
    'email',
    'phone',
    'address',
    'type',
    'creditLimit',
    'balance',
    'totalPurchases',
    'status',
    'notes',
    'Sale',
    'createdAt',
    'updatedAt',
]
CustomerScalarFieldKeys = Literal[
    'id',
    'name',
    'email',
    'phone',
    'address',
    'type',
    'creditLimit',
    'balance',
    'totalPurchases',
    'status',
    'notes',
    'createdAt',
    'updatedAt',
]
CustomerScalarFieldKeysT = TypeVar('CustomerScalarFieldKeysT', bound=CustomerScalarFieldKeys)

CustomerRelationalFieldKeys = Literal[
        'Sale',
    ]

# Sale types

class SaleOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Sale create method"""
    id: _int
    branchId: _int
    branch: 'BranchCreateNestedWithoutRelationsInput'
    discount: decimal.Decimal
    paymentType: 'enums.PaymentType'
    customerId: Optional[_int]
    customer: 'CustomerCreateNestedWithoutRelationsInput'
    userId: _int
    user: 'UserCreateNestedWithoutRelationsInput'
    items: 'SaleItemCreateManyNestedWithoutRelationsInput'
    payments: 'PaymentCreateManyNestedWithoutRelationsInput'
    returns: 'ReturnSaleCreateManyNestedWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deletedAt: Optional[datetime.datetime]
    deletedById: Optional[_int]
    deletedBy: 'UserCreateNestedWithoutRelationsInput'


class SaleCreateInput(SaleOptionalCreateInput):
    """Required arguments to the Sale create method"""
    totalAmount: decimal.Decimal


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class SaleOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Sale create method, without relations"""
    id: _int
    branchId: _int
    discount: decimal.Decimal
    paymentType: 'enums.PaymentType'
    customerId: Optional[_int]
    userId: _int
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deletedAt: Optional[datetime.datetime]
    deletedById: Optional[_int]


class SaleCreateWithoutRelationsInput(SaleOptionalCreateWithoutRelationsInput):
    """Required arguments to the Sale create method, without relations"""
    totalAmount: decimal.Decimal


class SaleCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'SaleCreateWithoutRelationsInput'
    connect: 'SaleWhereUniqueInput'


class SaleCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['SaleCreateWithoutRelationsInput', List['SaleCreateWithoutRelationsInput']]
    connect: Union['SaleWhereUniqueInput', List['SaleWhereUniqueInput']]


_SaleWhereUnique_id_Input = TypedDict(
    '_SaleWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

SaleWhereUniqueInput = _SaleWhereUnique_id_Input


class SaleUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    branch: 'BranchUpdateOneWithoutRelationsInput'
    totalAmount: decimal.Decimal
    discount: decimal.Decimal
    paymentType: 'enums.PaymentType'
    customer: 'CustomerUpdateOneWithoutRelationsInput'
    user: 'UserUpdateOneWithoutRelationsInput'
    items: 'SaleItemUpdateManyWithoutRelationsInput'
    payments: 'PaymentUpdateManyWithoutRelationsInput'
    returns: 'ReturnSaleUpdateManyWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deletedAt: Optional[datetime.datetime]
    deletedBy: 'UserUpdateOneWithoutRelationsInput'


class SaleUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    totalAmount: decimal.Decimal
    discount: decimal.Decimal
    paymentType: 'enums.PaymentType'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deletedAt: Optional[datetime.datetime]


class SaleUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['SaleCreateWithoutRelationsInput']
    connect: List['SaleWhereUniqueInput']
    set: List['SaleWhereUniqueInput']
    disconnect: List['SaleWhereUniqueInput']
    delete: List['SaleWhereUniqueInput']

    # TODO
    # update: List['SaleUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['SaleUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['SaleScalarWhereInput']
    # upsert: List['SaleUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['SaleCreateOrConnectWithoutRelationsInput']


class SaleUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'SaleCreateWithoutRelationsInput'
    connect: 'SaleWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'SaleUpdateInput'
    # upsert: 'SaleUpsertWithoutRelationsInput'
    # connectOrCreate: 'SaleCreateOrConnectWithoutRelationsInput'


class SaleUpsertInput(TypedDict):
    create: 'SaleCreateInput'
    update: 'SaleUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Sale_id_OrderByInput = TypedDict(
    '_Sale_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Sale_branchId_OrderByInput = TypedDict(
    '_Sale_branchId_OrderByInput',
    {
        'branchId': 'SortOrder',
    },
    total=True
)

_Sale_totalAmount_OrderByInput = TypedDict(
    '_Sale_totalAmount_OrderByInput',
    {
        'totalAmount': 'SortOrder',
    },
    total=True
)

_Sale_discount_OrderByInput = TypedDict(
    '_Sale_discount_OrderByInput',
    {
        'discount': 'SortOrder',
    },
    total=True
)

_Sale_paymentType_OrderByInput = TypedDict(
    '_Sale_paymentType_OrderByInput',
    {
        'paymentType': 'SortOrder',
    },
    total=True
)

_Sale_customerId_OrderByInput = TypedDict(
    '_Sale_customerId_OrderByInput',
    {
        'customerId': 'SortOrder',
    },
    total=True
)

_Sale_userId_OrderByInput = TypedDict(
    '_Sale_userId_OrderByInput',
    {
        'userId': 'SortOrder',
    },
    total=True
)

_Sale_createdAt_OrderByInput = TypedDict(
    '_Sale_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Sale_updatedAt_OrderByInput = TypedDict(
    '_Sale_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_Sale_deletedAt_OrderByInput = TypedDict(
    '_Sale_deletedAt_OrderByInput',
    {
        'deletedAt': 'SortOrder',
    },
    total=True
)

_Sale_deletedById_OrderByInput = TypedDict(
    '_Sale_deletedById_OrderByInput',
    {
        'deletedById': 'SortOrder',
    },
    total=True
)

SaleOrderByInput = Union[
    '_Sale_id_OrderByInput',
    '_Sale_branchId_OrderByInput',
    '_Sale_totalAmount_OrderByInput',
    '_Sale_discount_OrderByInput',
    '_Sale_paymentType_OrderByInput',
    '_Sale_customerId_OrderByInput',
    '_Sale_userId_OrderByInput',
    '_Sale_createdAt_OrderByInput',
    '_Sale_updatedAt_OrderByInput',
    '_Sale_deletedAt_OrderByInput',
    '_Sale_deletedById_OrderByInput',
]



# recursive Sale types
# TODO: cleanup these types



SaleRelationFilter = TypedDict(
    'SaleRelationFilter',
    {
        'is': 'SaleWhereInput',
        'is_not': 'SaleWhereInput',
    },
    total=False,
)


class SaleListRelationFilter(TypedDict, total=False):
    some: 'SaleWhereInput'
    none: 'SaleWhereInput'
    every: 'SaleWhereInput'


class SaleInclude(TypedDict, total=False):
    """Sale relational arguments"""
    branch: Union[bool, 'BranchArgsFromSale']
    customer: Union[bool, 'CustomerArgsFromSale']
    user: Union[bool, 'UserArgsFromSale']
    items: Union[bool, 'FindManySaleItemArgsFromSale']
    payments: Union[bool, 'FindManyPaymentArgsFromSale']
    returns: Union[bool, 'FindManyReturnSaleArgsFromSale']
    deletedBy: Union[bool, 'UserArgsFromSale']


class UserIncludeFromSale(TypedDict, total=False):
    """Relational arguments for Sale"""
    branch: Union[bool, 'BranchArgsFromSale']
    auditLogs: Union[bool, 'FindManyAuditLogArgsFromSale']
    permissions: Union[bool, 'FindManyUserPermissionArgsFromSale']
    notifications: Union[bool, 'FindManyNotificationArgsFromSale']
    revokedTokens: Union[bool, 'FindManyRevokedTokenArgsFromSale']
    stockAdjustments: Union[bool, 'FindManyStockAdjustmentArgsFromSale']
    Sale: Union[bool, 'FindManySaleArgsFromSale']
    deletedSales: Union[bool, 'FindManySaleArgsFromSale']
    Payment: Union[bool, 'FindManyPaymentArgsFromSale']
    Backup: Union[bool, 'FindManyBackupArgsFromSale']
    requestedOrders: Union[bool, 'FindManyBranchOrderArgsFromSale']
    approvedOrders: Union[bool, 'FindManyBranchOrderArgsFromSale']
    sentOrders: Union[bool, 'FindManyBranchOrderArgsFromSale']
    receivedOrders: Union[bool, 'FindManyBranchOrderArgsFromSale']


class UserArgsFromSale(TypedDict, total=False):
    """Arguments for Sale"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromSale(TypedDict, total=False):
    """Arguments for Sale"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class UserPermissionIncludeFromSale(TypedDict, total=False):
    """Relational arguments for Sale"""
    user: Union[bool, 'UserArgsFromSale']


class UserPermissionArgsFromSale(TypedDict, total=False):
    """Arguments for Sale"""
    include: 'UserPermissionIncludeFromUserPermission'


class FindManyUserPermissionArgsFromSale(TypedDict, total=False):
    """Arguments for Sale"""
    take: int
    skip: int
    order_by: Union['UserPermissionOrderByInput', List['UserPermissionOrderByInput']]
    where: 'UserPermissionWhereInput'
    cursor: 'UserPermissionWhereUniqueInput'
    distinct: List['UserPermissionScalarFieldKeys']
    include: 'UserPermissionIncludeFromUserPermission'


class BranchIncludeFromSale(TypedDict, total=False):
    """Relational arguments for Sale"""
    users: Union[bool, 'FindManyUserArgsFromSale']
    Sale: Union[bool, 'FindManySaleArgsFromSale']
    Account: Union[bool, 'FindManyAccountArgsFromSale']
    BranchOrder: Union[bool, 'FindManyBranchOrderArgsFromSale']


class BranchArgsFromSale(TypedDict, total=False):
    """Arguments for Sale"""
    include: 'BranchIncludeFromBranch'


class FindManyBranchArgsFromSale(TypedDict, total=False):
    """Arguments for Sale"""
    take: int
    skip: int
    order_by: Union['BranchOrderByInput', List['BranchOrderByInput']]
    where: 'BranchWhereInput'
    cursor: 'BranchWhereUniqueInput'
    distinct: List['BranchScalarFieldKeys']
    include: 'BranchIncludeFromBranch'


class ProductIncludeFromSale(TypedDict, total=False):
    """Relational arguments for Sale"""
    category: Union[bool, 'CategoryArgsFromSale']
    stocks: Union[bool, 'FindManyStockArgsFromSale']
    stockAdjustments: Union[bool, 'FindManyStockAdjustmentArgsFromSale']


class ProductArgsFromSale(TypedDict, total=False):
    """Arguments for Sale"""
    include: 'ProductIncludeFromProduct'


class FindManyProductArgsFromSale(TypedDict, total=False):
    """Arguments for Sale"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProduct'


class CategoryIncludeFromSale(TypedDict, total=False):
    """Relational arguments for Sale"""
    products: Union[bool, 'FindManyProductArgsFromSale']


class CategoryArgsFromSale(TypedDict, total=False):
    """Arguments for Sale"""
    include: 'CategoryIncludeFromCategory'


class FindManyCategoryArgsFromSale(TypedDict, total=False):
    """Arguments for Sale"""
    take: int
    skip: int
    order_by: Union['CategoryOrderByInput', List['CategoryOrderByInput']]
    where: 'CategoryWhereInput'
    cursor: 'CategoryWhereUniqueInput'
    distinct: List['CategoryScalarFieldKeys']
    include: 'CategoryIncludeFromCategory'


class StockIncludeFromSale(TypedDict, total=False):
    """Relational arguments for Sale"""
    product: Union[bool, 'ProductArgsFromSale']
    SaleItem: Union[bool, 'FindManySaleItemArgsFromSale']
    BranchOrderItem: Union[bool, 'FindManyBranchOrderItemArgsFromSale']


class StockArgsFromSale(TypedDict, total=False):
    """Arguments for Sale"""
    include: 'StockIncludeFromStock'


class FindManyStockArgsFromSale(TypedDict, total=False):
    """Arguments for Sale"""
    take: int
    skip: int
    order_by: Union['StockOrderByInput', List['StockOrderByInput']]
    where: 'StockWhereInput'
    cursor: 'StockWhereUniqueInput'
    distinct: List['StockScalarFieldKeys']
    include: 'StockIncludeFromStock'


class CustomerIncludeFromSale(TypedDict, total=False):
    """Relational arguments for Sale"""
    Sale: Union[bool, 'FindManySaleArgsFromSale']


class CustomerArgsFromSale(TypedDict, total=False):
    """Arguments for Sale"""
    include: 'CustomerIncludeFromCustomer'


class FindManyCustomerArgsFromSale(TypedDict, total=False):
    """Arguments for Sale"""
    take: int
    skip: int
    order_by: Union['CustomerOrderByInput', List['CustomerOrderByInput']]
    where: 'CustomerWhereInput'
    cursor: 'CustomerWhereUniqueInput'
    distinct: List['CustomerScalarFieldKeys']
    include: 'CustomerIncludeFromCustomer'


class SaleIncludeFromSale(TypedDict, total=False):
    """Relational arguments for Sale"""
    branch: Union[bool, 'BranchArgsFromSale']
    customer: Union[bool, 'CustomerArgsFromSale']
    user: Union[bool, 'UserArgsFromSale']
    items: Union[bool, 'FindManySaleItemArgsFromSale']
    payments: Union[bool, 'FindManyPaymentArgsFromSale']
    returns: Union[bool, 'FindManyReturnSaleArgsFromSale']
    deletedBy: Union[bool, 'UserArgsFromSale']


class SaleArgsFromSale(TypedDict, total=False):
    """Arguments for Sale"""
    include: 'SaleIncludeFromSale'


class FindManySaleArgsFromSale(TypedDict, total=False):
    """Arguments for Sale"""
    take: int
    skip: int
    order_by: Union['SaleOrderByInput', List['SaleOrderByInput']]
    where: 'SaleWhereInput'
    cursor: 'SaleWhereUniqueInput'
    distinct: List['SaleScalarFieldKeys']
    include: 'SaleIncludeFromSale'


class SaleItemIncludeFromSale(TypedDict, total=False):
    """Relational arguments for Sale"""
    sale: Union[bool, 'SaleArgsFromSale']
    stock: Union[bool, 'StockArgsFromSale']
    ReturnItem: Union[bool, 'FindManyReturnItemArgsFromSale']


class SaleItemArgsFromSale(TypedDict, total=False):
    """Arguments for Sale"""
    include: 'SaleItemIncludeFromSaleItem'


class FindManySaleItemArgsFromSale(TypedDict, total=False):
    """Arguments for Sale"""
    take: int
    skip: int
    order_by: Union['SaleItemOrderByInput', List['SaleItemOrderByInput']]
    where: 'SaleItemWhereInput'
    cursor: 'SaleItemWhereUniqueInput'
    distinct: List['SaleItemScalarFieldKeys']
    include: 'SaleItemIncludeFromSaleItem'


class ReturnSaleIncludeFromSale(TypedDict, total=False):
    """Relational arguments for Sale"""
    original: Union[bool, 'SaleArgsFromSale']
    items: Union[bool, 'FindManyReturnItemArgsFromSale']
    refund: Union[bool, 'FindManyPaymentArgsFromSale']


class ReturnSaleArgsFromSale(TypedDict, total=False):
    """Arguments for Sale"""
    include: 'ReturnSaleIncludeFromReturnSale'


class FindManyReturnSaleArgsFromSale(TypedDict, total=False):
    """Arguments for Sale"""
    take: int
    skip: int
    order_by: Union['ReturnSaleOrderByInput', List['ReturnSaleOrderByInput']]
    where: 'ReturnSaleWhereInput'
    cursor: 'ReturnSaleWhereUniqueInput'
    distinct: List['ReturnSaleScalarFieldKeys']
    include: 'ReturnSaleIncludeFromReturnSale'


class ReturnItemIncludeFromSale(TypedDict, total=False):
    """Relational arguments for Sale"""
    returnSale: Union[bool, 'ReturnSaleArgsFromSale']
    saleItem: Union[bool, 'SaleItemArgsFromSale']


class ReturnItemArgsFromSale(TypedDict, total=False):
    """Arguments for Sale"""
    include: 'ReturnItemIncludeFromReturnItem'


class FindManyReturnItemArgsFromSale(TypedDict, total=False):
    """Arguments for Sale"""
    take: int
    skip: int
    order_by: Union['ReturnItemOrderByInput', List['ReturnItemOrderByInput']]
    where: 'ReturnItemWhereInput'
    cursor: 'ReturnItemWhereUniqueInput'
    distinct: List['ReturnItemScalarFieldKeys']
    include: 'ReturnItemIncludeFromReturnItem'


class PaymentIncludeFromSale(TypedDict, total=False):
    """Relational arguments for Sale"""
    sale: Union[bool, 'SaleArgsFromSale']
    account: Union[bool, 'AccountArgsFromSale']
    returnSale: Union[bool, 'ReturnSaleArgsFromSale']
    user: Union[bool, 'UserArgsFromSale']


class PaymentArgsFromSale(TypedDict, total=False):
    """Arguments for Sale"""
    include: 'PaymentIncludeFromPayment'


class FindManyPaymentArgsFromSale(TypedDict, total=False):
    """Arguments for Sale"""
    take: int
    skip: int
    order_by: Union['PaymentOrderByInput', List['PaymentOrderByInput']]
    where: 'PaymentWhereInput'
    cursor: 'PaymentWhereUniqueInput'
    distinct: List['PaymentScalarFieldKeys']
    include: 'PaymentIncludeFromPayment'


class JournalEntryIncludeFromSale(TypedDict, total=False):
    """Relational arguments for Sale"""
    lines: Union[bool, 'FindManyJournalEntryLineArgsFromSale']


class JournalEntryArgsFromSale(TypedDict, total=False):
    """Arguments for Sale"""
    include: 'JournalEntryIncludeFromJournalEntry'


class FindManyJournalEntryArgsFromSale(TypedDict, total=False):
    """Arguments for Sale"""
    take: int
    skip: int
    order_by: Union['JournalEntryOrderByInput', List['JournalEntryOrderByInput']]
    where: 'JournalEntryWhereInput'
    cursor: 'JournalEntryWhereUniqueInput'
    distinct: List['JournalEntryScalarFieldKeys']
    include: 'JournalEntryIncludeFromJournalEntry'


class JournalEntryLineIncludeFromSale(TypedDict, total=False):
    """Relational arguments for Sale"""
    entry: Union[bool, 'JournalEntryArgsFromSale']
    account: Union[bool, 'AccountArgsFromSale']


class JournalEntryLineArgsFromSale(TypedDict, total=False):
    """Arguments for Sale"""
    include: 'JournalEntryLineIncludeFromJournalEntryLine'


class FindManyJournalEntryLineArgsFromSale(TypedDict, total=False):
    """Arguments for Sale"""
    take: int
    skip: int
    order_by: Union['JournalEntryLineOrderByInput', List['JournalEntryLineOrderByInput']]
    where: 'JournalEntryLineWhereInput'
    cursor: 'JournalEntryLineWhereUniqueInput'
    distinct: List['JournalEntryLineScalarFieldKeys']
    include: 'JournalEntryLineIncludeFromJournalEntryLine'


class AccountIncludeFromSale(TypedDict, total=False):
    """Relational arguments for Sale"""
    branch: Union[bool, 'BranchArgsFromSale']
    entries: Union[bool, 'FindManyJournalEntryLineArgsFromSale']
    payments: Union[bool, 'FindManyPaymentArgsFromSale']
    outgoingTransfers: Union[bool, 'FindManyAccountTransferArgsFromSale']
    incomingTransfers: Union[bool, 'FindManyAccountTransferArgsFromSale']


class AccountArgsFromSale(TypedDict, total=False):
    """Arguments for Sale"""
    include: 'AccountIncludeFromAccount'


class FindManyAccountArgsFromSale(TypedDict, total=False):
    """Arguments for Sale"""
    take: int
    skip: int
    order_by: Union['AccountOrderByInput', List['AccountOrderByInput']]
    where: 'AccountWhereInput'
    cursor: 'AccountWhereUniqueInput'
    distinct: List['AccountScalarFieldKeys']
    include: 'AccountIncludeFromAccount'


class AccountTransferIncludeFromSale(TypedDict, total=False):
    """Relational arguments for Sale"""
    fromAccount: Union[bool, 'AccountArgsFromSale']
    toAccount: Union[bool, 'AccountArgsFromSale']


class AccountTransferArgsFromSale(TypedDict, total=False):
    """Arguments for Sale"""
    include: 'AccountTransferIncludeFromAccountTransfer'


class FindManyAccountTransferArgsFromSale(TypedDict, total=False):
    """Arguments for Sale"""
    take: int
    skip: int
    order_by: Union['AccountTransferOrderByInput', List['AccountTransferOrderByInput']]
    where: 'AccountTransferWhereInput'
    cursor: 'AccountTransferWhereUniqueInput'
    distinct: List['AccountTransferScalarFieldKeys']
    include: 'AccountTransferIncludeFromAccountTransfer'


class BranchOrderIncludeFromSale(TypedDict, total=False):
    """Relational arguments for Sale"""
    branch: Union[bool, 'BranchArgsFromSale']
    requestedBy: Union[bool, 'UserArgsFromSale']
    approvedBy: Union[bool, 'UserArgsFromSale']
    sentBy: Union[bool, 'UserArgsFromSale']
    receivedBy: Union[bool, 'UserArgsFromSale']
    items: Union[bool, 'FindManyBranchOrderItemArgsFromSale']


class BranchOrderArgsFromSale(TypedDict, total=False):
    """Arguments for Sale"""
    include: 'BranchOrderIncludeFromBranchOrder'


class FindManyBranchOrderArgsFromSale(TypedDict, total=False):
    """Arguments for Sale"""
    take: int
    skip: int
    order_by: Union['BranchOrderOrderByInput', List['BranchOrderOrderByInput']]
    where: 'BranchOrderWhereInput'
    cursor: 'BranchOrderWhereUniqueInput'
    distinct: List['BranchOrderScalarFieldKeys']
    include: 'BranchOrderIncludeFromBranchOrder'


class BranchOrderItemIncludeFromSale(TypedDict, total=False):
    """Relational arguments for Sale"""
    branchOrder: Union[bool, 'BranchOrderArgsFromSale']
    stock: Union[bool, 'StockArgsFromSale']


class BranchOrderItemArgsFromSale(TypedDict, total=False):
    """Arguments for Sale"""
    include: 'BranchOrderItemIncludeFromBranchOrderItem'


class FindManyBranchOrderItemArgsFromSale(TypedDict, total=False):
    """Arguments for Sale"""
    take: int
    skip: int
    order_by: Union['BranchOrderItemOrderByInput', List['BranchOrderItemOrderByInput']]
    where: 'BranchOrderItemWhereInput'
    cursor: 'BranchOrderItemWhereUniqueInput'
    distinct: List['BranchOrderItemScalarFieldKeys']
    include: 'BranchOrderItemIncludeFromBranchOrderItem'


class AuditLogIncludeFromSale(TypedDict, total=False):
    """Relational arguments for Sale"""
    user: Union[bool, 'UserArgsFromSale']


class AuditLogArgsFromSale(TypedDict, total=False):
    """Arguments for Sale"""
    include: 'AuditLogIncludeFromAuditLog'


class FindManyAuditLogArgsFromSale(TypedDict, total=False):
    """Arguments for Sale"""
    take: int
    skip: int
    order_by: Union['AuditLogOrderByInput', List['AuditLogOrderByInput']]
    where: 'AuditLogWhereInput'
    cursor: 'AuditLogWhereUniqueInput'
    distinct: List['AuditLogScalarFieldKeys']
    include: 'AuditLogIncludeFromAuditLog'


class SystemInfoIncludeFromSale(TypedDict, total=False):
    """Relational arguments for Sale"""


class SystemInfoArgsFromSale(TypedDict, total=False):
    """Arguments for Sale"""
    include: 'SystemInfoIncludeFromSystemInfo'


class FindManySystemInfoArgsFromSale(TypedDict, total=False):
    """Arguments for Sale"""
    take: int
    skip: int
    order_by: Union['SystemInfoOrderByInput', List['SystemInfoOrderByInput']]
    where: 'SystemInfoWhereInput'
    cursor: 'SystemInfoWhereUniqueInput'
    distinct: List['SystemInfoScalarFieldKeys']
    include: 'SystemInfoIncludeFromSystemInfo'


class BackupIncludeFromSale(TypedDict, total=False):
    """Relational arguments for Sale"""
    createdBy: Union[bool, 'UserArgsFromSale']


class BackupArgsFromSale(TypedDict, total=False):
    """Arguments for Sale"""
    include: 'BackupIncludeFromBackup'


class FindManyBackupArgsFromSale(TypedDict, total=False):
    """Arguments for Sale"""
    take: int
    skip: int
    order_by: Union['BackupOrderByInput', List['BackupOrderByInput']]
    where: 'BackupWhereInput'
    cursor: 'BackupWhereUniqueInput'
    distinct: List['BackupScalarFieldKeys']
    include: 'BackupIncludeFromBackup'


class RevokedTokenIncludeFromSale(TypedDict, total=False):
    """Relational arguments for Sale"""
    user: Union[bool, 'UserArgsFromSale']


class RevokedTokenArgsFromSale(TypedDict, total=False):
    """Arguments for Sale"""
    include: 'RevokedTokenIncludeFromRevokedToken'


class FindManyRevokedTokenArgsFromSale(TypedDict, total=False):
    """Arguments for Sale"""
    take: int
    skip: int
    order_by: Union['RevokedTokenOrderByInput', List['RevokedTokenOrderByInput']]
    where: 'RevokedTokenWhereInput'
    cursor: 'RevokedTokenWhereUniqueInput'
    distinct: List['RevokedTokenScalarFieldKeys']
    include: 'RevokedTokenIncludeFromRevokedToken'


class SystemSettingIncludeFromSale(TypedDict, total=False):
    """Relational arguments for Sale"""


class SystemSettingArgsFromSale(TypedDict, total=False):
    """Arguments for Sale"""
    include: 'SystemSettingIncludeFromSystemSetting'


class FindManySystemSettingArgsFromSale(TypedDict, total=False):
    """Arguments for Sale"""
    take: int
    skip: int
    order_by: Union['SystemSettingOrderByInput', List['SystemSettingOrderByInput']]
    where: 'SystemSettingWhereInput'
    cursor: 'SystemSettingWhereUniqueInput'
    distinct: List['SystemSettingScalarFieldKeys']
    include: 'SystemSettingIncludeFromSystemSetting'


class NotificationIncludeFromSale(TypedDict, total=False):
    """Relational arguments for Sale"""
    user: Union[bool, 'UserArgsFromSale']


class NotificationArgsFromSale(TypedDict, total=False):
    """Arguments for Sale"""
    include: 'NotificationIncludeFromNotification'


class FindManyNotificationArgsFromSale(TypedDict, total=False):
    """Arguments for Sale"""
    take: int
    skip: int
    order_by: Union['NotificationOrderByInput', List['NotificationOrderByInput']]
    where: 'NotificationWhereInput'
    cursor: 'NotificationWhereUniqueInput'
    distinct: List['NotificationScalarFieldKeys']
    include: 'NotificationIncludeFromNotification'


class StockAdjustmentIncludeFromSale(TypedDict, total=False):
    """Relational arguments for Sale"""
    product: Union[bool, 'ProductArgsFromSale']
    createdBy: Union[bool, 'UserArgsFromSale']


class StockAdjustmentArgsFromSale(TypedDict, total=False):
    """Arguments for Sale"""
    include: 'StockAdjustmentIncludeFromStockAdjustment'


class FindManyStockAdjustmentArgsFromSale(TypedDict, total=False):
    """Arguments for Sale"""
    take: int
    skip: int
    order_by: Union['StockAdjustmentOrderByInput', List['StockAdjustmentOrderByInput']]
    where: 'StockAdjustmentWhereInput'
    cursor: 'StockAdjustmentWhereUniqueInput'
    distinct: List['StockAdjustmentScalarFieldKeys']
    include: 'StockAdjustmentIncludeFromStockAdjustment'




FindManySaleArgs = FindManySaleArgsFromSale
FindFirstSaleArgs = FindManySaleArgsFromSale


class SaleWhereInput(TypedDict, total=False):
    """Sale arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    branchId: Union[_int, 'types.IntFilter']
    branch: 'BranchRelationFilter'
    totalAmount: Union[decimal.Decimal, 'types.DecimalFilter']
    discount: Union[decimal.Decimal, 'types.DecimalFilter']
    paymentType: 'enums.PaymentType'
    customerId: Union[None, _int, 'types.IntFilter']
    customer: 'CustomerRelationFilter'
    userId: Union[_int, 'types.IntFilter']
    user: 'UserRelationFilter'
    items: 'SaleItemListRelationFilter'
    payments: 'PaymentListRelationFilter'
    returns: 'ReturnSaleListRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    deletedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    deletedById: Union[None, _int, 'types.IntFilter']
    deletedBy: 'UserRelationFilter'

    # should be noted that AND and NOT should be Union['SaleWhereInput', List['SaleWhereInput']]
    # but this causes mypy to hang :/
    AND: List['SaleWhereInput']
    OR: List['SaleWhereInput']
    NOT: List['SaleWhereInput']



# aggregate Sale types


class SaleScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Sale arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    branchId: Union[_int, 'types.IntWithAggregatesFilter']
    totalAmount: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    discount: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    paymentType: 'enums.PaymentType'
    customerId: Union[_int, 'types.IntWithAggregatesFilter']
    userId: Union[_int, 'types.IntWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deletedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deletedById: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['SaleScalarWhereWithAggregatesInput']
    OR: List['SaleScalarWhereWithAggregatesInput']
    NOT: List['SaleScalarWhereWithAggregatesInput']



class SaleGroupByOutput(TypedDict, total=False):
    id: _int
    branchId: _int
    totalAmount: decimal.Decimal
    discount: decimal.Decimal
    paymentType: 'enums.PaymentType'
    customerId: _int
    userId: _int
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deletedAt: datetime.datetime
    deletedById: _int
    _sum: 'SaleSumAggregateOutput'
    _avg: 'SaleAvgAggregateOutput'
    _min: 'SaleMinAggregateOutput'
    _max: 'SaleMaxAggregateOutput'
    _count: 'SaleCountAggregateOutput'


class SaleAvgAggregateOutput(TypedDict, total=False):
    """Sale output for aggregating averages"""
    id: float
    branchId: float
    customerId: float
    userId: float
    deletedById: float


class SaleSumAggregateOutput(TypedDict, total=False):
    """Sale output for aggregating sums"""
    id: _int
    branchId: _int
    customerId: _int
    userId: _int
    deletedById: _int


class SaleScalarAggregateOutput(TypedDict, total=False):
    """Sale output including scalar fields"""
    id: _int
    branchId: _int
    totalAmount: decimal.Decimal
    discount: decimal.Decimal
    paymentType: 'enums.PaymentType'
    customerId: _int
    userId: _int
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deletedAt: datetime.datetime
    deletedById: _int


SaleMinAggregateOutput = SaleScalarAggregateOutput
SaleMaxAggregateOutput = SaleScalarAggregateOutput


class SaleMaxAggregateInput(TypedDict, total=False):
    """Sale input for aggregating by max"""
    id: bool
    branchId: bool
    totalAmount: bool
    discount: bool
    paymentType: bool
    customerId: bool
    userId: bool
    createdAt: bool
    updatedAt: bool
    deletedAt: bool
    deletedById: bool


class SaleMinAggregateInput(TypedDict, total=False):
    """Sale input for aggregating by min"""
    id: bool
    branchId: bool
    totalAmount: bool
    discount: bool
    paymentType: bool
    customerId: bool
    userId: bool
    createdAt: bool
    updatedAt: bool
    deletedAt: bool
    deletedById: bool


class SaleNumberAggregateInput(TypedDict, total=False):
    """Sale input for aggregating numbers"""
    id: bool
    branchId: bool
    customerId: bool
    userId: bool
    deletedById: bool


SaleAvgAggregateInput = SaleNumberAggregateInput
SaleSumAggregateInput = SaleNumberAggregateInput


SaleCountAggregateInput = TypedDict(
    'SaleCountAggregateInput',
    {
        'id': bool,
        'branchId': bool,
        'totalAmount': bool,
        'discount': bool,
        'paymentType': bool,
        'customerId': bool,
        'userId': bool,
        'createdAt': bool,
        'updatedAt': bool,
        'deletedAt': bool,
        'deletedById': bool,
        '_all': bool,
    },
    total=False,
)

SaleCountAggregateOutput = TypedDict(
    'SaleCountAggregateOutput',
    {
        'id': int,
        'branchId': int,
        'totalAmount': int,
        'discount': int,
        'paymentType': int,
        'customerId': int,
        'userId': int,
        'createdAt': int,
        'updatedAt': int,
        'deletedAt': int,
        'deletedById': int,
        '_all': int,
    },
    total=False,
)


SaleKeys = Literal[
    'id',
    'branchId',
    'branch',
    'totalAmount',
    'discount',
    'paymentType',
    'customerId',
    'customer',
    'userId',
    'user',
    'items',
    'payments',
    'returns',
    'createdAt',
    'updatedAt',
    'deletedAt',
    'deletedById',
    'deletedBy',
]
SaleScalarFieldKeys = Literal[
    'id',
    'branchId',
    'totalAmount',
    'discount',
    'paymentType',
    'customerId',
    'userId',
    'createdAt',
    'updatedAt',
    'deletedAt',
    'deletedById',
]
SaleScalarFieldKeysT = TypeVar('SaleScalarFieldKeysT', bound=SaleScalarFieldKeys)

SaleRelationalFieldKeys = Literal[
        'branch',
        'customer',
        'user',
        'items',
        'payments',
        'returns',
        'deletedBy',
    ]

# SaleItem types

class SaleItemOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the SaleItem create method"""
    id: _int
    saleId: _int
    sale: 'SaleCreateNestedWithoutRelationsInput'
    stockId: _int
    stock: 'StockCreateNestedWithoutRelationsInput'
    ReturnItem: 'ReturnItemCreateManyNestedWithoutRelationsInput'


class SaleItemCreateInput(SaleItemOptionalCreateInput):
    """Required arguments to the SaleItem create method"""
    quantity: _int
    price: decimal.Decimal
    subtotal: decimal.Decimal


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class SaleItemOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the SaleItem create method, without relations"""
    id: _int
    saleId: _int
    stockId: _int


class SaleItemCreateWithoutRelationsInput(SaleItemOptionalCreateWithoutRelationsInput):
    """Required arguments to the SaleItem create method, without relations"""
    quantity: _int
    price: decimal.Decimal
    subtotal: decimal.Decimal


class SaleItemCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'SaleItemCreateWithoutRelationsInput'
    connect: 'SaleItemWhereUniqueInput'


class SaleItemCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['SaleItemCreateWithoutRelationsInput', List['SaleItemCreateWithoutRelationsInput']]
    connect: Union['SaleItemWhereUniqueInput', List['SaleItemWhereUniqueInput']]


_SaleItemWhereUnique_id_Input = TypedDict(
    '_SaleItemWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

SaleItemWhereUniqueInput = _SaleItemWhereUnique_id_Input


class SaleItemUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    sale: 'SaleUpdateOneWithoutRelationsInput'
    stock: 'StockUpdateOneWithoutRelationsInput'
    quantity: Union[AtomicIntInput, _int]
    price: decimal.Decimal
    subtotal: decimal.Decimal
    ReturnItem: 'ReturnItemUpdateManyWithoutRelationsInput'


class SaleItemUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    quantity: Union[AtomicIntInput, _int]
    price: decimal.Decimal
    subtotal: decimal.Decimal


class SaleItemUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['SaleItemCreateWithoutRelationsInput']
    connect: List['SaleItemWhereUniqueInput']
    set: List['SaleItemWhereUniqueInput']
    disconnect: List['SaleItemWhereUniqueInput']
    delete: List['SaleItemWhereUniqueInput']

    # TODO
    # update: List['SaleItemUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['SaleItemUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['SaleItemScalarWhereInput']
    # upsert: List['SaleItemUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['SaleItemCreateOrConnectWithoutRelationsInput']


class SaleItemUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'SaleItemCreateWithoutRelationsInput'
    connect: 'SaleItemWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'SaleItemUpdateInput'
    # upsert: 'SaleItemUpsertWithoutRelationsInput'
    # connectOrCreate: 'SaleItemCreateOrConnectWithoutRelationsInput'


class SaleItemUpsertInput(TypedDict):
    create: 'SaleItemCreateInput'
    update: 'SaleItemUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_SaleItem_id_OrderByInput = TypedDict(
    '_SaleItem_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_SaleItem_saleId_OrderByInput = TypedDict(
    '_SaleItem_saleId_OrderByInput',
    {
        'saleId': 'SortOrder',
    },
    total=True
)

_SaleItem_stockId_OrderByInput = TypedDict(
    '_SaleItem_stockId_OrderByInput',
    {
        'stockId': 'SortOrder',
    },
    total=True
)

_SaleItem_quantity_OrderByInput = TypedDict(
    '_SaleItem_quantity_OrderByInput',
    {
        'quantity': 'SortOrder',
    },
    total=True
)

_SaleItem_price_OrderByInput = TypedDict(
    '_SaleItem_price_OrderByInput',
    {
        'price': 'SortOrder',
    },
    total=True
)

_SaleItem_subtotal_OrderByInput = TypedDict(
    '_SaleItem_subtotal_OrderByInput',
    {
        'subtotal': 'SortOrder',
    },
    total=True
)

SaleItemOrderByInput = Union[
    '_SaleItem_id_OrderByInput',
    '_SaleItem_saleId_OrderByInput',
    '_SaleItem_stockId_OrderByInput',
    '_SaleItem_quantity_OrderByInput',
    '_SaleItem_price_OrderByInput',
    '_SaleItem_subtotal_OrderByInput',
]



# recursive SaleItem types
# TODO: cleanup these types



SaleItemRelationFilter = TypedDict(
    'SaleItemRelationFilter',
    {
        'is': 'SaleItemWhereInput',
        'is_not': 'SaleItemWhereInput',
    },
    total=False,
)


class SaleItemListRelationFilter(TypedDict, total=False):
    some: 'SaleItemWhereInput'
    none: 'SaleItemWhereInput'
    every: 'SaleItemWhereInput'


class SaleItemInclude(TypedDict, total=False):
    """SaleItem relational arguments"""
    sale: Union[bool, 'SaleArgsFromSaleItem']
    stock: Union[bool, 'StockArgsFromSaleItem']
    ReturnItem: Union[bool, 'FindManyReturnItemArgsFromSaleItem']


class UserIncludeFromSaleItem(TypedDict, total=False):
    """Relational arguments for SaleItem"""
    branch: Union[bool, 'BranchArgsFromSaleItem']
    auditLogs: Union[bool, 'FindManyAuditLogArgsFromSaleItem']
    permissions: Union[bool, 'FindManyUserPermissionArgsFromSaleItem']
    notifications: Union[bool, 'FindManyNotificationArgsFromSaleItem']
    revokedTokens: Union[bool, 'FindManyRevokedTokenArgsFromSaleItem']
    stockAdjustments: Union[bool, 'FindManyStockAdjustmentArgsFromSaleItem']
    Sale: Union[bool, 'FindManySaleArgsFromSaleItem']
    deletedSales: Union[bool, 'FindManySaleArgsFromSaleItem']
    Payment: Union[bool, 'FindManyPaymentArgsFromSaleItem']
    Backup: Union[bool, 'FindManyBackupArgsFromSaleItem']
    requestedOrders: Union[bool, 'FindManyBranchOrderArgsFromSaleItem']
    approvedOrders: Union[bool, 'FindManyBranchOrderArgsFromSaleItem']
    sentOrders: Union[bool, 'FindManyBranchOrderArgsFromSaleItem']
    receivedOrders: Union[bool, 'FindManyBranchOrderArgsFromSaleItem']


class UserArgsFromSaleItem(TypedDict, total=False):
    """Arguments for SaleItem"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromSaleItem(TypedDict, total=False):
    """Arguments for SaleItem"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class UserPermissionIncludeFromSaleItem(TypedDict, total=False):
    """Relational arguments for SaleItem"""
    user: Union[bool, 'UserArgsFromSaleItem']


class UserPermissionArgsFromSaleItem(TypedDict, total=False):
    """Arguments for SaleItem"""
    include: 'UserPermissionIncludeFromUserPermission'


class FindManyUserPermissionArgsFromSaleItem(TypedDict, total=False):
    """Arguments for SaleItem"""
    take: int
    skip: int
    order_by: Union['UserPermissionOrderByInput', List['UserPermissionOrderByInput']]
    where: 'UserPermissionWhereInput'
    cursor: 'UserPermissionWhereUniqueInput'
    distinct: List['UserPermissionScalarFieldKeys']
    include: 'UserPermissionIncludeFromUserPermission'


class BranchIncludeFromSaleItem(TypedDict, total=False):
    """Relational arguments for SaleItem"""
    users: Union[bool, 'FindManyUserArgsFromSaleItem']
    Sale: Union[bool, 'FindManySaleArgsFromSaleItem']
    Account: Union[bool, 'FindManyAccountArgsFromSaleItem']
    BranchOrder: Union[bool, 'FindManyBranchOrderArgsFromSaleItem']


class BranchArgsFromSaleItem(TypedDict, total=False):
    """Arguments for SaleItem"""
    include: 'BranchIncludeFromBranch'


class FindManyBranchArgsFromSaleItem(TypedDict, total=False):
    """Arguments for SaleItem"""
    take: int
    skip: int
    order_by: Union['BranchOrderByInput', List['BranchOrderByInput']]
    where: 'BranchWhereInput'
    cursor: 'BranchWhereUniqueInput'
    distinct: List['BranchScalarFieldKeys']
    include: 'BranchIncludeFromBranch'


class ProductIncludeFromSaleItem(TypedDict, total=False):
    """Relational arguments for SaleItem"""
    category: Union[bool, 'CategoryArgsFromSaleItem']
    stocks: Union[bool, 'FindManyStockArgsFromSaleItem']
    stockAdjustments: Union[bool, 'FindManyStockAdjustmentArgsFromSaleItem']


class ProductArgsFromSaleItem(TypedDict, total=False):
    """Arguments for SaleItem"""
    include: 'ProductIncludeFromProduct'


class FindManyProductArgsFromSaleItem(TypedDict, total=False):
    """Arguments for SaleItem"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProduct'


class CategoryIncludeFromSaleItem(TypedDict, total=False):
    """Relational arguments for SaleItem"""
    products: Union[bool, 'FindManyProductArgsFromSaleItem']


class CategoryArgsFromSaleItem(TypedDict, total=False):
    """Arguments for SaleItem"""
    include: 'CategoryIncludeFromCategory'


class FindManyCategoryArgsFromSaleItem(TypedDict, total=False):
    """Arguments for SaleItem"""
    take: int
    skip: int
    order_by: Union['CategoryOrderByInput', List['CategoryOrderByInput']]
    where: 'CategoryWhereInput'
    cursor: 'CategoryWhereUniqueInput'
    distinct: List['CategoryScalarFieldKeys']
    include: 'CategoryIncludeFromCategory'


class StockIncludeFromSaleItem(TypedDict, total=False):
    """Relational arguments for SaleItem"""
    product: Union[bool, 'ProductArgsFromSaleItem']
    SaleItem: Union[bool, 'FindManySaleItemArgsFromSaleItem']
    BranchOrderItem: Union[bool, 'FindManyBranchOrderItemArgsFromSaleItem']


class StockArgsFromSaleItem(TypedDict, total=False):
    """Arguments for SaleItem"""
    include: 'StockIncludeFromStock'


class FindManyStockArgsFromSaleItem(TypedDict, total=False):
    """Arguments for SaleItem"""
    take: int
    skip: int
    order_by: Union['StockOrderByInput', List['StockOrderByInput']]
    where: 'StockWhereInput'
    cursor: 'StockWhereUniqueInput'
    distinct: List['StockScalarFieldKeys']
    include: 'StockIncludeFromStock'


class CustomerIncludeFromSaleItem(TypedDict, total=False):
    """Relational arguments for SaleItem"""
    Sale: Union[bool, 'FindManySaleArgsFromSaleItem']


class CustomerArgsFromSaleItem(TypedDict, total=False):
    """Arguments for SaleItem"""
    include: 'CustomerIncludeFromCustomer'


class FindManyCustomerArgsFromSaleItem(TypedDict, total=False):
    """Arguments for SaleItem"""
    take: int
    skip: int
    order_by: Union['CustomerOrderByInput', List['CustomerOrderByInput']]
    where: 'CustomerWhereInput'
    cursor: 'CustomerWhereUniqueInput'
    distinct: List['CustomerScalarFieldKeys']
    include: 'CustomerIncludeFromCustomer'


class SaleIncludeFromSaleItem(TypedDict, total=False):
    """Relational arguments for SaleItem"""
    branch: Union[bool, 'BranchArgsFromSaleItem']
    customer: Union[bool, 'CustomerArgsFromSaleItem']
    user: Union[bool, 'UserArgsFromSaleItem']
    items: Union[bool, 'FindManySaleItemArgsFromSaleItem']
    payments: Union[bool, 'FindManyPaymentArgsFromSaleItem']
    returns: Union[bool, 'FindManyReturnSaleArgsFromSaleItem']
    deletedBy: Union[bool, 'UserArgsFromSaleItem']


class SaleArgsFromSaleItem(TypedDict, total=False):
    """Arguments for SaleItem"""
    include: 'SaleIncludeFromSale'


class FindManySaleArgsFromSaleItem(TypedDict, total=False):
    """Arguments for SaleItem"""
    take: int
    skip: int
    order_by: Union['SaleOrderByInput', List['SaleOrderByInput']]
    where: 'SaleWhereInput'
    cursor: 'SaleWhereUniqueInput'
    distinct: List['SaleScalarFieldKeys']
    include: 'SaleIncludeFromSale'


class SaleItemIncludeFromSaleItem(TypedDict, total=False):
    """Relational arguments for SaleItem"""
    sale: Union[bool, 'SaleArgsFromSaleItem']
    stock: Union[bool, 'StockArgsFromSaleItem']
    ReturnItem: Union[bool, 'FindManyReturnItemArgsFromSaleItem']


class SaleItemArgsFromSaleItem(TypedDict, total=False):
    """Arguments for SaleItem"""
    include: 'SaleItemIncludeFromSaleItem'


class FindManySaleItemArgsFromSaleItem(TypedDict, total=False):
    """Arguments for SaleItem"""
    take: int
    skip: int
    order_by: Union['SaleItemOrderByInput', List['SaleItemOrderByInput']]
    where: 'SaleItemWhereInput'
    cursor: 'SaleItemWhereUniqueInput'
    distinct: List['SaleItemScalarFieldKeys']
    include: 'SaleItemIncludeFromSaleItem'


class ReturnSaleIncludeFromSaleItem(TypedDict, total=False):
    """Relational arguments for SaleItem"""
    original: Union[bool, 'SaleArgsFromSaleItem']
    items: Union[bool, 'FindManyReturnItemArgsFromSaleItem']
    refund: Union[bool, 'FindManyPaymentArgsFromSaleItem']


class ReturnSaleArgsFromSaleItem(TypedDict, total=False):
    """Arguments for SaleItem"""
    include: 'ReturnSaleIncludeFromReturnSale'


class FindManyReturnSaleArgsFromSaleItem(TypedDict, total=False):
    """Arguments for SaleItem"""
    take: int
    skip: int
    order_by: Union['ReturnSaleOrderByInput', List['ReturnSaleOrderByInput']]
    where: 'ReturnSaleWhereInput'
    cursor: 'ReturnSaleWhereUniqueInput'
    distinct: List['ReturnSaleScalarFieldKeys']
    include: 'ReturnSaleIncludeFromReturnSale'


class ReturnItemIncludeFromSaleItem(TypedDict, total=False):
    """Relational arguments for SaleItem"""
    returnSale: Union[bool, 'ReturnSaleArgsFromSaleItem']
    saleItem: Union[bool, 'SaleItemArgsFromSaleItem']


class ReturnItemArgsFromSaleItem(TypedDict, total=False):
    """Arguments for SaleItem"""
    include: 'ReturnItemIncludeFromReturnItem'


class FindManyReturnItemArgsFromSaleItem(TypedDict, total=False):
    """Arguments for SaleItem"""
    take: int
    skip: int
    order_by: Union['ReturnItemOrderByInput', List['ReturnItemOrderByInput']]
    where: 'ReturnItemWhereInput'
    cursor: 'ReturnItemWhereUniqueInput'
    distinct: List['ReturnItemScalarFieldKeys']
    include: 'ReturnItemIncludeFromReturnItem'


class PaymentIncludeFromSaleItem(TypedDict, total=False):
    """Relational arguments for SaleItem"""
    sale: Union[bool, 'SaleArgsFromSaleItem']
    account: Union[bool, 'AccountArgsFromSaleItem']
    returnSale: Union[bool, 'ReturnSaleArgsFromSaleItem']
    user: Union[bool, 'UserArgsFromSaleItem']


class PaymentArgsFromSaleItem(TypedDict, total=False):
    """Arguments for SaleItem"""
    include: 'PaymentIncludeFromPayment'


class FindManyPaymentArgsFromSaleItem(TypedDict, total=False):
    """Arguments for SaleItem"""
    take: int
    skip: int
    order_by: Union['PaymentOrderByInput', List['PaymentOrderByInput']]
    where: 'PaymentWhereInput'
    cursor: 'PaymentWhereUniqueInput'
    distinct: List['PaymentScalarFieldKeys']
    include: 'PaymentIncludeFromPayment'


class JournalEntryIncludeFromSaleItem(TypedDict, total=False):
    """Relational arguments for SaleItem"""
    lines: Union[bool, 'FindManyJournalEntryLineArgsFromSaleItem']


class JournalEntryArgsFromSaleItem(TypedDict, total=False):
    """Arguments for SaleItem"""
    include: 'JournalEntryIncludeFromJournalEntry'


class FindManyJournalEntryArgsFromSaleItem(TypedDict, total=False):
    """Arguments for SaleItem"""
    take: int
    skip: int
    order_by: Union['JournalEntryOrderByInput', List['JournalEntryOrderByInput']]
    where: 'JournalEntryWhereInput'
    cursor: 'JournalEntryWhereUniqueInput'
    distinct: List['JournalEntryScalarFieldKeys']
    include: 'JournalEntryIncludeFromJournalEntry'


class JournalEntryLineIncludeFromSaleItem(TypedDict, total=False):
    """Relational arguments for SaleItem"""
    entry: Union[bool, 'JournalEntryArgsFromSaleItem']
    account: Union[bool, 'AccountArgsFromSaleItem']


class JournalEntryLineArgsFromSaleItem(TypedDict, total=False):
    """Arguments for SaleItem"""
    include: 'JournalEntryLineIncludeFromJournalEntryLine'


class FindManyJournalEntryLineArgsFromSaleItem(TypedDict, total=False):
    """Arguments for SaleItem"""
    take: int
    skip: int
    order_by: Union['JournalEntryLineOrderByInput', List['JournalEntryLineOrderByInput']]
    where: 'JournalEntryLineWhereInput'
    cursor: 'JournalEntryLineWhereUniqueInput'
    distinct: List['JournalEntryLineScalarFieldKeys']
    include: 'JournalEntryLineIncludeFromJournalEntryLine'


class AccountIncludeFromSaleItem(TypedDict, total=False):
    """Relational arguments for SaleItem"""
    branch: Union[bool, 'BranchArgsFromSaleItem']
    entries: Union[bool, 'FindManyJournalEntryLineArgsFromSaleItem']
    payments: Union[bool, 'FindManyPaymentArgsFromSaleItem']
    outgoingTransfers: Union[bool, 'FindManyAccountTransferArgsFromSaleItem']
    incomingTransfers: Union[bool, 'FindManyAccountTransferArgsFromSaleItem']


class AccountArgsFromSaleItem(TypedDict, total=False):
    """Arguments for SaleItem"""
    include: 'AccountIncludeFromAccount'


class FindManyAccountArgsFromSaleItem(TypedDict, total=False):
    """Arguments for SaleItem"""
    take: int
    skip: int
    order_by: Union['AccountOrderByInput', List['AccountOrderByInput']]
    where: 'AccountWhereInput'
    cursor: 'AccountWhereUniqueInput'
    distinct: List['AccountScalarFieldKeys']
    include: 'AccountIncludeFromAccount'


class AccountTransferIncludeFromSaleItem(TypedDict, total=False):
    """Relational arguments for SaleItem"""
    fromAccount: Union[bool, 'AccountArgsFromSaleItem']
    toAccount: Union[bool, 'AccountArgsFromSaleItem']


class AccountTransferArgsFromSaleItem(TypedDict, total=False):
    """Arguments for SaleItem"""
    include: 'AccountTransferIncludeFromAccountTransfer'


class FindManyAccountTransferArgsFromSaleItem(TypedDict, total=False):
    """Arguments for SaleItem"""
    take: int
    skip: int
    order_by: Union['AccountTransferOrderByInput', List['AccountTransferOrderByInput']]
    where: 'AccountTransferWhereInput'
    cursor: 'AccountTransferWhereUniqueInput'
    distinct: List['AccountTransferScalarFieldKeys']
    include: 'AccountTransferIncludeFromAccountTransfer'


class BranchOrderIncludeFromSaleItem(TypedDict, total=False):
    """Relational arguments for SaleItem"""
    branch: Union[bool, 'BranchArgsFromSaleItem']
    requestedBy: Union[bool, 'UserArgsFromSaleItem']
    approvedBy: Union[bool, 'UserArgsFromSaleItem']
    sentBy: Union[bool, 'UserArgsFromSaleItem']
    receivedBy: Union[bool, 'UserArgsFromSaleItem']
    items: Union[bool, 'FindManyBranchOrderItemArgsFromSaleItem']


class BranchOrderArgsFromSaleItem(TypedDict, total=False):
    """Arguments for SaleItem"""
    include: 'BranchOrderIncludeFromBranchOrder'


class FindManyBranchOrderArgsFromSaleItem(TypedDict, total=False):
    """Arguments for SaleItem"""
    take: int
    skip: int
    order_by: Union['BranchOrderOrderByInput', List['BranchOrderOrderByInput']]
    where: 'BranchOrderWhereInput'
    cursor: 'BranchOrderWhereUniqueInput'
    distinct: List['BranchOrderScalarFieldKeys']
    include: 'BranchOrderIncludeFromBranchOrder'


class BranchOrderItemIncludeFromSaleItem(TypedDict, total=False):
    """Relational arguments for SaleItem"""
    branchOrder: Union[bool, 'BranchOrderArgsFromSaleItem']
    stock: Union[bool, 'StockArgsFromSaleItem']


class BranchOrderItemArgsFromSaleItem(TypedDict, total=False):
    """Arguments for SaleItem"""
    include: 'BranchOrderItemIncludeFromBranchOrderItem'


class FindManyBranchOrderItemArgsFromSaleItem(TypedDict, total=False):
    """Arguments for SaleItem"""
    take: int
    skip: int
    order_by: Union['BranchOrderItemOrderByInput', List['BranchOrderItemOrderByInput']]
    where: 'BranchOrderItemWhereInput'
    cursor: 'BranchOrderItemWhereUniqueInput'
    distinct: List['BranchOrderItemScalarFieldKeys']
    include: 'BranchOrderItemIncludeFromBranchOrderItem'


class AuditLogIncludeFromSaleItem(TypedDict, total=False):
    """Relational arguments for SaleItem"""
    user: Union[bool, 'UserArgsFromSaleItem']


class AuditLogArgsFromSaleItem(TypedDict, total=False):
    """Arguments for SaleItem"""
    include: 'AuditLogIncludeFromAuditLog'


class FindManyAuditLogArgsFromSaleItem(TypedDict, total=False):
    """Arguments for SaleItem"""
    take: int
    skip: int
    order_by: Union['AuditLogOrderByInput', List['AuditLogOrderByInput']]
    where: 'AuditLogWhereInput'
    cursor: 'AuditLogWhereUniqueInput'
    distinct: List['AuditLogScalarFieldKeys']
    include: 'AuditLogIncludeFromAuditLog'


class SystemInfoIncludeFromSaleItem(TypedDict, total=False):
    """Relational arguments for SaleItem"""


class SystemInfoArgsFromSaleItem(TypedDict, total=False):
    """Arguments for SaleItem"""
    include: 'SystemInfoIncludeFromSystemInfo'


class FindManySystemInfoArgsFromSaleItem(TypedDict, total=False):
    """Arguments for SaleItem"""
    take: int
    skip: int
    order_by: Union['SystemInfoOrderByInput', List['SystemInfoOrderByInput']]
    where: 'SystemInfoWhereInput'
    cursor: 'SystemInfoWhereUniqueInput'
    distinct: List['SystemInfoScalarFieldKeys']
    include: 'SystemInfoIncludeFromSystemInfo'


class BackupIncludeFromSaleItem(TypedDict, total=False):
    """Relational arguments for SaleItem"""
    createdBy: Union[bool, 'UserArgsFromSaleItem']


class BackupArgsFromSaleItem(TypedDict, total=False):
    """Arguments for SaleItem"""
    include: 'BackupIncludeFromBackup'


class FindManyBackupArgsFromSaleItem(TypedDict, total=False):
    """Arguments for SaleItem"""
    take: int
    skip: int
    order_by: Union['BackupOrderByInput', List['BackupOrderByInput']]
    where: 'BackupWhereInput'
    cursor: 'BackupWhereUniqueInput'
    distinct: List['BackupScalarFieldKeys']
    include: 'BackupIncludeFromBackup'


class RevokedTokenIncludeFromSaleItem(TypedDict, total=False):
    """Relational arguments for SaleItem"""
    user: Union[bool, 'UserArgsFromSaleItem']


class RevokedTokenArgsFromSaleItem(TypedDict, total=False):
    """Arguments for SaleItem"""
    include: 'RevokedTokenIncludeFromRevokedToken'


class FindManyRevokedTokenArgsFromSaleItem(TypedDict, total=False):
    """Arguments for SaleItem"""
    take: int
    skip: int
    order_by: Union['RevokedTokenOrderByInput', List['RevokedTokenOrderByInput']]
    where: 'RevokedTokenWhereInput'
    cursor: 'RevokedTokenWhereUniqueInput'
    distinct: List['RevokedTokenScalarFieldKeys']
    include: 'RevokedTokenIncludeFromRevokedToken'


class SystemSettingIncludeFromSaleItem(TypedDict, total=False):
    """Relational arguments for SaleItem"""


class SystemSettingArgsFromSaleItem(TypedDict, total=False):
    """Arguments for SaleItem"""
    include: 'SystemSettingIncludeFromSystemSetting'


class FindManySystemSettingArgsFromSaleItem(TypedDict, total=False):
    """Arguments for SaleItem"""
    take: int
    skip: int
    order_by: Union['SystemSettingOrderByInput', List['SystemSettingOrderByInput']]
    where: 'SystemSettingWhereInput'
    cursor: 'SystemSettingWhereUniqueInput'
    distinct: List['SystemSettingScalarFieldKeys']
    include: 'SystemSettingIncludeFromSystemSetting'


class NotificationIncludeFromSaleItem(TypedDict, total=False):
    """Relational arguments for SaleItem"""
    user: Union[bool, 'UserArgsFromSaleItem']


class NotificationArgsFromSaleItem(TypedDict, total=False):
    """Arguments for SaleItem"""
    include: 'NotificationIncludeFromNotification'


class FindManyNotificationArgsFromSaleItem(TypedDict, total=False):
    """Arguments for SaleItem"""
    take: int
    skip: int
    order_by: Union['NotificationOrderByInput', List['NotificationOrderByInput']]
    where: 'NotificationWhereInput'
    cursor: 'NotificationWhereUniqueInput'
    distinct: List['NotificationScalarFieldKeys']
    include: 'NotificationIncludeFromNotification'


class StockAdjustmentIncludeFromSaleItem(TypedDict, total=False):
    """Relational arguments for SaleItem"""
    product: Union[bool, 'ProductArgsFromSaleItem']
    createdBy: Union[bool, 'UserArgsFromSaleItem']


class StockAdjustmentArgsFromSaleItem(TypedDict, total=False):
    """Arguments for SaleItem"""
    include: 'StockAdjustmentIncludeFromStockAdjustment'


class FindManyStockAdjustmentArgsFromSaleItem(TypedDict, total=False):
    """Arguments for SaleItem"""
    take: int
    skip: int
    order_by: Union['StockAdjustmentOrderByInput', List['StockAdjustmentOrderByInput']]
    where: 'StockAdjustmentWhereInput'
    cursor: 'StockAdjustmentWhereUniqueInput'
    distinct: List['StockAdjustmentScalarFieldKeys']
    include: 'StockAdjustmentIncludeFromStockAdjustment'




FindManySaleItemArgs = FindManySaleItemArgsFromSaleItem
FindFirstSaleItemArgs = FindManySaleItemArgsFromSaleItem


class SaleItemWhereInput(TypedDict, total=False):
    """SaleItem arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    saleId: Union[_int, 'types.IntFilter']
    sale: 'SaleRelationFilter'
    stockId: Union[_int, 'types.IntFilter']
    stock: 'StockRelationFilter'
    quantity: Union[_int, 'types.IntFilter']
    price: Union[decimal.Decimal, 'types.DecimalFilter']
    subtotal: Union[decimal.Decimal, 'types.DecimalFilter']
    ReturnItem: 'ReturnItemListRelationFilter'

    # should be noted that AND and NOT should be Union['SaleItemWhereInput', List['SaleItemWhereInput']]
    # but this causes mypy to hang :/
    AND: List['SaleItemWhereInput']
    OR: List['SaleItemWhereInput']
    NOT: List['SaleItemWhereInput']



# aggregate SaleItem types


class SaleItemScalarWhereWithAggregatesInput(TypedDict, total=False):
    """SaleItem arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    saleId: Union[_int, 'types.IntWithAggregatesFilter']
    stockId: Union[_int, 'types.IntWithAggregatesFilter']
    quantity: Union[_int, 'types.IntWithAggregatesFilter']
    price: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    subtotal: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']

    AND: List['SaleItemScalarWhereWithAggregatesInput']
    OR: List['SaleItemScalarWhereWithAggregatesInput']
    NOT: List['SaleItemScalarWhereWithAggregatesInput']



class SaleItemGroupByOutput(TypedDict, total=False):
    id: _int
    saleId: _int
    stockId: _int
    quantity: _int
    price: decimal.Decimal
    subtotal: decimal.Decimal
    _sum: 'SaleItemSumAggregateOutput'
    _avg: 'SaleItemAvgAggregateOutput'
    _min: 'SaleItemMinAggregateOutput'
    _max: 'SaleItemMaxAggregateOutput'
    _count: 'SaleItemCountAggregateOutput'


class SaleItemAvgAggregateOutput(TypedDict, total=False):
    """SaleItem output for aggregating averages"""
    id: float
    saleId: float
    stockId: float
    quantity: float


class SaleItemSumAggregateOutput(TypedDict, total=False):
    """SaleItem output for aggregating sums"""
    id: _int
    saleId: _int
    stockId: _int
    quantity: _int


class SaleItemScalarAggregateOutput(TypedDict, total=False):
    """SaleItem output including scalar fields"""
    id: _int
    saleId: _int
    stockId: _int
    quantity: _int
    price: decimal.Decimal
    subtotal: decimal.Decimal


SaleItemMinAggregateOutput = SaleItemScalarAggregateOutput
SaleItemMaxAggregateOutput = SaleItemScalarAggregateOutput


class SaleItemMaxAggregateInput(TypedDict, total=False):
    """SaleItem input for aggregating by max"""
    id: bool
    saleId: bool
    stockId: bool
    quantity: bool
    price: bool
    subtotal: bool


class SaleItemMinAggregateInput(TypedDict, total=False):
    """SaleItem input for aggregating by min"""
    id: bool
    saleId: bool
    stockId: bool
    quantity: bool
    price: bool
    subtotal: bool


class SaleItemNumberAggregateInput(TypedDict, total=False):
    """SaleItem input for aggregating numbers"""
    id: bool
    saleId: bool
    stockId: bool
    quantity: bool


SaleItemAvgAggregateInput = SaleItemNumberAggregateInput
SaleItemSumAggregateInput = SaleItemNumberAggregateInput


SaleItemCountAggregateInput = TypedDict(
    'SaleItemCountAggregateInput',
    {
        'id': bool,
        'saleId': bool,
        'stockId': bool,
        'quantity': bool,
        'price': bool,
        'subtotal': bool,
        '_all': bool,
    },
    total=False,
)

SaleItemCountAggregateOutput = TypedDict(
    'SaleItemCountAggregateOutput',
    {
        'id': int,
        'saleId': int,
        'stockId': int,
        'quantity': int,
        'price': int,
        'subtotal': int,
        '_all': int,
    },
    total=False,
)


SaleItemKeys = Literal[
    'id',
    'saleId',
    'sale',
    'stockId',
    'stock',
    'quantity',
    'price',
    'subtotal',
    'ReturnItem',
]
SaleItemScalarFieldKeys = Literal[
    'id',
    'saleId',
    'stockId',
    'quantity',
    'price',
    'subtotal',
]
SaleItemScalarFieldKeysT = TypeVar('SaleItemScalarFieldKeysT', bound=SaleItemScalarFieldKeys)

SaleItemRelationalFieldKeys = Literal[
        'sale',
        'stock',
        'ReturnItem',
    ]

# ReturnSale types

class ReturnSaleOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the ReturnSale create method"""
    id: _int
    originalId: _int
    original: 'SaleCreateNestedWithoutRelationsInput'
    items: 'ReturnItemCreateManyNestedWithoutRelationsInput'
    reason: Optional[_str]
    refund: 'PaymentCreateManyNestedWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class ReturnSaleCreateInput(ReturnSaleOptionalCreateInput):
    """Required arguments to the ReturnSale create method"""


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class ReturnSaleOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the ReturnSale create method, without relations"""
    id: _int
    originalId: _int
    reason: Optional[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class ReturnSaleCreateWithoutRelationsInput(ReturnSaleOptionalCreateWithoutRelationsInput):
    """Required arguments to the ReturnSale create method, without relations"""


class ReturnSaleCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'ReturnSaleCreateWithoutRelationsInput'
    connect: 'ReturnSaleWhereUniqueInput'


class ReturnSaleCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['ReturnSaleCreateWithoutRelationsInput', List['ReturnSaleCreateWithoutRelationsInput']]
    connect: Union['ReturnSaleWhereUniqueInput', List['ReturnSaleWhereUniqueInput']]


_ReturnSaleWhereUnique_id_Input = TypedDict(
    '_ReturnSaleWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

ReturnSaleWhereUniqueInput = _ReturnSaleWhereUnique_id_Input


class ReturnSaleUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    original: 'SaleUpdateOneWithoutRelationsInput'
    items: 'ReturnItemUpdateManyWithoutRelationsInput'
    reason: Optional[_str]
    refund: 'PaymentUpdateManyWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class ReturnSaleUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    reason: Optional[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class ReturnSaleUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['ReturnSaleCreateWithoutRelationsInput']
    connect: List['ReturnSaleWhereUniqueInput']
    set: List['ReturnSaleWhereUniqueInput']
    disconnect: List['ReturnSaleWhereUniqueInput']
    delete: List['ReturnSaleWhereUniqueInput']

    # TODO
    # update: List['ReturnSaleUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['ReturnSaleUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['ReturnSaleScalarWhereInput']
    # upsert: List['ReturnSaleUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['ReturnSaleCreateOrConnectWithoutRelationsInput']


class ReturnSaleUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'ReturnSaleCreateWithoutRelationsInput'
    connect: 'ReturnSaleWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'ReturnSaleUpdateInput'
    # upsert: 'ReturnSaleUpsertWithoutRelationsInput'
    # connectOrCreate: 'ReturnSaleCreateOrConnectWithoutRelationsInput'


class ReturnSaleUpsertInput(TypedDict):
    create: 'ReturnSaleCreateInput'
    update: 'ReturnSaleUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_ReturnSale_id_OrderByInput = TypedDict(
    '_ReturnSale_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_ReturnSale_originalId_OrderByInput = TypedDict(
    '_ReturnSale_originalId_OrderByInput',
    {
        'originalId': 'SortOrder',
    },
    total=True
)

_ReturnSale_reason_OrderByInput = TypedDict(
    '_ReturnSale_reason_OrderByInput',
    {
        'reason': 'SortOrder',
    },
    total=True
)

_ReturnSale_createdAt_OrderByInput = TypedDict(
    '_ReturnSale_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_ReturnSale_updatedAt_OrderByInput = TypedDict(
    '_ReturnSale_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

ReturnSaleOrderByInput = Union[
    '_ReturnSale_id_OrderByInput',
    '_ReturnSale_originalId_OrderByInput',
    '_ReturnSale_reason_OrderByInput',
    '_ReturnSale_createdAt_OrderByInput',
    '_ReturnSale_updatedAt_OrderByInput',
]



# recursive ReturnSale types
# TODO: cleanup these types



ReturnSaleRelationFilter = TypedDict(
    'ReturnSaleRelationFilter',
    {
        'is': 'ReturnSaleWhereInput',
        'is_not': 'ReturnSaleWhereInput',
    },
    total=False,
)


class ReturnSaleListRelationFilter(TypedDict, total=False):
    some: 'ReturnSaleWhereInput'
    none: 'ReturnSaleWhereInput'
    every: 'ReturnSaleWhereInput'


class ReturnSaleInclude(TypedDict, total=False):
    """ReturnSale relational arguments"""
    original: Union[bool, 'SaleArgsFromReturnSale']
    items: Union[bool, 'FindManyReturnItemArgsFromReturnSale']
    refund: Union[bool, 'FindManyPaymentArgsFromReturnSale']


class UserIncludeFromReturnSale(TypedDict, total=False):
    """Relational arguments for ReturnSale"""
    branch: Union[bool, 'BranchArgsFromReturnSale']
    auditLogs: Union[bool, 'FindManyAuditLogArgsFromReturnSale']
    permissions: Union[bool, 'FindManyUserPermissionArgsFromReturnSale']
    notifications: Union[bool, 'FindManyNotificationArgsFromReturnSale']
    revokedTokens: Union[bool, 'FindManyRevokedTokenArgsFromReturnSale']
    stockAdjustments: Union[bool, 'FindManyStockAdjustmentArgsFromReturnSale']
    Sale: Union[bool, 'FindManySaleArgsFromReturnSale']
    deletedSales: Union[bool, 'FindManySaleArgsFromReturnSale']
    Payment: Union[bool, 'FindManyPaymentArgsFromReturnSale']
    Backup: Union[bool, 'FindManyBackupArgsFromReturnSale']
    requestedOrders: Union[bool, 'FindManyBranchOrderArgsFromReturnSale']
    approvedOrders: Union[bool, 'FindManyBranchOrderArgsFromReturnSale']
    sentOrders: Union[bool, 'FindManyBranchOrderArgsFromReturnSale']
    receivedOrders: Union[bool, 'FindManyBranchOrderArgsFromReturnSale']


class UserArgsFromReturnSale(TypedDict, total=False):
    """Arguments for ReturnSale"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromReturnSale(TypedDict, total=False):
    """Arguments for ReturnSale"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class UserPermissionIncludeFromReturnSale(TypedDict, total=False):
    """Relational arguments for ReturnSale"""
    user: Union[bool, 'UserArgsFromReturnSale']


class UserPermissionArgsFromReturnSale(TypedDict, total=False):
    """Arguments for ReturnSale"""
    include: 'UserPermissionIncludeFromUserPermission'


class FindManyUserPermissionArgsFromReturnSale(TypedDict, total=False):
    """Arguments for ReturnSale"""
    take: int
    skip: int
    order_by: Union['UserPermissionOrderByInput', List['UserPermissionOrderByInput']]
    where: 'UserPermissionWhereInput'
    cursor: 'UserPermissionWhereUniqueInput'
    distinct: List['UserPermissionScalarFieldKeys']
    include: 'UserPermissionIncludeFromUserPermission'


class BranchIncludeFromReturnSale(TypedDict, total=False):
    """Relational arguments for ReturnSale"""
    users: Union[bool, 'FindManyUserArgsFromReturnSale']
    Sale: Union[bool, 'FindManySaleArgsFromReturnSale']
    Account: Union[bool, 'FindManyAccountArgsFromReturnSale']
    BranchOrder: Union[bool, 'FindManyBranchOrderArgsFromReturnSale']


class BranchArgsFromReturnSale(TypedDict, total=False):
    """Arguments for ReturnSale"""
    include: 'BranchIncludeFromBranch'


class FindManyBranchArgsFromReturnSale(TypedDict, total=False):
    """Arguments for ReturnSale"""
    take: int
    skip: int
    order_by: Union['BranchOrderByInput', List['BranchOrderByInput']]
    where: 'BranchWhereInput'
    cursor: 'BranchWhereUniqueInput'
    distinct: List['BranchScalarFieldKeys']
    include: 'BranchIncludeFromBranch'


class ProductIncludeFromReturnSale(TypedDict, total=False):
    """Relational arguments for ReturnSale"""
    category: Union[bool, 'CategoryArgsFromReturnSale']
    stocks: Union[bool, 'FindManyStockArgsFromReturnSale']
    stockAdjustments: Union[bool, 'FindManyStockAdjustmentArgsFromReturnSale']


class ProductArgsFromReturnSale(TypedDict, total=False):
    """Arguments for ReturnSale"""
    include: 'ProductIncludeFromProduct'


class FindManyProductArgsFromReturnSale(TypedDict, total=False):
    """Arguments for ReturnSale"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProduct'


class CategoryIncludeFromReturnSale(TypedDict, total=False):
    """Relational arguments for ReturnSale"""
    products: Union[bool, 'FindManyProductArgsFromReturnSale']


class CategoryArgsFromReturnSale(TypedDict, total=False):
    """Arguments for ReturnSale"""
    include: 'CategoryIncludeFromCategory'


class FindManyCategoryArgsFromReturnSale(TypedDict, total=False):
    """Arguments for ReturnSale"""
    take: int
    skip: int
    order_by: Union['CategoryOrderByInput', List['CategoryOrderByInput']]
    where: 'CategoryWhereInput'
    cursor: 'CategoryWhereUniqueInput'
    distinct: List['CategoryScalarFieldKeys']
    include: 'CategoryIncludeFromCategory'


class StockIncludeFromReturnSale(TypedDict, total=False):
    """Relational arguments for ReturnSale"""
    product: Union[bool, 'ProductArgsFromReturnSale']
    SaleItem: Union[bool, 'FindManySaleItemArgsFromReturnSale']
    BranchOrderItem: Union[bool, 'FindManyBranchOrderItemArgsFromReturnSale']


class StockArgsFromReturnSale(TypedDict, total=False):
    """Arguments for ReturnSale"""
    include: 'StockIncludeFromStock'


class FindManyStockArgsFromReturnSale(TypedDict, total=False):
    """Arguments for ReturnSale"""
    take: int
    skip: int
    order_by: Union['StockOrderByInput', List['StockOrderByInput']]
    where: 'StockWhereInput'
    cursor: 'StockWhereUniqueInput'
    distinct: List['StockScalarFieldKeys']
    include: 'StockIncludeFromStock'


class CustomerIncludeFromReturnSale(TypedDict, total=False):
    """Relational arguments for ReturnSale"""
    Sale: Union[bool, 'FindManySaleArgsFromReturnSale']


class CustomerArgsFromReturnSale(TypedDict, total=False):
    """Arguments for ReturnSale"""
    include: 'CustomerIncludeFromCustomer'


class FindManyCustomerArgsFromReturnSale(TypedDict, total=False):
    """Arguments for ReturnSale"""
    take: int
    skip: int
    order_by: Union['CustomerOrderByInput', List['CustomerOrderByInput']]
    where: 'CustomerWhereInput'
    cursor: 'CustomerWhereUniqueInput'
    distinct: List['CustomerScalarFieldKeys']
    include: 'CustomerIncludeFromCustomer'


class SaleIncludeFromReturnSale(TypedDict, total=False):
    """Relational arguments for ReturnSale"""
    branch: Union[bool, 'BranchArgsFromReturnSale']
    customer: Union[bool, 'CustomerArgsFromReturnSale']
    user: Union[bool, 'UserArgsFromReturnSale']
    items: Union[bool, 'FindManySaleItemArgsFromReturnSale']
    payments: Union[bool, 'FindManyPaymentArgsFromReturnSale']
    returns: Union[bool, 'FindManyReturnSaleArgsFromReturnSale']
    deletedBy: Union[bool, 'UserArgsFromReturnSale']


class SaleArgsFromReturnSale(TypedDict, total=False):
    """Arguments for ReturnSale"""
    include: 'SaleIncludeFromSale'


class FindManySaleArgsFromReturnSale(TypedDict, total=False):
    """Arguments for ReturnSale"""
    take: int
    skip: int
    order_by: Union['SaleOrderByInput', List['SaleOrderByInput']]
    where: 'SaleWhereInput'
    cursor: 'SaleWhereUniqueInput'
    distinct: List['SaleScalarFieldKeys']
    include: 'SaleIncludeFromSale'


class SaleItemIncludeFromReturnSale(TypedDict, total=False):
    """Relational arguments for ReturnSale"""
    sale: Union[bool, 'SaleArgsFromReturnSale']
    stock: Union[bool, 'StockArgsFromReturnSale']
    ReturnItem: Union[bool, 'FindManyReturnItemArgsFromReturnSale']


class SaleItemArgsFromReturnSale(TypedDict, total=False):
    """Arguments for ReturnSale"""
    include: 'SaleItemIncludeFromSaleItem'


class FindManySaleItemArgsFromReturnSale(TypedDict, total=False):
    """Arguments for ReturnSale"""
    take: int
    skip: int
    order_by: Union['SaleItemOrderByInput', List['SaleItemOrderByInput']]
    where: 'SaleItemWhereInput'
    cursor: 'SaleItemWhereUniqueInput'
    distinct: List['SaleItemScalarFieldKeys']
    include: 'SaleItemIncludeFromSaleItem'


class ReturnSaleIncludeFromReturnSale(TypedDict, total=False):
    """Relational arguments for ReturnSale"""
    original: Union[bool, 'SaleArgsFromReturnSale']
    items: Union[bool, 'FindManyReturnItemArgsFromReturnSale']
    refund: Union[bool, 'FindManyPaymentArgsFromReturnSale']


class ReturnSaleArgsFromReturnSale(TypedDict, total=False):
    """Arguments for ReturnSale"""
    include: 'ReturnSaleIncludeFromReturnSale'


class FindManyReturnSaleArgsFromReturnSale(TypedDict, total=False):
    """Arguments for ReturnSale"""
    take: int
    skip: int
    order_by: Union['ReturnSaleOrderByInput', List['ReturnSaleOrderByInput']]
    where: 'ReturnSaleWhereInput'
    cursor: 'ReturnSaleWhereUniqueInput'
    distinct: List['ReturnSaleScalarFieldKeys']
    include: 'ReturnSaleIncludeFromReturnSale'


class ReturnItemIncludeFromReturnSale(TypedDict, total=False):
    """Relational arguments for ReturnSale"""
    returnSale: Union[bool, 'ReturnSaleArgsFromReturnSale']
    saleItem: Union[bool, 'SaleItemArgsFromReturnSale']


class ReturnItemArgsFromReturnSale(TypedDict, total=False):
    """Arguments for ReturnSale"""
    include: 'ReturnItemIncludeFromReturnItem'


class FindManyReturnItemArgsFromReturnSale(TypedDict, total=False):
    """Arguments for ReturnSale"""
    take: int
    skip: int
    order_by: Union['ReturnItemOrderByInput', List['ReturnItemOrderByInput']]
    where: 'ReturnItemWhereInput'
    cursor: 'ReturnItemWhereUniqueInput'
    distinct: List['ReturnItemScalarFieldKeys']
    include: 'ReturnItemIncludeFromReturnItem'


class PaymentIncludeFromReturnSale(TypedDict, total=False):
    """Relational arguments for ReturnSale"""
    sale: Union[bool, 'SaleArgsFromReturnSale']
    account: Union[bool, 'AccountArgsFromReturnSale']
    returnSale: Union[bool, 'ReturnSaleArgsFromReturnSale']
    user: Union[bool, 'UserArgsFromReturnSale']


class PaymentArgsFromReturnSale(TypedDict, total=False):
    """Arguments for ReturnSale"""
    include: 'PaymentIncludeFromPayment'


class FindManyPaymentArgsFromReturnSale(TypedDict, total=False):
    """Arguments for ReturnSale"""
    take: int
    skip: int
    order_by: Union['PaymentOrderByInput', List['PaymentOrderByInput']]
    where: 'PaymentWhereInput'
    cursor: 'PaymentWhereUniqueInput'
    distinct: List['PaymentScalarFieldKeys']
    include: 'PaymentIncludeFromPayment'


class JournalEntryIncludeFromReturnSale(TypedDict, total=False):
    """Relational arguments for ReturnSale"""
    lines: Union[bool, 'FindManyJournalEntryLineArgsFromReturnSale']


class JournalEntryArgsFromReturnSale(TypedDict, total=False):
    """Arguments for ReturnSale"""
    include: 'JournalEntryIncludeFromJournalEntry'


class FindManyJournalEntryArgsFromReturnSale(TypedDict, total=False):
    """Arguments for ReturnSale"""
    take: int
    skip: int
    order_by: Union['JournalEntryOrderByInput', List['JournalEntryOrderByInput']]
    where: 'JournalEntryWhereInput'
    cursor: 'JournalEntryWhereUniqueInput'
    distinct: List['JournalEntryScalarFieldKeys']
    include: 'JournalEntryIncludeFromJournalEntry'


class JournalEntryLineIncludeFromReturnSale(TypedDict, total=False):
    """Relational arguments for ReturnSale"""
    entry: Union[bool, 'JournalEntryArgsFromReturnSale']
    account: Union[bool, 'AccountArgsFromReturnSale']


class JournalEntryLineArgsFromReturnSale(TypedDict, total=False):
    """Arguments for ReturnSale"""
    include: 'JournalEntryLineIncludeFromJournalEntryLine'


class FindManyJournalEntryLineArgsFromReturnSale(TypedDict, total=False):
    """Arguments for ReturnSale"""
    take: int
    skip: int
    order_by: Union['JournalEntryLineOrderByInput', List['JournalEntryLineOrderByInput']]
    where: 'JournalEntryLineWhereInput'
    cursor: 'JournalEntryLineWhereUniqueInput'
    distinct: List['JournalEntryLineScalarFieldKeys']
    include: 'JournalEntryLineIncludeFromJournalEntryLine'


class AccountIncludeFromReturnSale(TypedDict, total=False):
    """Relational arguments for ReturnSale"""
    branch: Union[bool, 'BranchArgsFromReturnSale']
    entries: Union[bool, 'FindManyJournalEntryLineArgsFromReturnSale']
    payments: Union[bool, 'FindManyPaymentArgsFromReturnSale']
    outgoingTransfers: Union[bool, 'FindManyAccountTransferArgsFromReturnSale']
    incomingTransfers: Union[bool, 'FindManyAccountTransferArgsFromReturnSale']


class AccountArgsFromReturnSale(TypedDict, total=False):
    """Arguments for ReturnSale"""
    include: 'AccountIncludeFromAccount'


class FindManyAccountArgsFromReturnSale(TypedDict, total=False):
    """Arguments for ReturnSale"""
    take: int
    skip: int
    order_by: Union['AccountOrderByInput', List['AccountOrderByInput']]
    where: 'AccountWhereInput'
    cursor: 'AccountWhereUniqueInput'
    distinct: List['AccountScalarFieldKeys']
    include: 'AccountIncludeFromAccount'


class AccountTransferIncludeFromReturnSale(TypedDict, total=False):
    """Relational arguments for ReturnSale"""
    fromAccount: Union[bool, 'AccountArgsFromReturnSale']
    toAccount: Union[bool, 'AccountArgsFromReturnSale']


class AccountTransferArgsFromReturnSale(TypedDict, total=False):
    """Arguments for ReturnSale"""
    include: 'AccountTransferIncludeFromAccountTransfer'


class FindManyAccountTransferArgsFromReturnSale(TypedDict, total=False):
    """Arguments for ReturnSale"""
    take: int
    skip: int
    order_by: Union['AccountTransferOrderByInput', List['AccountTransferOrderByInput']]
    where: 'AccountTransferWhereInput'
    cursor: 'AccountTransferWhereUniqueInput'
    distinct: List['AccountTransferScalarFieldKeys']
    include: 'AccountTransferIncludeFromAccountTransfer'


class BranchOrderIncludeFromReturnSale(TypedDict, total=False):
    """Relational arguments for ReturnSale"""
    branch: Union[bool, 'BranchArgsFromReturnSale']
    requestedBy: Union[bool, 'UserArgsFromReturnSale']
    approvedBy: Union[bool, 'UserArgsFromReturnSale']
    sentBy: Union[bool, 'UserArgsFromReturnSale']
    receivedBy: Union[bool, 'UserArgsFromReturnSale']
    items: Union[bool, 'FindManyBranchOrderItemArgsFromReturnSale']


class BranchOrderArgsFromReturnSale(TypedDict, total=False):
    """Arguments for ReturnSale"""
    include: 'BranchOrderIncludeFromBranchOrder'


class FindManyBranchOrderArgsFromReturnSale(TypedDict, total=False):
    """Arguments for ReturnSale"""
    take: int
    skip: int
    order_by: Union['BranchOrderOrderByInput', List['BranchOrderOrderByInput']]
    where: 'BranchOrderWhereInput'
    cursor: 'BranchOrderWhereUniqueInput'
    distinct: List['BranchOrderScalarFieldKeys']
    include: 'BranchOrderIncludeFromBranchOrder'


class BranchOrderItemIncludeFromReturnSale(TypedDict, total=False):
    """Relational arguments for ReturnSale"""
    branchOrder: Union[bool, 'BranchOrderArgsFromReturnSale']
    stock: Union[bool, 'StockArgsFromReturnSale']


class BranchOrderItemArgsFromReturnSale(TypedDict, total=False):
    """Arguments for ReturnSale"""
    include: 'BranchOrderItemIncludeFromBranchOrderItem'


class FindManyBranchOrderItemArgsFromReturnSale(TypedDict, total=False):
    """Arguments for ReturnSale"""
    take: int
    skip: int
    order_by: Union['BranchOrderItemOrderByInput', List['BranchOrderItemOrderByInput']]
    where: 'BranchOrderItemWhereInput'
    cursor: 'BranchOrderItemWhereUniqueInput'
    distinct: List['BranchOrderItemScalarFieldKeys']
    include: 'BranchOrderItemIncludeFromBranchOrderItem'


class AuditLogIncludeFromReturnSale(TypedDict, total=False):
    """Relational arguments for ReturnSale"""
    user: Union[bool, 'UserArgsFromReturnSale']


class AuditLogArgsFromReturnSale(TypedDict, total=False):
    """Arguments for ReturnSale"""
    include: 'AuditLogIncludeFromAuditLog'


class FindManyAuditLogArgsFromReturnSale(TypedDict, total=False):
    """Arguments for ReturnSale"""
    take: int
    skip: int
    order_by: Union['AuditLogOrderByInput', List['AuditLogOrderByInput']]
    where: 'AuditLogWhereInput'
    cursor: 'AuditLogWhereUniqueInput'
    distinct: List['AuditLogScalarFieldKeys']
    include: 'AuditLogIncludeFromAuditLog'


class SystemInfoIncludeFromReturnSale(TypedDict, total=False):
    """Relational arguments for ReturnSale"""


class SystemInfoArgsFromReturnSale(TypedDict, total=False):
    """Arguments for ReturnSale"""
    include: 'SystemInfoIncludeFromSystemInfo'


class FindManySystemInfoArgsFromReturnSale(TypedDict, total=False):
    """Arguments for ReturnSale"""
    take: int
    skip: int
    order_by: Union['SystemInfoOrderByInput', List['SystemInfoOrderByInput']]
    where: 'SystemInfoWhereInput'
    cursor: 'SystemInfoWhereUniqueInput'
    distinct: List['SystemInfoScalarFieldKeys']
    include: 'SystemInfoIncludeFromSystemInfo'


class BackupIncludeFromReturnSale(TypedDict, total=False):
    """Relational arguments for ReturnSale"""
    createdBy: Union[bool, 'UserArgsFromReturnSale']


class BackupArgsFromReturnSale(TypedDict, total=False):
    """Arguments for ReturnSale"""
    include: 'BackupIncludeFromBackup'


class FindManyBackupArgsFromReturnSale(TypedDict, total=False):
    """Arguments for ReturnSale"""
    take: int
    skip: int
    order_by: Union['BackupOrderByInput', List['BackupOrderByInput']]
    where: 'BackupWhereInput'
    cursor: 'BackupWhereUniqueInput'
    distinct: List['BackupScalarFieldKeys']
    include: 'BackupIncludeFromBackup'


class RevokedTokenIncludeFromReturnSale(TypedDict, total=False):
    """Relational arguments for ReturnSale"""
    user: Union[bool, 'UserArgsFromReturnSale']


class RevokedTokenArgsFromReturnSale(TypedDict, total=False):
    """Arguments for ReturnSale"""
    include: 'RevokedTokenIncludeFromRevokedToken'


class FindManyRevokedTokenArgsFromReturnSale(TypedDict, total=False):
    """Arguments for ReturnSale"""
    take: int
    skip: int
    order_by: Union['RevokedTokenOrderByInput', List['RevokedTokenOrderByInput']]
    where: 'RevokedTokenWhereInput'
    cursor: 'RevokedTokenWhereUniqueInput'
    distinct: List['RevokedTokenScalarFieldKeys']
    include: 'RevokedTokenIncludeFromRevokedToken'


class SystemSettingIncludeFromReturnSale(TypedDict, total=False):
    """Relational arguments for ReturnSale"""


class SystemSettingArgsFromReturnSale(TypedDict, total=False):
    """Arguments for ReturnSale"""
    include: 'SystemSettingIncludeFromSystemSetting'


class FindManySystemSettingArgsFromReturnSale(TypedDict, total=False):
    """Arguments for ReturnSale"""
    take: int
    skip: int
    order_by: Union['SystemSettingOrderByInput', List['SystemSettingOrderByInput']]
    where: 'SystemSettingWhereInput'
    cursor: 'SystemSettingWhereUniqueInput'
    distinct: List['SystemSettingScalarFieldKeys']
    include: 'SystemSettingIncludeFromSystemSetting'


class NotificationIncludeFromReturnSale(TypedDict, total=False):
    """Relational arguments for ReturnSale"""
    user: Union[bool, 'UserArgsFromReturnSale']


class NotificationArgsFromReturnSale(TypedDict, total=False):
    """Arguments for ReturnSale"""
    include: 'NotificationIncludeFromNotification'


class FindManyNotificationArgsFromReturnSale(TypedDict, total=False):
    """Arguments for ReturnSale"""
    take: int
    skip: int
    order_by: Union['NotificationOrderByInput', List['NotificationOrderByInput']]
    where: 'NotificationWhereInput'
    cursor: 'NotificationWhereUniqueInput'
    distinct: List['NotificationScalarFieldKeys']
    include: 'NotificationIncludeFromNotification'


class StockAdjustmentIncludeFromReturnSale(TypedDict, total=False):
    """Relational arguments for ReturnSale"""
    product: Union[bool, 'ProductArgsFromReturnSale']
    createdBy: Union[bool, 'UserArgsFromReturnSale']


class StockAdjustmentArgsFromReturnSale(TypedDict, total=False):
    """Arguments for ReturnSale"""
    include: 'StockAdjustmentIncludeFromStockAdjustment'


class FindManyStockAdjustmentArgsFromReturnSale(TypedDict, total=False):
    """Arguments for ReturnSale"""
    take: int
    skip: int
    order_by: Union['StockAdjustmentOrderByInput', List['StockAdjustmentOrderByInput']]
    where: 'StockAdjustmentWhereInput'
    cursor: 'StockAdjustmentWhereUniqueInput'
    distinct: List['StockAdjustmentScalarFieldKeys']
    include: 'StockAdjustmentIncludeFromStockAdjustment'




FindManyReturnSaleArgs = FindManyReturnSaleArgsFromReturnSale
FindFirstReturnSaleArgs = FindManyReturnSaleArgsFromReturnSale


class ReturnSaleWhereInput(TypedDict, total=False):
    """ReturnSale arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    originalId: Union[_int, 'types.IntFilter']
    original: 'SaleRelationFilter'
    items: 'ReturnItemListRelationFilter'
    reason: Union[None, _str, 'types.StringFilter']
    refund: 'PaymentListRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['ReturnSaleWhereInput', List['ReturnSaleWhereInput']]
    # but this causes mypy to hang :/
    AND: List['ReturnSaleWhereInput']
    OR: List['ReturnSaleWhereInput']
    NOT: List['ReturnSaleWhereInput']



# aggregate ReturnSale types


class ReturnSaleScalarWhereWithAggregatesInput(TypedDict, total=False):
    """ReturnSale arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    originalId: Union[_int, 'types.IntWithAggregatesFilter']
    reason: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['ReturnSaleScalarWhereWithAggregatesInput']
    OR: List['ReturnSaleScalarWhereWithAggregatesInput']
    NOT: List['ReturnSaleScalarWhereWithAggregatesInput']



class ReturnSaleGroupByOutput(TypedDict, total=False):
    id: _int
    originalId: _int
    reason: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'ReturnSaleSumAggregateOutput'
    _avg: 'ReturnSaleAvgAggregateOutput'
    _min: 'ReturnSaleMinAggregateOutput'
    _max: 'ReturnSaleMaxAggregateOutput'
    _count: 'ReturnSaleCountAggregateOutput'


class ReturnSaleAvgAggregateOutput(TypedDict, total=False):
    """ReturnSale output for aggregating averages"""
    id: float
    originalId: float


class ReturnSaleSumAggregateOutput(TypedDict, total=False):
    """ReturnSale output for aggregating sums"""
    id: _int
    originalId: _int


class ReturnSaleScalarAggregateOutput(TypedDict, total=False):
    """ReturnSale output including scalar fields"""
    id: _int
    originalId: _int
    reason: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


ReturnSaleMinAggregateOutput = ReturnSaleScalarAggregateOutput
ReturnSaleMaxAggregateOutput = ReturnSaleScalarAggregateOutput


class ReturnSaleMaxAggregateInput(TypedDict, total=False):
    """ReturnSale input for aggregating by max"""
    id: bool
    originalId: bool
    reason: bool
    createdAt: bool
    updatedAt: bool


class ReturnSaleMinAggregateInput(TypedDict, total=False):
    """ReturnSale input for aggregating by min"""
    id: bool
    originalId: bool
    reason: bool
    createdAt: bool
    updatedAt: bool


class ReturnSaleNumberAggregateInput(TypedDict, total=False):
    """ReturnSale input for aggregating numbers"""
    id: bool
    originalId: bool


ReturnSaleAvgAggregateInput = ReturnSaleNumberAggregateInput
ReturnSaleSumAggregateInput = ReturnSaleNumberAggregateInput


ReturnSaleCountAggregateInput = TypedDict(
    'ReturnSaleCountAggregateInput',
    {
        'id': bool,
        'originalId': bool,
        'reason': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

ReturnSaleCountAggregateOutput = TypedDict(
    'ReturnSaleCountAggregateOutput',
    {
        'id': int,
        'originalId': int,
        'reason': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


ReturnSaleKeys = Literal[
    'id',
    'originalId',
    'original',
    'items',
    'reason',
    'refund',
    'createdAt',
    'updatedAt',
]
ReturnSaleScalarFieldKeys = Literal[
    'id',
    'originalId',
    'reason',
    'createdAt',
    'updatedAt',
]
ReturnSaleScalarFieldKeysT = TypeVar('ReturnSaleScalarFieldKeysT', bound=ReturnSaleScalarFieldKeys)

ReturnSaleRelationalFieldKeys = Literal[
        'original',
        'items',
        'refund',
    ]

# ReturnItem types

class ReturnItemOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the ReturnItem create method"""
    id: _int
    returnId: _int
    returnSale: 'ReturnSaleCreateNestedWithoutRelationsInput'
    saleItemId: _int
    saleItem: 'SaleItemCreateNestedWithoutRelationsInput'


class ReturnItemCreateInput(ReturnItemOptionalCreateInput):
    """Required arguments to the ReturnItem create method"""
    quantity: _int
    refundAmount: decimal.Decimal


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class ReturnItemOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the ReturnItem create method, without relations"""
    id: _int
    returnId: _int
    saleItemId: _int


class ReturnItemCreateWithoutRelationsInput(ReturnItemOptionalCreateWithoutRelationsInput):
    """Required arguments to the ReturnItem create method, without relations"""
    quantity: _int
    refundAmount: decimal.Decimal


class ReturnItemCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'ReturnItemCreateWithoutRelationsInput'
    connect: 'ReturnItemWhereUniqueInput'


class ReturnItemCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['ReturnItemCreateWithoutRelationsInput', List['ReturnItemCreateWithoutRelationsInput']]
    connect: Union['ReturnItemWhereUniqueInput', List['ReturnItemWhereUniqueInput']]


_ReturnItemWhereUnique_id_Input = TypedDict(
    '_ReturnItemWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

ReturnItemWhereUniqueInput = _ReturnItemWhereUnique_id_Input


class ReturnItemUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    returnSale: 'ReturnSaleUpdateOneWithoutRelationsInput'
    saleItem: 'SaleItemUpdateOneWithoutRelationsInput'
    quantity: Union[AtomicIntInput, _int]
    refundAmount: decimal.Decimal


class ReturnItemUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    quantity: Union[AtomicIntInput, _int]
    refundAmount: decimal.Decimal


class ReturnItemUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['ReturnItemCreateWithoutRelationsInput']
    connect: List['ReturnItemWhereUniqueInput']
    set: List['ReturnItemWhereUniqueInput']
    disconnect: List['ReturnItemWhereUniqueInput']
    delete: List['ReturnItemWhereUniqueInput']

    # TODO
    # update: List['ReturnItemUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['ReturnItemUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['ReturnItemScalarWhereInput']
    # upsert: List['ReturnItemUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['ReturnItemCreateOrConnectWithoutRelationsInput']


class ReturnItemUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'ReturnItemCreateWithoutRelationsInput'
    connect: 'ReturnItemWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'ReturnItemUpdateInput'
    # upsert: 'ReturnItemUpsertWithoutRelationsInput'
    # connectOrCreate: 'ReturnItemCreateOrConnectWithoutRelationsInput'


class ReturnItemUpsertInput(TypedDict):
    create: 'ReturnItemCreateInput'
    update: 'ReturnItemUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_ReturnItem_id_OrderByInput = TypedDict(
    '_ReturnItem_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_ReturnItem_returnId_OrderByInput = TypedDict(
    '_ReturnItem_returnId_OrderByInput',
    {
        'returnId': 'SortOrder',
    },
    total=True
)

_ReturnItem_saleItemId_OrderByInput = TypedDict(
    '_ReturnItem_saleItemId_OrderByInput',
    {
        'saleItemId': 'SortOrder',
    },
    total=True
)

_ReturnItem_quantity_OrderByInput = TypedDict(
    '_ReturnItem_quantity_OrderByInput',
    {
        'quantity': 'SortOrder',
    },
    total=True
)

_ReturnItem_refundAmount_OrderByInput = TypedDict(
    '_ReturnItem_refundAmount_OrderByInput',
    {
        'refundAmount': 'SortOrder',
    },
    total=True
)

ReturnItemOrderByInput = Union[
    '_ReturnItem_id_OrderByInput',
    '_ReturnItem_returnId_OrderByInput',
    '_ReturnItem_saleItemId_OrderByInput',
    '_ReturnItem_quantity_OrderByInput',
    '_ReturnItem_refundAmount_OrderByInput',
]



# recursive ReturnItem types
# TODO: cleanup these types



ReturnItemRelationFilter = TypedDict(
    'ReturnItemRelationFilter',
    {
        'is': 'ReturnItemWhereInput',
        'is_not': 'ReturnItemWhereInput',
    },
    total=False,
)


class ReturnItemListRelationFilter(TypedDict, total=False):
    some: 'ReturnItemWhereInput'
    none: 'ReturnItemWhereInput'
    every: 'ReturnItemWhereInput'


class ReturnItemInclude(TypedDict, total=False):
    """ReturnItem relational arguments"""
    returnSale: Union[bool, 'ReturnSaleArgsFromReturnItem']
    saleItem: Union[bool, 'SaleItemArgsFromReturnItem']


class UserIncludeFromReturnItem(TypedDict, total=False):
    """Relational arguments for ReturnItem"""
    branch: Union[bool, 'BranchArgsFromReturnItem']
    auditLogs: Union[bool, 'FindManyAuditLogArgsFromReturnItem']
    permissions: Union[bool, 'FindManyUserPermissionArgsFromReturnItem']
    notifications: Union[bool, 'FindManyNotificationArgsFromReturnItem']
    revokedTokens: Union[bool, 'FindManyRevokedTokenArgsFromReturnItem']
    stockAdjustments: Union[bool, 'FindManyStockAdjustmentArgsFromReturnItem']
    Sale: Union[bool, 'FindManySaleArgsFromReturnItem']
    deletedSales: Union[bool, 'FindManySaleArgsFromReturnItem']
    Payment: Union[bool, 'FindManyPaymentArgsFromReturnItem']
    Backup: Union[bool, 'FindManyBackupArgsFromReturnItem']
    requestedOrders: Union[bool, 'FindManyBranchOrderArgsFromReturnItem']
    approvedOrders: Union[bool, 'FindManyBranchOrderArgsFromReturnItem']
    sentOrders: Union[bool, 'FindManyBranchOrderArgsFromReturnItem']
    receivedOrders: Union[bool, 'FindManyBranchOrderArgsFromReturnItem']


class UserArgsFromReturnItem(TypedDict, total=False):
    """Arguments for ReturnItem"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromReturnItem(TypedDict, total=False):
    """Arguments for ReturnItem"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class UserPermissionIncludeFromReturnItem(TypedDict, total=False):
    """Relational arguments for ReturnItem"""
    user: Union[bool, 'UserArgsFromReturnItem']


class UserPermissionArgsFromReturnItem(TypedDict, total=False):
    """Arguments for ReturnItem"""
    include: 'UserPermissionIncludeFromUserPermission'


class FindManyUserPermissionArgsFromReturnItem(TypedDict, total=False):
    """Arguments for ReturnItem"""
    take: int
    skip: int
    order_by: Union['UserPermissionOrderByInput', List['UserPermissionOrderByInput']]
    where: 'UserPermissionWhereInput'
    cursor: 'UserPermissionWhereUniqueInput'
    distinct: List['UserPermissionScalarFieldKeys']
    include: 'UserPermissionIncludeFromUserPermission'


class BranchIncludeFromReturnItem(TypedDict, total=False):
    """Relational arguments for ReturnItem"""
    users: Union[bool, 'FindManyUserArgsFromReturnItem']
    Sale: Union[bool, 'FindManySaleArgsFromReturnItem']
    Account: Union[bool, 'FindManyAccountArgsFromReturnItem']
    BranchOrder: Union[bool, 'FindManyBranchOrderArgsFromReturnItem']


class BranchArgsFromReturnItem(TypedDict, total=False):
    """Arguments for ReturnItem"""
    include: 'BranchIncludeFromBranch'


class FindManyBranchArgsFromReturnItem(TypedDict, total=False):
    """Arguments for ReturnItem"""
    take: int
    skip: int
    order_by: Union['BranchOrderByInput', List['BranchOrderByInput']]
    where: 'BranchWhereInput'
    cursor: 'BranchWhereUniqueInput'
    distinct: List['BranchScalarFieldKeys']
    include: 'BranchIncludeFromBranch'


class ProductIncludeFromReturnItem(TypedDict, total=False):
    """Relational arguments for ReturnItem"""
    category: Union[bool, 'CategoryArgsFromReturnItem']
    stocks: Union[bool, 'FindManyStockArgsFromReturnItem']
    stockAdjustments: Union[bool, 'FindManyStockAdjustmentArgsFromReturnItem']


class ProductArgsFromReturnItem(TypedDict, total=False):
    """Arguments for ReturnItem"""
    include: 'ProductIncludeFromProduct'


class FindManyProductArgsFromReturnItem(TypedDict, total=False):
    """Arguments for ReturnItem"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProduct'


class CategoryIncludeFromReturnItem(TypedDict, total=False):
    """Relational arguments for ReturnItem"""
    products: Union[bool, 'FindManyProductArgsFromReturnItem']


class CategoryArgsFromReturnItem(TypedDict, total=False):
    """Arguments for ReturnItem"""
    include: 'CategoryIncludeFromCategory'


class FindManyCategoryArgsFromReturnItem(TypedDict, total=False):
    """Arguments for ReturnItem"""
    take: int
    skip: int
    order_by: Union['CategoryOrderByInput', List['CategoryOrderByInput']]
    where: 'CategoryWhereInput'
    cursor: 'CategoryWhereUniqueInput'
    distinct: List['CategoryScalarFieldKeys']
    include: 'CategoryIncludeFromCategory'


class StockIncludeFromReturnItem(TypedDict, total=False):
    """Relational arguments for ReturnItem"""
    product: Union[bool, 'ProductArgsFromReturnItem']
    SaleItem: Union[bool, 'FindManySaleItemArgsFromReturnItem']
    BranchOrderItem: Union[bool, 'FindManyBranchOrderItemArgsFromReturnItem']


class StockArgsFromReturnItem(TypedDict, total=False):
    """Arguments for ReturnItem"""
    include: 'StockIncludeFromStock'


class FindManyStockArgsFromReturnItem(TypedDict, total=False):
    """Arguments for ReturnItem"""
    take: int
    skip: int
    order_by: Union['StockOrderByInput', List['StockOrderByInput']]
    where: 'StockWhereInput'
    cursor: 'StockWhereUniqueInput'
    distinct: List['StockScalarFieldKeys']
    include: 'StockIncludeFromStock'


class CustomerIncludeFromReturnItem(TypedDict, total=False):
    """Relational arguments for ReturnItem"""
    Sale: Union[bool, 'FindManySaleArgsFromReturnItem']


class CustomerArgsFromReturnItem(TypedDict, total=False):
    """Arguments for ReturnItem"""
    include: 'CustomerIncludeFromCustomer'


class FindManyCustomerArgsFromReturnItem(TypedDict, total=False):
    """Arguments for ReturnItem"""
    take: int
    skip: int
    order_by: Union['CustomerOrderByInput', List['CustomerOrderByInput']]
    where: 'CustomerWhereInput'
    cursor: 'CustomerWhereUniqueInput'
    distinct: List['CustomerScalarFieldKeys']
    include: 'CustomerIncludeFromCustomer'


class SaleIncludeFromReturnItem(TypedDict, total=False):
    """Relational arguments for ReturnItem"""
    branch: Union[bool, 'BranchArgsFromReturnItem']
    customer: Union[bool, 'CustomerArgsFromReturnItem']
    user: Union[bool, 'UserArgsFromReturnItem']
    items: Union[bool, 'FindManySaleItemArgsFromReturnItem']
    payments: Union[bool, 'FindManyPaymentArgsFromReturnItem']
    returns: Union[bool, 'FindManyReturnSaleArgsFromReturnItem']
    deletedBy: Union[bool, 'UserArgsFromReturnItem']


class SaleArgsFromReturnItem(TypedDict, total=False):
    """Arguments for ReturnItem"""
    include: 'SaleIncludeFromSale'


class FindManySaleArgsFromReturnItem(TypedDict, total=False):
    """Arguments for ReturnItem"""
    take: int
    skip: int
    order_by: Union['SaleOrderByInput', List['SaleOrderByInput']]
    where: 'SaleWhereInput'
    cursor: 'SaleWhereUniqueInput'
    distinct: List['SaleScalarFieldKeys']
    include: 'SaleIncludeFromSale'


class SaleItemIncludeFromReturnItem(TypedDict, total=False):
    """Relational arguments for ReturnItem"""
    sale: Union[bool, 'SaleArgsFromReturnItem']
    stock: Union[bool, 'StockArgsFromReturnItem']
    ReturnItem: Union[bool, 'FindManyReturnItemArgsFromReturnItem']


class SaleItemArgsFromReturnItem(TypedDict, total=False):
    """Arguments for ReturnItem"""
    include: 'SaleItemIncludeFromSaleItem'


class FindManySaleItemArgsFromReturnItem(TypedDict, total=False):
    """Arguments for ReturnItem"""
    take: int
    skip: int
    order_by: Union['SaleItemOrderByInput', List['SaleItemOrderByInput']]
    where: 'SaleItemWhereInput'
    cursor: 'SaleItemWhereUniqueInput'
    distinct: List['SaleItemScalarFieldKeys']
    include: 'SaleItemIncludeFromSaleItem'


class ReturnSaleIncludeFromReturnItem(TypedDict, total=False):
    """Relational arguments for ReturnItem"""
    original: Union[bool, 'SaleArgsFromReturnItem']
    items: Union[bool, 'FindManyReturnItemArgsFromReturnItem']
    refund: Union[bool, 'FindManyPaymentArgsFromReturnItem']


class ReturnSaleArgsFromReturnItem(TypedDict, total=False):
    """Arguments for ReturnItem"""
    include: 'ReturnSaleIncludeFromReturnSale'


class FindManyReturnSaleArgsFromReturnItem(TypedDict, total=False):
    """Arguments for ReturnItem"""
    take: int
    skip: int
    order_by: Union['ReturnSaleOrderByInput', List['ReturnSaleOrderByInput']]
    where: 'ReturnSaleWhereInput'
    cursor: 'ReturnSaleWhereUniqueInput'
    distinct: List['ReturnSaleScalarFieldKeys']
    include: 'ReturnSaleIncludeFromReturnSale'


class ReturnItemIncludeFromReturnItem(TypedDict, total=False):
    """Relational arguments for ReturnItem"""
    returnSale: Union[bool, 'ReturnSaleArgsFromReturnItem']
    saleItem: Union[bool, 'SaleItemArgsFromReturnItem']


class ReturnItemArgsFromReturnItem(TypedDict, total=False):
    """Arguments for ReturnItem"""
    include: 'ReturnItemIncludeFromReturnItem'


class FindManyReturnItemArgsFromReturnItem(TypedDict, total=False):
    """Arguments for ReturnItem"""
    take: int
    skip: int
    order_by: Union['ReturnItemOrderByInput', List['ReturnItemOrderByInput']]
    where: 'ReturnItemWhereInput'
    cursor: 'ReturnItemWhereUniqueInput'
    distinct: List['ReturnItemScalarFieldKeys']
    include: 'ReturnItemIncludeFromReturnItem'


class PaymentIncludeFromReturnItem(TypedDict, total=False):
    """Relational arguments for ReturnItem"""
    sale: Union[bool, 'SaleArgsFromReturnItem']
    account: Union[bool, 'AccountArgsFromReturnItem']
    returnSale: Union[bool, 'ReturnSaleArgsFromReturnItem']
    user: Union[bool, 'UserArgsFromReturnItem']


class PaymentArgsFromReturnItem(TypedDict, total=False):
    """Arguments for ReturnItem"""
    include: 'PaymentIncludeFromPayment'


class FindManyPaymentArgsFromReturnItem(TypedDict, total=False):
    """Arguments for ReturnItem"""
    take: int
    skip: int
    order_by: Union['PaymentOrderByInput', List['PaymentOrderByInput']]
    where: 'PaymentWhereInput'
    cursor: 'PaymentWhereUniqueInput'
    distinct: List['PaymentScalarFieldKeys']
    include: 'PaymentIncludeFromPayment'


class JournalEntryIncludeFromReturnItem(TypedDict, total=False):
    """Relational arguments for ReturnItem"""
    lines: Union[bool, 'FindManyJournalEntryLineArgsFromReturnItem']


class JournalEntryArgsFromReturnItem(TypedDict, total=False):
    """Arguments for ReturnItem"""
    include: 'JournalEntryIncludeFromJournalEntry'


class FindManyJournalEntryArgsFromReturnItem(TypedDict, total=False):
    """Arguments for ReturnItem"""
    take: int
    skip: int
    order_by: Union['JournalEntryOrderByInput', List['JournalEntryOrderByInput']]
    where: 'JournalEntryWhereInput'
    cursor: 'JournalEntryWhereUniqueInput'
    distinct: List['JournalEntryScalarFieldKeys']
    include: 'JournalEntryIncludeFromJournalEntry'


class JournalEntryLineIncludeFromReturnItem(TypedDict, total=False):
    """Relational arguments for ReturnItem"""
    entry: Union[bool, 'JournalEntryArgsFromReturnItem']
    account: Union[bool, 'AccountArgsFromReturnItem']


class JournalEntryLineArgsFromReturnItem(TypedDict, total=False):
    """Arguments for ReturnItem"""
    include: 'JournalEntryLineIncludeFromJournalEntryLine'


class FindManyJournalEntryLineArgsFromReturnItem(TypedDict, total=False):
    """Arguments for ReturnItem"""
    take: int
    skip: int
    order_by: Union['JournalEntryLineOrderByInput', List['JournalEntryLineOrderByInput']]
    where: 'JournalEntryLineWhereInput'
    cursor: 'JournalEntryLineWhereUniqueInput'
    distinct: List['JournalEntryLineScalarFieldKeys']
    include: 'JournalEntryLineIncludeFromJournalEntryLine'


class AccountIncludeFromReturnItem(TypedDict, total=False):
    """Relational arguments for ReturnItem"""
    branch: Union[bool, 'BranchArgsFromReturnItem']
    entries: Union[bool, 'FindManyJournalEntryLineArgsFromReturnItem']
    payments: Union[bool, 'FindManyPaymentArgsFromReturnItem']
    outgoingTransfers: Union[bool, 'FindManyAccountTransferArgsFromReturnItem']
    incomingTransfers: Union[bool, 'FindManyAccountTransferArgsFromReturnItem']


class AccountArgsFromReturnItem(TypedDict, total=False):
    """Arguments for ReturnItem"""
    include: 'AccountIncludeFromAccount'


class FindManyAccountArgsFromReturnItem(TypedDict, total=False):
    """Arguments for ReturnItem"""
    take: int
    skip: int
    order_by: Union['AccountOrderByInput', List['AccountOrderByInput']]
    where: 'AccountWhereInput'
    cursor: 'AccountWhereUniqueInput'
    distinct: List['AccountScalarFieldKeys']
    include: 'AccountIncludeFromAccount'


class AccountTransferIncludeFromReturnItem(TypedDict, total=False):
    """Relational arguments for ReturnItem"""
    fromAccount: Union[bool, 'AccountArgsFromReturnItem']
    toAccount: Union[bool, 'AccountArgsFromReturnItem']


class AccountTransferArgsFromReturnItem(TypedDict, total=False):
    """Arguments for ReturnItem"""
    include: 'AccountTransferIncludeFromAccountTransfer'


class FindManyAccountTransferArgsFromReturnItem(TypedDict, total=False):
    """Arguments for ReturnItem"""
    take: int
    skip: int
    order_by: Union['AccountTransferOrderByInput', List['AccountTransferOrderByInput']]
    where: 'AccountTransferWhereInput'
    cursor: 'AccountTransferWhereUniqueInput'
    distinct: List['AccountTransferScalarFieldKeys']
    include: 'AccountTransferIncludeFromAccountTransfer'


class BranchOrderIncludeFromReturnItem(TypedDict, total=False):
    """Relational arguments for ReturnItem"""
    branch: Union[bool, 'BranchArgsFromReturnItem']
    requestedBy: Union[bool, 'UserArgsFromReturnItem']
    approvedBy: Union[bool, 'UserArgsFromReturnItem']
    sentBy: Union[bool, 'UserArgsFromReturnItem']
    receivedBy: Union[bool, 'UserArgsFromReturnItem']
    items: Union[bool, 'FindManyBranchOrderItemArgsFromReturnItem']


class BranchOrderArgsFromReturnItem(TypedDict, total=False):
    """Arguments for ReturnItem"""
    include: 'BranchOrderIncludeFromBranchOrder'


class FindManyBranchOrderArgsFromReturnItem(TypedDict, total=False):
    """Arguments for ReturnItem"""
    take: int
    skip: int
    order_by: Union['BranchOrderOrderByInput', List['BranchOrderOrderByInput']]
    where: 'BranchOrderWhereInput'
    cursor: 'BranchOrderWhereUniqueInput'
    distinct: List['BranchOrderScalarFieldKeys']
    include: 'BranchOrderIncludeFromBranchOrder'


class BranchOrderItemIncludeFromReturnItem(TypedDict, total=False):
    """Relational arguments for ReturnItem"""
    branchOrder: Union[bool, 'BranchOrderArgsFromReturnItem']
    stock: Union[bool, 'StockArgsFromReturnItem']


class BranchOrderItemArgsFromReturnItem(TypedDict, total=False):
    """Arguments for ReturnItem"""
    include: 'BranchOrderItemIncludeFromBranchOrderItem'


class FindManyBranchOrderItemArgsFromReturnItem(TypedDict, total=False):
    """Arguments for ReturnItem"""
    take: int
    skip: int
    order_by: Union['BranchOrderItemOrderByInput', List['BranchOrderItemOrderByInput']]
    where: 'BranchOrderItemWhereInput'
    cursor: 'BranchOrderItemWhereUniqueInput'
    distinct: List['BranchOrderItemScalarFieldKeys']
    include: 'BranchOrderItemIncludeFromBranchOrderItem'


class AuditLogIncludeFromReturnItem(TypedDict, total=False):
    """Relational arguments for ReturnItem"""
    user: Union[bool, 'UserArgsFromReturnItem']


class AuditLogArgsFromReturnItem(TypedDict, total=False):
    """Arguments for ReturnItem"""
    include: 'AuditLogIncludeFromAuditLog'


class FindManyAuditLogArgsFromReturnItem(TypedDict, total=False):
    """Arguments for ReturnItem"""
    take: int
    skip: int
    order_by: Union['AuditLogOrderByInput', List['AuditLogOrderByInput']]
    where: 'AuditLogWhereInput'
    cursor: 'AuditLogWhereUniqueInput'
    distinct: List['AuditLogScalarFieldKeys']
    include: 'AuditLogIncludeFromAuditLog'


class SystemInfoIncludeFromReturnItem(TypedDict, total=False):
    """Relational arguments for ReturnItem"""


class SystemInfoArgsFromReturnItem(TypedDict, total=False):
    """Arguments for ReturnItem"""
    include: 'SystemInfoIncludeFromSystemInfo'


class FindManySystemInfoArgsFromReturnItem(TypedDict, total=False):
    """Arguments for ReturnItem"""
    take: int
    skip: int
    order_by: Union['SystemInfoOrderByInput', List['SystemInfoOrderByInput']]
    where: 'SystemInfoWhereInput'
    cursor: 'SystemInfoWhereUniqueInput'
    distinct: List['SystemInfoScalarFieldKeys']
    include: 'SystemInfoIncludeFromSystemInfo'


class BackupIncludeFromReturnItem(TypedDict, total=False):
    """Relational arguments for ReturnItem"""
    createdBy: Union[bool, 'UserArgsFromReturnItem']


class BackupArgsFromReturnItem(TypedDict, total=False):
    """Arguments for ReturnItem"""
    include: 'BackupIncludeFromBackup'


class FindManyBackupArgsFromReturnItem(TypedDict, total=False):
    """Arguments for ReturnItem"""
    take: int
    skip: int
    order_by: Union['BackupOrderByInput', List['BackupOrderByInput']]
    where: 'BackupWhereInput'
    cursor: 'BackupWhereUniqueInput'
    distinct: List['BackupScalarFieldKeys']
    include: 'BackupIncludeFromBackup'


class RevokedTokenIncludeFromReturnItem(TypedDict, total=False):
    """Relational arguments for ReturnItem"""
    user: Union[bool, 'UserArgsFromReturnItem']


class RevokedTokenArgsFromReturnItem(TypedDict, total=False):
    """Arguments for ReturnItem"""
    include: 'RevokedTokenIncludeFromRevokedToken'


class FindManyRevokedTokenArgsFromReturnItem(TypedDict, total=False):
    """Arguments for ReturnItem"""
    take: int
    skip: int
    order_by: Union['RevokedTokenOrderByInput', List['RevokedTokenOrderByInput']]
    where: 'RevokedTokenWhereInput'
    cursor: 'RevokedTokenWhereUniqueInput'
    distinct: List['RevokedTokenScalarFieldKeys']
    include: 'RevokedTokenIncludeFromRevokedToken'


class SystemSettingIncludeFromReturnItem(TypedDict, total=False):
    """Relational arguments for ReturnItem"""


class SystemSettingArgsFromReturnItem(TypedDict, total=False):
    """Arguments for ReturnItem"""
    include: 'SystemSettingIncludeFromSystemSetting'


class FindManySystemSettingArgsFromReturnItem(TypedDict, total=False):
    """Arguments for ReturnItem"""
    take: int
    skip: int
    order_by: Union['SystemSettingOrderByInput', List['SystemSettingOrderByInput']]
    where: 'SystemSettingWhereInput'
    cursor: 'SystemSettingWhereUniqueInput'
    distinct: List['SystemSettingScalarFieldKeys']
    include: 'SystemSettingIncludeFromSystemSetting'


class NotificationIncludeFromReturnItem(TypedDict, total=False):
    """Relational arguments for ReturnItem"""
    user: Union[bool, 'UserArgsFromReturnItem']


class NotificationArgsFromReturnItem(TypedDict, total=False):
    """Arguments for ReturnItem"""
    include: 'NotificationIncludeFromNotification'


class FindManyNotificationArgsFromReturnItem(TypedDict, total=False):
    """Arguments for ReturnItem"""
    take: int
    skip: int
    order_by: Union['NotificationOrderByInput', List['NotificationOrderByInput']]
    where: 'NotificationWhereInput'
    cursor: 'NotificationWhereUniqueInput'
    distinct: List['NotificationScalarFieldKeys']
    include: 'NotificationIncludeFromNotification'


class StockAdjustmentIncludeFromReturnItem(TypedDict, total=False):
    """Relational arguments for ReturnItem"""
    product: Union[bool, 'ProductArgsFromReturnItem']
    createdBy: Union[bool, 'UserArgsFromReturnItem']


class StockAdjustmentArgsFromReturnItem(TypedDict, total=False):
    """Arguments for ReturnItem"""
    include: 'StockAdjustmentIncludeFromStockAdjustment'


class FindManyStockAdjustmentArgsFromReturnItem(TypedDict, total=False):
    """Arguments for ReturnItem"""
    take: int
    skip: int
    order_by: Union['StockAdjustmentOrderByInput', List['StockAdjustmentOrderByInput']]
    where: 'StockAdjustmentWhereInput'
    cursor: 'StockAdjustmentWhereUniqueInput'
    distinct: List['StockAdjustmentScalarFieldKeys']
    include: 'StockAdjustmentIncludeFromStockAdjustment'




FindManyReturnItemArgs = FindManyReturnItemArgsFromReturnItem
FindFirstReturnItemArgs = FindManyReturnItemArgsFromReturnItem


class ReturnItemWhereInput(TypedDict, total=False):
    """ReturnItem arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    returnId: Union[_int, 'types.IntFilter']
    returnSale: 'ReturnSaleRelationFilter'
    saleItemId: Union[_int, 'types.IntFilter']
    saleItem: 'SaleItemRelationFilter'
    quantity: Union[_int, 'types.IntFilter']
    refundAmount: Union[decimal.Decimal, 'types.DecimalFilter']

    # should be noted that AND and NOT should be Union['ReturnItemWhereInput', List['ReturnItemWhereInput']]
    # but this causes mypy to hang :/
    AND: List['ReturnItemWhereInput']
    OR: List['ReturnItemWhereInput']
    NOT: List['ReturnItemWhereInput']



# aggregate ReturnItem types


class ReturnItemScalarWhereWithAggregatesInput(TypedDict, total=False):
    """ReturnItem arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    returnId: Union[_int, 'types.IntWithAggregatesFilter']
    saleItemId: Union[_int, 'types.IntWithAggregatesFilter']
    quantity: Union[_int, 'types.IntWithAggregatesFilter']
    refundAmount: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']

    AND: List['ReturnItemScalarWhereWithAggregatesInput']
    OR: List['ReturnItemScalarWhereWithAggregatesInput']
    NOT: List['ReturnItemScalarWhereWithAggregatesInput']



class ReturnItemGroupByOutput(TypedDict, total=False):
    id: _int
    returnId: _int
    saleItemId: _int
    quantity: _int
    refundAmount: decimal.Decimal
    _sum: 'ReturnItemSumAggregateOutput'
    _avg: 'ReturnItemAvgAggregateOutput'
    _min: 'ReturnItemMinAggregateOutput'
    _max: 'ReturnItemMaxAggregateOutput'
    _count: 'ReturnItemCountAggregateOutput'


class ReturnItemAvgAggregateOutput(TypedDict, total=False):
    """ReturnItem output for aggregating averages"""
    id: float
    returnId: float
    saleItemId: float
    quantity: float


class ReturnItemSumAggregateOutput(TypedDict, total=False):
    """ReturnItem output for aggregating sums"""
    id: _int
    returnId: _int
    saleItemId: _int
    quantity: _int


class ReturnItemScalarAggregateOutput(TypedDict, total=False):
    """ReturnItem output including scalar fields"""
    id: _int
    returnId: _int
    saleItemId: _int
    quantity: _int
    refundAmount: decimal.Decimal


ReturnItemMinAggregateOutput = ReturnItemScalarAggregateOutput
ReturnItemMaxAggregateOutput = ReturnItemScalarAggregateOutput


class ReturnItemMaxAggregateInput(TypedDict, total=False):
    """ReturnItem input for aggregating by max"""
    id: bool
    returnId: bool
    saleItemId: bool
    quantity: bool
    refundAmount: bool


class ReturnItemMinAggregateInput(TypedDict, total=False):
    """ReturnItem input for aggregating by min"""
    id: bool
    returnId: bool
    saleItemId: bool
    quantity: bool
    refundAmount: bool


class ReturnItemNumberAggregateInput(TypedDict, total=False):
    """ReturnItem input for aggregating numbers"""
    id: bool
    returnId: bool
    saleItemId: bool
    quantity: bool


ReturnItemAvgAggregateInput = ReturnItemNumberAggregateInput
ReturnItemSumAggregateInput = ReturnItemNumberAggregateInput


ReturnItemCountAggregateInput = TypedDict(
    'ReturnItemCountAggregateInput',
    {
        'id': bool,
        'returnId': bool,
        'saleItemId': bool,
        'quantity': bool,
        'refundAmount': bool,
        '_all': bool,
    },
    total=False,
)

ReturnItemCountAggregateOutput = TypedDict(
    'ReturnItemCountAggregateOutput',
    {
        'id': int,
        'returnId': int,
        'saleItemId': int,
        'quantity': int,
        'refundAmount': int,
        '_all': int,
    },
    total=False,
)


ReturnItemKeys = Literal[
    'id',
    'returnId',
    'returnSale',
    'saleItemId',
    'saleItem',
    'quantity',
    'refundAmount',
]
ReturnItemScalarFieldKeys = Literal[
    'id',
    'returnId',
    'saleItemId',
    'quantity',
    'refundAmount',
]
ReturnItemScalarFieldKeysT = TypeVar('ReturnItemScalarFieldKeysT', bound=ReturnItemScalarFieldKeys)

ReturnItemRelationalFieldKeys = Literal[
        'returnSale',
        'saleItem',
    ]

# Payment types

class PaymentOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Payment create method"""
    id: _int
    saleId: _int
    sale: 'SaleCreateNestedWithoutRelationsInput'
    accountId: _int
    account: 'AccountCreateNestedWithoutRelationsInput'
    returnId: Optional[_int]
    returnSale: 'ReturnSaleCreateNestedWithoutRelationsInput'
    userId: _int
    user: 'UserCreateNestedWithoutRelationsInput'
    currency: 'enums.Currency'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class PaymentCreateInput(PaymentOptionalCreateInput):
    """Required arguments to the Payment create method"""
    amount: decimal.Decimal


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class PaymentOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Payment create method, without relations"""
    id: _int
    saleId: _int
    accountId: _int
    returnId: Optional[_int]
    userId: _int
    currency: 'enums.Currency'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class PaymentCreateWithoutRelationsInput(PaymentOptionalCreateWithoutRelationsInput):
    """Required arguments to the Payment create method, without relations"""
    amount: decimal.Decimal


class PaymentCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'PaymentCreateWithoutRelationsInput'
    connect: 'PaymentWhereUniqueInput'


class PaymentCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['PaymentCreateWithoutRelationsInput', List['PaymentCreateWithoutRelationsInput']]
    connect: Union['PaymentWhereUniqueInput', List['PaymentWhereUniqueInput']]


_PaymentWhereUnique_id_Input = TypedDict(
    '_PaymentWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

PaymentWhereUniqueInput = _PaymentWhereUnique_id_Input


class PaymentUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    sale: 'SaleUpdateOneWithoutRelationsInput'
    account: 'AccountUpdateOneWithoutRelationsInput'
    returnSale: 'ReturnSaleUpdateOneWithoutRelationsInput'
    user: 'UserUpdateOneWithoutRelationsInput'
    amount: decimal.Decimal
    currency: 'enums.Currency'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class PaymentUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    amount: decimal.Decimal
    currency: 'enums.Currency'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class PaymentUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['PaymentCreateWithoutRelationsInput']
    connect: List['PaymentWhereUniqueInput']
    set: List['PaymentWhereUniqueInput']
    disconnect: List['PaymentWhereUniqueInput']
    delete: List['PaymentWhereUniqueInput']

    # TODO
    # update: List['PaymentUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['PaymentUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['PaymentScalarWhereInput']
    # upsert: List['PaymentUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['PaymentCreateOrConnectWithoutRelationsInput']


class PaymentUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'PaymentCreateWithoutRelationsInput'
    connect: 'PaymentWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'PaymentUpdateInput'
    # upsert: 'PaymentUpsertWithoutRelationsInput'
    # connectOrCreate: 'PaymentCreateOrConnectWithoutRelationsInput'


class PaymentUpsertInput(TypedDict):
    create: 'PaymentCreateInput'
    update: 'PaymentUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Payment_id_OrderByInput = TypedDict(
    '_Payment_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Payment_saleId_OrderByInput = TypedDict(
    '_Payment_saleId_OrderByInput',
    {
        'saleId': 'SortOrder',
    },
    total=True
)

_Payment_accountId_OrderByInput = TypedDict(
    '_Payment_accountId_OrderByInput',
    {
        'accountId': 'SortOrder',
    },
    total=True
)

_Payment_returnId_OrderByInput = TypedDict(
    '_Payment_returnId_OrderByInput',
    {
        'returnId': 'SortOrder',
    },
    total=True
)

_Payment_userId_OrderByInput = TypedDict(
    '_Payment_userId_OrderByInput',
    {
        'userId': 'SortOrder',
    },
    total=True
)

_Payment_amount_OrderByInput = TypedDict(
    '_Payment_amount_OrderByInput',
    {
        'amount': 'SortOrder',
    },
    total=True
)

_Payment_currency_OrderByInput = TypedDict(
    '_Payment_currency_OrderByInput',
    {
        'currency': 'SortOrder',
    },
    total=True
)

_Payment_createdAt_OrderByInput = TypedDict(
    '_Payment_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Payment_updatedAt_OrderByInput = TypedDict(
    '_Payment_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

PaymentOrderByInput = Union[
    '_Payment_id_OrderByInput',
    '_Payment_saleId_OrderByInput',
    '_Payment_accountId_OrderByInput',
    '_Payment_returnId_OrderByInput',
    '_Payment_userId_OrderByInput',
    '_Payment_amount_OrderByInput',
    '_Payment_currency_OrderByInput',
    '_Payment_createdAt_OrderByInput',
    '_Payment_updatedAt_OrderByInput',
]



# recursive Payment types
# TODO: cleanup these types



PaymentRelationFilter = TypedDict(
    'PaymentRelationFilter',
    {
        'is': 'PaymentWhereInput',
        'is_not': 'PaymentWhereInput',
    },
    total=False,
)


class PaymentListRelationFilter(TypedDict, total=False):
    some: 'PaymentWhereInput'
    none: 'PaymentWhereInput'
    every: 'PaymentWhereInput'


class PaymentInclude(TypedDict, total=False):
    """Payment relational arguments"""
    sale: Union[bool, 'SaleArgsFromPayment']
    account: Union[bool, 'AccountArgsFromPayment']
    returnSale: Union[bool, 'ReturnSaleArgsFromPayment']
    user: Union[bool, 'UserArgsFromPayment']


class UserIncludeFromPayment(TypedDict, total=False):
    """Relational arguments for Payment"""
    branch: Union[bool, 'BranchArgsFromPayment']
    auditLogs: Union[bool, 'FindManyAuditLogArgsFromPayment']
    permissions: Union[bool, 'FindManyUserPermissionArgsFromPayment']
    notifications: Union[bool, 'FindManyNotificationArgsFromPayment']
    revokedTokens: Union[bool, 'FindManyRevokedTokenArgsFromPayment']
    stockAdjustments: Union[bool, 'FindManyStockAdjustmentArgsFromPayment']
    Sale: Union[bool, 'FindManySaleArgsFromPayment']
    deletedSales: Union[bool, 'FindManySaleArgsFromPayment']
    Payment: Union[bool, 'FindManyPaymentArgsFromPayment']
    Backup: Union[bool, 'FindManyBackupArgsFromPayment']
    requestedOrders: Union[bool, 'FindManyBranchOrderArgsFromPayment']
    approvedOrders: Union[bool, 'FindManyBranchOrderArgsFromPayment']
    sentOrders: Union[bool, 'FindManyBranchOrderArgsFromPayment']
    receivedOrders: Union[bool, 'FindManyBranchOrderArgsFromPayment']


class UserArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class UserPermissionIncludeFromPayment(TypedDict, total=False):
    """Relational arguments for Payment"""
    user: Union[bool, 'UserArgsFromPayment']


class UserPermissionArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    include: 'UserPermissionIncludeFromUserPermission'


class FindManyUserPermissionArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    take: int
    skip: int
    order_by: Union['UserPermissionOrderByInput', List['UserPermissionOrderByInput']]
    where: 'UserPermissionWhereInput'
    cursor: 'UserPermissionWhereUniqueInput'
    distinct: List['UserPermissionScalarFieldKeys']
    include: 'UserPermissionIncludeFromUserPermission'


class BranchIncludeFromPayment(TypedDict, total=False):
    """Relational arguments for Payment"""
    users: Union[bool, 'FindManyUserArgsFromPayment']
    Sale: Union[bool, 'FindManySaleArgsFromPayment']
    Account: Union[bool, 'FindManyAccountArgsFromPayment']
    BranchOrder: Union[bool, 'FindManyBranchOrderArgsFromPayment']


class BranchArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    include: 'BranchIncludeFromBranch'


class FindManyBranchArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    take: int
    skip: int
    order_by: Union['BranchOrderByInput', List['BranchOrderByInput']]
    where: 'BranchWhereInput'
    cursor: 'BranchWhereUniqueInput'
    distinct: List['BranchScalarFieldKeys']
    include: 'BranchIncludeFromBranch'


class ProductIncludeFromPayment(TypedDict, total=False):
    """Relational arguments for Payment"""
    category: Union[bool, 'CategoryArgsFromPayment']
    stocks: Union[bool, 'FindManyStockArgsFromPayment']
    stockAdjustments: Union[bool, 'FindManyStockAdjustmentArgsFromPayment']


class ProductArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    include: 'ProductIncludeFromProduct'


class FindManyProductArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProduct'


class CategoryIncludeFromPayment(TypedDict, total=False):
    """Relational arguments for Payment"""
    products: Union[bool, 'FindManyProductArgsFromPayment']


class CategoryArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    include: 'CategoryIncludeFromCategory'


class FindManyCategoryArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    take: int
    skip: int
    order_by: Union['CategoryOrderByInput', List['CategoryOrderByInput']]
    where: 'CategoryWhereInput'
    cursor: 'CategoryWhereUniqueInput'
    distinct: List['CategoryScalarFieldKeys']
    include: 'CategoryIncludeFromCategory'


class StockIncludeFromPayment(TypedDict, total=False):
    """Relational arguments for Payment"""
    product: Union[bool, 'ProductArgsFromPayment']
    SaleItem: Union[bool, 'FindManySaleItemArgsFromPayment']
    BranchOrderItem: Union[bool, 'FindManyBranchOrderItemArgsFromPayment']


class StockArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    include: 'StockIncludeFromStock'


class FindManyStockArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    take: int
    skip: int
    order_by: Union['StockOrderByInput', List['StockOrderByInput']]
    where: 'StockWhereInput'
    cursor: 'StockWhereUniqueInput'
    distinct: List['StockScalarFieldKeys']
    include: 'StockIncludeFromStock'


class CustomerIncludeFromPayment(TypedDict, total=False):
    """Relational arguments for Payment"""
    Sale: Union[bool, 'FindManySaleArgsFromPayment']


class CustomerArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    include: 'CustomerIncludeFromCustomer'


class FindManyCustomerArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    take: int
    skip: int
    order_by: Union['CustomerOrderByInput', List['CustomerOrderByInput']]
    where: 'CustomerWhereInput'
    cursor: 'CustomerWhereUniqueInput'
    distinct: List['CustomerScalarFieldKeys']
    include: 'CustomerIncludeFromCustomer'


class SaleIncludeFromPayment(TypedDict, total=False):
    """Relational arguments for Payment"""
    branch: Union[bool, 'BranchArgsFromPayment']
    customer: Union[bool, 'CustomerArgsFromPayment']
    user: Union[bool, 'UserArgsFromPayment']
    items: Union[bool, 'FindManySaleItemArgsFromPayment']
    payments: Union[bool, 'FindManyPaymentArgsFromPayment']
    returns: Union[bool, 'FindManyReturnSaleArgsFromPayment']
    deletedBy: Union[bool, 'UserArgsFromPayment']


class SaleArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    include: 'SaleIncludeFromSale'


class FindManySaleArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    take: int
    skip: int
    order_by: Union['SaleOrderByInput', List['SaleOrderByInput']]
    where: 'SaleWhereInput'
    cursor: 'SaleWhereUniqueInput'
    distinct: List['SaleScalarFieldKeys']
    include: 'SaleIncludeFromSale'


class SaleItemIncludeFromPayment(TypedDict, total=False):
    """Relational arguments for Payment"""
    sale: Union[bool, 'SaleArgsFromPayment']
    stock: Union[bool, 'StockArgsFromPayment']
    ReturnItem: Union[bool, 'FindManyReturnItemArgsFromPayment']


class SaleItemArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    include: 'SaleItemIncludeFromSaleItem'


class FindManySaleItemArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    take: int
    skip: int
    order_by: Union['SaleItemOrderByInput', List['SaleItemOrderByInput']]
    where: 'SaleItemWhereInput'
    cursor: 'SaleItemWhereUniqueInput'
    distinct: List['SaleItemScalarFieldKeys']
    include: 'SaleItemIncludeFromSaleItem'


class ReturnSaleIncludeFromPayment(TypedDict, total=False):
    """Relational arguments for Payment"""
    original: Union[bool, 'SaleArgsFromPayment']
    items: Union[bool, 'FindManyReturnItemArgsFromPayment']
    refund: Union[bool, 'FindManyPaymentArgsFromPayment']


class ReturnSaleArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    include: 'ReturnSaleIncludeFromReturnSale'


class FindManyReturnSaleArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    take: int
    skip: int
    order_by: Union['ReturnSaleOrderByInput', List['ReturnSaleOrderByInput']]
    where: 'ReturnSaleWhereInput'
    cursor: 'ReturnSaleWhereUniqueInput'
    distinct: List['ReturnSaleScalarFieldKeys']
    include: 'ReturnSaleIncludeFromReturnSale'


class ReturnItemIncludeFromPayment(TypedDict, total=False):
    """Relational arguments for Payment"""
    returnSale: Union[bool, 'ReturnSaleArgsFromPayment']
    saleItem: Union[bool, 'SaleItemArgsFromPayment']


class ReturnItemArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    include: 'ReturnItemIncludeFromReturnItem'


class FindManyReturnItemArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    take: int
    skip: int
    order_by: Union['ReturnItemOrderByInput', List['ReturnItemOrderByInput']]
    where: 'ReturnItemWhereInput'
    cursor: 'ReturnItemWhereUniqueInput'
    distinct: List['ReturnItemScalarFieldKeys']
    include: 'ReturnItemIncludeFromReturnItem'


class PaymentIncludeFromPayment(TypedDict, total=False):
    """Relational arguments for Payment"""
    sale: Union[bool, 'SaleArgsFromPayment']
    account: Union[bool, 'AccountArgsFromPayment']
    returnSale: Union[bool, 'ReturnSaleArgsFromPayment']
    user: Union[bool, 'UserArgsFromPayment']


class PaymentArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    include: 'PaymentIncludeFromPayment'


class FindManyPaymentArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    take: int
    skip: int
    order_by: Union['PaymentOrderByInput', List['PaymentOrderByInput']]
    where: 'PaymentWhereInput'
    cursor: 'PaymentWhereUniqueInput'
    distinct: List['PaymentScalarFieldKeys']
    include: 'PaymentIncludeFromPayment'


class JournalEntryIncludeFromPayment(TypedDict, total=False):
    """Relational arguments for Payment"""
    lines: Union[bool, 'FindManyJournalEntryLineArgsFromPayment']


class JournalEntryArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    include: 'JournalEntryIncludeFromJournalEntry'


class FindManyJournalEntryArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    take: int
    skip: int
    order_by: Union['JournalEntryOrderByInput', List['JournalEntryOrderByInput']]
    where: 'JournalEntryWhereInput'
    cursor: 'JournalEntryWhereUniqueInput'
    distinct: List['JournalEntryScalarFieldKeys']
    include: 'JournalEntryIncludeFromJournalEntry'


class JournalEntryLineIncludeFromPayment(TypedDict, total=False):
    """Relational arguments for Payment"""
    entry: Union[bool, 'JournalEntryArgsFromPayment']
    account: Union[bool, 'AccountArgsFromPayment']


class JournalEntryLineArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    include: 'JournalEntryLineIncludeFromJournalEntryLine'


class FindManyJournalEntryLineArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    take: int
    skip: int
    order_by: Union['JournalEntryLineOrderByInput', List['JournalEntryLineOrderByInput']]
    where: 'JournalEntryLineWhereInput'
    cursor: 'JournalEntryLineWhereUniqueInput'
    distinct: List['JournalEntryLineScalarFieldKeys']
    include: 'JournalEntryLineIncludeFromJournalEntryLine'


class AccountIncludeFromPayment(TypedDict, total=False):
    """Relational arguments for Payment"""
    branch: Union[bool, 'BranchArgsFromPayment']
    entries: Union[bool, 'FindManyJournalEntryLineArgsFromPayment']
    payments: Union[bool, 'FindManyPaymentArgsFromPayment']
    outgoingTransfers: Union[bool, 'FindManyAccountTransferArgsFromPayment']
    incomingTransfers: Union[bool, 'FindManyAccountTransferArgsFromPayment']


class AccountArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    include: 'AccountIncludeFromAccount'


class FindManyAccountArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    take: int
    skip: int
    order_by: Union['AccountOrderByInput', List['AccountOrderByInput']]
    where: 'AccountWhereInput'
    cursor: 'AccountWhereUniqueInput'
    distinct: List['AccountScalarFieldKeys']
    include: 'AccountIncludeFromAccount'


class AccountTransferIncludeFromPayment(TypedDict, total=False):
    """Relational arguments for Payment"""
    fromAccount: Union[bool, 'AccountArgsFromPayment']
    toAccount: Union[bool, 'AccountArgsFromPayment']


class AccountTransferArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    include: 'AccountTransferIncludeFromAccountTransfer'


class FindManyAccountTransferArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    take: int
    skip: int
    order_by: Union['AccountTransferOrderByInput', List['AccountTransferOrderByInput']]
    where: 'AccountTransferWhereInput'
    cursor: 'AccountTransferWhereUniqueInput'
    distinct: List['AccountTransferScalarFieldKeys']
    include: 'AccountTransferIncludeFromAccountTransfer'


class BranchOrderIncludeFromPayment(TypedDict, total=False):
    """Relational arguments for Payment"""
    branch: Union[bool, 'BranchArgsFromPayment']
    requestedBy: Union[bool, 'UserArgsFromPayment']
    approvedBy: Union[bool, 'UserArgsFromPayment']
    sentBy: Union[bool, 'UserArgsFromPayment']
    receivedBy: Union[bool, 'UserArgsFromPayment']
    items: Union[bool, 'FindManyBranchOrderItemArgsFromPayment']


class BranchOrderArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    include: 'BranchOrderIncludeFromBranchOrder'


class FindManyBranchOrderArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    take: int
    skip: int
    order_by: Union['BranchOrderOrderByInput', List['BranchOrderOrderByInput']]
    where: 'BranchOrderWhereInput'
    cursor: 'BranchOrderWhereUniqueInput'
    distinct: List['BranchOrderScalarFieldKeys']
    include: 'BranchOrderIncludeFromBranchOrder'


class BranchOrderItemIncludeFromPayment(TypedDict, total=False):
    """Relational arguments for Payment"""
    branchOrder: Union[bool, 'BranchOrderArgsFromPayment']
    stock: Union[bool, 'StockArgsFromPayment']


class BranchOrderItemArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    include: 'BranchOrderItemIncludeFromBranchOrderItem'


class FindManyBranchOrderItemArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    take: int
    skip: int
    order_by: Union['BranchOrderItemOrderByInput', List['BranchOrderItemOrderByInput']]
    where: 'BranchOrderItemWhereInput'
    cursor: 'BranchOrderItemWhereUniqueInput'
    distinct: List['BranchOrderItemScalarFieldKeys']
    include: 'BranchOrderItemIncludeFromBranchOrderItem'


class AuditLogIncludeFromPayment(TypedDict, total=False):
    """Relational arguments for Payment"""
    user: Union[bool, 'UserArgsFromPayment']


class AuditLogArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    include: 'AuditLogIncludeFromAuditLog'


class FindManyAuditLogArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    take: int
    skip: int
    order_by: Union['AuditLogOrderByInput', List['AuditLogOrderByInput']]
    where: 'AuditLogWhereInput'
    cursor: 'AuditLogWhereUniqueInput'
    distinct: List['AuditLogScalarFieldKeys']
    include: 'AuditLogIncludeFromAuditLog'


class SystemInfoIncludeFromPayment(TypedDict, total=False):
    """Relational arguments for Payment"""


class SystemInfoArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    include: 'SystemInfoIncludeFromSystemInfo'


class FindManySystemInfoArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    take: int
    skip: int
    order_by: Union['SystemInfoOrderByInput', List['SystemInfoOrderByInput']]
    where: 'SystemInfoWhereInput'
    cursor: 'SystemInfoWhereUniqueInput'
    distinct: List['SystemInfoScalarFieldKeys']
    include: 'SystemInfoIncludeFromSystemInfo'


class BackupIncludeFromPayment(TypedDict, total=False):
    """Relational arguments for Payment"""
    createdBy: Union[bool, 'UserArgsFromPayment']


class BackupArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    include: 'BackupIncludeFromBackup'


class FindManyBackupArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    take: int
    skip: int
    order_by: Union['BackupOrderByInput', List['BackupOrderByInput']]
    where: 'BackupWhereInput'
    cursor: 'BackupWhereUniqueInput'
    distinct: List['BackupScalarFieldKeys']
    include: 'BackupIncludeFromBackup'


class RevokedTokenIncludeFromPayment(TypedDict, total=False):
    """Relational arguments for Payment"""
    user: Union[bool, 'UserArgsFromPayment']


class RevokedTokenArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    include: 'RevokedTokenIncludeFromRevokedToken'


class FindManyRevokedTokenArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    take: int
    skip: int
    order_by: Union['RevokedTokenOrderByInput', List['RevokedTokenOrderByInput']]
    where: 'RevokedTokenWhereInput'
    cursor: 'RevokedTokenWhereUniqueInput'
    distinct: List['RevokedTokenScalarFieldKeys']
    include: 'RevokedTokenIncludeFromRevokedToken'


class SystemSettingIncludeFromPayment(TypedDict, total=False):
    """Relational arguments for Payment"""


class SystemSettingArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    include: 'SystemSettingIncludeFromSystemSetting'


class FindManySystemSettingArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    take: int
    skip: int
    order_by: Union['SystemSettingOrderByInput', List['SystemSettingOrderByInput']]
    where: 'SystemSettingWhereInput'
    cursor: 'SystemSettingWhereUniqueInput'
    distinct: List['SystemSettingScalarFieldKeys']
    include: 'SystemSettingIncludeFromSystemSetting'


class NotificationIncludeFromPayment(TypedDict, total=False):
    """Relational arguments for Payment"""
    user: Union[bool, 'UserArgsFromPayment']


class NotificationArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    include: 'NotificationIncludeFromNotification'


class FindManyNotificationArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    take: int
    skip: int
    order_by: Union['NotificationOrderByInput', List['NotificationOrderByInput']]
    where: 'NotificationWhereInput'
    cursor: 'NotificationWhereUniqueInput'
    distinct: List['NotificationScalarFieldKeys']
    include: 'NotificationIncludeFromNotification'


class StockAdjustmentIncludeFromPayment(TypedDict, total=False):
    """Relational arguments for Payment"""
    product: Union[bool, 'ProductArgsFromPayment']
    createdBy: Union[bool, 'UserArgsFromPayment']


class StockAdjustmentArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    include: 'StockAdjustmentIncludeFromStockAdjustment'


class FindManyStockAdjustmentArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    take: int
    skip: int
    order_by: Union['StockAdjustmentOrderByInput', List['StockAdjustmentOrderByInput']]
    where: 'StockAdjustmentWhereInput'
    cursor: 'StockAdjustmentWhereUniqueInput'
    distinct: List['StockAdjustmentScalarFieldKeys']
    include: 'StockAdjustmentIncludeFromStockAdjustment'




FindManyPaymentArgs = FindManyPaymentArgsFromPayment
FindFirstPaymentArgs = FindManyPaymentArgsFromPayment


class PaymentWhereInput(TypedDict, total=False):
    """Payment arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    saleId: Union[_int, 'types.IntFilter']
    sale: 'SaleRelationFilter'
    accountId: Union[_int, 'types.IntFilter']
    account: 'AccountRelationFilter'
    returnId: Union[None, _int, 'types.IntFilter']
    returnSale: 'ReturnSaleRelationFilter'
    userId: Union[_int, 'types.IntFilter']
    user: 'UserRelationFilter'
    amount: Union[decimal.Decimal, 'types.DecimalFilter']
    currency: 'enums.Currency'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['PaymentWhereInput', List['PaymentWhereInput']]
    # but this causes mypy to hang :/
    AND: List['PaymentWhereInput']
    OR: List['PaymentWhereInput']
    NOT: List['PaymentWhereInput']



# aggregate Payment types


class PaymentScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Payment arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    saleId: Union[_int, 'types.IntWithAggregatesFilter']
    accountId: Union[_int, 'types.IntWithAggregatesFilter']
    returnId: Union[_int, 'types.IntWithAggregatesFilter']
    userId: Union[_int, 'types.IntWithAggregatesFilter']
    amount: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    currency: 'enums.Currency'
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['PaymentScalarWhereWithAggregatesInput']
    OR: List['PaymentScalarWhereWithAggregatesInput']
    NOT: List['PaymentScalarWhereWithAggregatesInput']



class PaymentGroupByOutput(TypedDict, total=False):
    id: _int
    saleId: _int
    accountId: _int
    returnId: _int
    userId: _int
    amount: decimal.Decimal
    currency: 'enums.Currency'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'PaymentSumAggregateOutput'
    _avg: 'PaymentAvgAggregateOutput'
    _min: 'PaymentMinAggregateOutput'
    _max: 'PaymentMaxAggregateOutput'
    _count: 'PaymentCountAggregateOutput'


class PaymentAvgAggregateOutput(TypedDict, total=False):
    """Payment output for aggregating averages"""
    id: float
    saleId: float
    accountId: float
    returnId: float
    userId: float


class PaymentSumAggregateOutput(TypedDict, total=False):
    """Payment output for aggregating sums"""
    id: _int
    saleId: _int
    accountId: _int
    returnId: _int
    userId: _int


class PaymentScalarAggregateOutput(TypedDict, total=False):
    """Payment output including scalar fields"""
    id: _int
    saleId: _int
    accountId: _int
    returnId: _int
    userId: _int
    amount: decimal.Decimal
    currency: 'enums.Currency'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


PaymentMinAggregateOutput = PaymentScalarAggregateOutput
PaymentMaxAggregateOutput = PaymentScalarAggregateOutput


class PaymentMaxAggregateInput(TypedDict, total=False):
    """Payment input for aggregating by max"""
    id: bool
    saleId: bool
    accountId: bool
    returnId: bool
    userId: bool
    amount: bool
    currency: bool
    createdAt: bool
    updatedAt: bool


class PaymentMinAggregateInput(TypedDict, total=False):
    """Payment input for aggregating by min"""
    id: bool
    saleId: bool
    accountId: bool
    returnId: bool
    userId: bool
    amount: bool
    currency: bool
    createdAt: bool
    updatedAt: bool


class PaymentNumberAggregateInput(TypedDict, total=False):
    """Payment input for aggregating numbers"""
    id: bool
    saleId: bool
    accountId: bool
    returnId: bool
    userId: bool


PaymentAvgAggregateInput = PaymentNumberAggregateInput
PaymentSumAggregateInput = PaymentNumberAggregateInput


PaymentCountAggregateInput = TypedDict(
    'PaymentCountAggregateInput',
    {
        'id': bool,
        'saleId': bool,
        'accountId': bool,
        'returnId': bool,
        'userId': bool,
        'amount': bool,
        'currency': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

PaymentCountAggregateOutput = TypedDict(
    'PaymentCountAggregateOutput',
    {
        'id': int,
        'saleId': int,
        'accountId': int,
        'returnId': int,
        'userId': int,
        'amount': int,
        'currency': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


PaymentKeys = Literal[
    'id',
    'saleId',
    'sale',
    'accountId',
    'account',
    'returnId',
    'returnSale',
    'userId',
    'user',
    'amount',
    'currency',
    'createdAt',
    'updatedAt',
]
PaymentScalarFieldKeys = Literal[
    'id',
    'saleId',
    'accountId',
    'returnId',
    'userId',
    'amount',
    'currency',
    'createdAt',
    'updatedAt',
]
PaymentScalarFieldKeysT = TypeVar('PaymentScalarFieldKeysT', bound=PaymentScalarFieldKeys)

PaymentRelationalFieldKeys = Literal[
        'sale',
        'account',
        'returnSale',
        'user',
    ]

# JournalEntry types

class JournalEntryOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the JournalEntry create method"""
    id: _int
    referenceType: Optional[_str]
    referenceId: Optional[_int]
    lines: 'JournalEntryLineCreateManyNestedWithoutRelationsInput'
    date: datetime.datetime
    updatedAt: datetime.datetime


class JournalEntryCreateInput(JournalEntryOptionalCreateInput):
    """Required arguments to the JournalEntry create method"""


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class JournalEntryOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the JournalEntry create method, without relations"""
    id: _int
    referenceType: Optional[_str]
    referenceId: Optional[_int]
    date: datetime.datetime
    updatedAt: datetime.datetime


class JournalEntryCreateWithoutRelationsInput(JournalEntryOptionalCreateWithoutRelationsInput):
    """Required arguments to the JournalEntry create method, without relations"""


class JournalEntryCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'JournalEntryCreateWithoutRelationsInput'
    connect: 'JournalEntryWhereUniqueInput'


class JournalEntryCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['JournalEntryCreateWithoutRelationsInput', List['JournalEntryCreateWithoutRelationsInput']]
    connect: Union['JournalEntryWhereUniqueInput', List['JournalEntryWhereUniqueInput']]


_JournalEntryWhereUnique_id_Input = TypedDict(
    '_JournalEntryWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

JournalEntryWhereUniqueInput = _JournalEntryWhereUnique_id_Input


class JournalEntryUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    referenceType: Optional[_str]
    referenceId: Optional[Union[AtomicIntInput, _int]]
    lines: 'JournalEntryLineUpdateManyWithoutRelationsInput'
    date: datetime.datetime
    updatedAt: datetime.datetime


class JournalEntryUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    referenceType: Optional[_str]
    referenceId: Optional[Union[AtomicIntInput, _int]]
    date: datetime.datetime
    updatedAt: datetime.datetime


class JournalEntryUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['JournalEntryCreateWithoutRelationsInput']
    connect: List['JournalEntryWhereUniqueInput']
    set: List['JournalEntryWhereUniqueInput']
    disconnect: List['JournalEntryWhereUniqueInput']
    delete: List['JournalEntryWhereUniqueInput']

    # TODO
    # update: List['JournalEntryUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['JournalEntryUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['JournalEntryScalarWhereInput']
    # upsert: List['JournalEntryUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['JournalEntryCreateOrConnectWithoutRelationsInput']


class JournalEntryUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'JournalEntryCreateWithoutRelationsInput'
    connect: 'JournalEntryWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'JournalEntryUpdateInput'
    # upsert: 'JournalEntryUpsertWithoutRelationsInput'
    # connectOrCreate: 'JournalEntryCreateOrConnectWithoutRelationsInput'


class JournalEntryUpsertInput(TypedDict):
    create: 'JournalEntryCreateInput'
    update: 'JournalEntryUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_JournalEntry_id_OrderByInput = TypedDict(
    '_JournalEntry_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_JournalEntry_referenceType_OrderByInput = TypedDict(
    '_JournalEntry_referenceType_OrderByInput',
    {
        'referenceType': 'SortOrder',
    },
    total=True
)

_JournalEntry_referenceId_OrderByInput = TypedDict(
    '_JournalEntry_referenceId_OrderByInput',
    {
        'referenceId': 'SortOrder',
    },
    total=True
)

_JournalEntry_date_OrderByInput = TypedDict(
    '_JournalEntry_date_OrderByInput',
    {
        'date': 'SortOrder',
    },
    total=True
)

_JournalEntry_updatedAt_OrderByInput = TypedDict(
    '_JournalEntry_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

JournalEntryOrderByInput = Union[
    '_JournalEntry_id_OrderByInput',
    '_JournalEntry_referenceType_OrderByInput',
    '_JournalEntry_referenceId_OrderByInput',
    '_JournalEntry_date_OrderByInput',
    '_JournalEntry_updatedAt_OrderByInput',
]



# recursive JournalEntry types
# TODO: cleanup these types



JournalEntryRelationFilter = TypedDict(
    'JournalEntryRelationFilter',
    {
        'is': 'JournalEntryWhereInput',
        'is_not': 'JournalEntryWhereInput',
    },
    total=False,
)


class JournalEntryListRelationFilter(TypedDict, total=False):
    some: 'JournalEntryWhereInput'
    none: 'JournalEntryWhereInput'
    every: 'JournalEntryWhereInput'


class JournalEntryInclude(TypedDict, total=False):
    """JournalEntry relational arguments"""
    lines: Union[bool, 'FindManyJournalEntryLineArgsFromJournalEntry']


class UserIncludeFromJournalEntry(TypedDict, total=False):
    """Relational arguments for JournalEntry"""
    branch: Union[bool, 'BranchArgsFromJournalEntry']
    auditLogs: Union[bool, 'FindManyAuditLogArgsFromJournalEntry']
    permissions: Union[bool, 'FindManyUserPermissionArgsFromJournalEntry']
    notifications: Union[bool, 'FindManyNotificationArgsFromJournalEntry']
    revokedTokens: Union[bool, 'FindManyRevokedTokenArgsFromJournalEntry']
    stockAdjustments: Union[bool, 'FindManyStockAdjustmentArgsFromJournalEntry']
    Sale: Union[bool, 'FindManySaleArgsFromJournalEntry']
    deletedSales: Union[bool, 'FindManySaleArgsFromJournalEntry']
    Payment: Union[bool, 'FindManyPaymentArgsFromJournalEntry']
    Backup: Union[bool, 'FindManyBackupArgsFromJournalEntry']
    requestedOrders: Union[bool, 'FindManyBranchOrderArgsFromJournalEntry']
    approvedOrders: Union[bool, 'FindManyBranchOrderArgsFromJournalEntry']
    sentOrders: Union[bool, 'FindManyBranchOrderArgsFromJournalEntry']
    receivedOrders: Union[bool, 'FindManyBranchOrderArgsFromJournalEntry']


class UserArgsFromJournalEntry(TypedDict, total=False):
    """Arguments for JournalEntry"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromJournalEntry(TypedDict, total=False):
    """Arguments for JournalEntry"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class UserPermissionIncludeFromJournalEntry(TypedDict, total=False):
    """Relational arguments for JournalEntry"""
    user: Union[bool, 'UserArgsFromJournalEntry']


class UserPermissionArgsFromJournalEntry(TypedDict, total=False):
    """Arguments for JournalEntry"""
    include: 'UserPermissionIncludeFromUserPermission'


class FindManyUserPermissionArgsFromJournalEntry(TypedDict, total=False):
    """Arguments for JournalEntry"""
    take: int
    skip: int
    order_by: Union['UserPermissionOrderByInput', List['UserPermissionOrderByInput']]
    where: 'UserPermissionWhereInput'
    cursor: 'UserPermissionWhereUniqueInput'
    distinct: List['UserPermissionScalarFieldKeys']
    include: 'UserPermissionIncludeFromUserPermission'


class BranchIncludeFromJournalEntry(TypedDict, total=False):
    """Relational arguments for JournalEntry"""
    users: Union[bool, 'FindManyUserArgsFromJournalEntry']
    Sale: Union[bool, 'FindManySaleArgsFromJournalEntry']
    Account: Union[bool, 'FindManyAccountArgsFromJournalEntry']
    BranchOrder: Union[bool, 'FindManyBranchOrderArgsFromJournalEntry']


class BranchArgsFromJournalEntry(TypedDict, total=False):
    """Arguments for JournalEntry"""
    include: 'BranchIncludeFromBranch'


class FindManyBranchArgsFromJournalEntry(TypedDict, total=False):
    """Arguments for JournalEntry"""
    take: int
    skip: int
    order_by: Union['BranchOrderByInput', List['BranchOrderByInput']]
    where: 'BranchWhereInput'
    cursor: 'BranchWhereUniqueInput'
    distinct: List['BranchScalarFieldKeys']
    include: 'BranchIncludeFromBranch'


class ProductIncludeFromJournalEntry(TypedDict, total=False):
    """Relational arguments for JournalEntry"""
    category: Union[bool, 'CategoryArgsFromJournalEntry']
    stocks: Union[bool, 'FindManyStockArgsFromJournalEntry']
    stockAdjustments: Union[bool, 'FindManyStockAdjustmentArgsFromJournalEntry']


class ProductArgsFromJournalEntry(TypedDict, total=False):
    """Arguments for JournalEntry"""
    include: 'ProductIncludeFromProduct'


class FindManyProductArgsFromJournalEntry(TypedDict, total=False):
    """Arguments for JournalEntry"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProduct'


class CategoryIncludeFromJournalEntry(TypedDict, total=False):
    """Relational arguments for JournalEntry"""
    products: Union[bool, 'FindManyProductArgsFromJournalEntry']


class CategoryArgsFromJournalEntry(TypedDict, total=False):
    """Arguments for JournalEntry"""
    include: 'CategoryIncludeFromCategory'


class FindManyCategoryArgsFromJournalEntry(TypedDict, total=False):
    """Arguments for JournalEntry"""
    take: int
    skip: int
    order_by: Union['CategoryOrderByInput', List['CategoryOrderByInput']]
    where: 'CategoryWhereInput'
    cursor: 'CategoryWhereUniqueInput'
    distinct: List['CategoryScalarFieldKeys']
    include: 'CategoryIncludeFromCategory'


class StockIncludeFromJournalEntry(TypedDict, total=False):
    """Relational arguments for JournalEntry"""
    product: Union[bool, 'ProductArgsFromJournalEntry']
    SaleItem: Union[bool, 'FindManySaleItemArgsFromJournalEntry']
    BranchOrderItem: Union[bool, 'FindManyBranchOrderItemArgsFromJournalEntry']


class StockArgsFromJournalEntry(TypedDict, total=False):
    """Arguments for JournalEntry"""
    include: 'StockIncludeFromStock'


class FindManyStockArgsFromJournalEntry(TypedDict, total=False):
    """Arguments for JournalEntry"""
    take: int
    skip: int
    order_by: Union['StockOrderByInput', List['StockOrderByInput']]
    where: 'StockWhereInput'
    cursor: 'StockWhereUniqueInput'
    distinct: List['StockScalarFieldKeys']
    include: 'StockIncludeFromStock'


class CustomerIncludeFromJournalEntry(TypedDict, total=False):
    """Relational arguments for JournalEntry"""
    Sale: Union[bool, 'FindManySaleArgsFromJournalEntry']


class CustomerArgsFromJournalEntry(TypedDict, total=False):
    """Arguments for JournalEntry"""
    include: 'CustomerIncludeFromCustomer'


class FindManyCustomerArgsFromJournalEntry(TypedDict, total=False):
    """Arguments for JournalEntry"""
    take: int
    skip: int
    order_by: Union['CustomerOrderByInput', List['CustomerOrderByInput']]
    where: 'CustomerWhereInput'
    cursor: 'CustomerWhereUniqueInput'
    distinct: List['CustomerScalarFieldKeys']
    include: 'CustomerIncludeFromCustomer'


class SaleIncludeFromJournalEntry(TypedDict, total=False):
    """Relational arguments for JournalEntry"""
    branch: Union[bool, 'BranchArgsFromJournalEntry']
    customer: Union[bool, 'CustomerArgsFromJournalEntry']
    user: Union[bool, 'UserArgsFromJournalEntry']
    items: Union[bool, 'FindManySaleItemArgsFromJournalEntry']
    payments: Union[bool, 'FindManyPaymentArgsFromJournalEntry']
    returns: Union[bool, 'FindManyReturnSaleArgsFromJournalEntry']
    deletedBy: Union[bool, 'UserArgsFromJournalEntry']


class SaleArgsFromJournalEntry(TypedDict, total=False):
    """Arguments for JournalEntry"""
    include: 'SaleIncludeFromSale'


class FindManySaleArgsFromJournalEntry(TypedDict, total=False):
    """Arguments for JournalEntry"""
    take: int
    skip: int
    order_by: Union['SaleOrderByInput', List['SaleOrderByInput']]
    where: 'SaleWhereInput'
    cursor: 'SaleWhereUniqueInput'
    distinct: List['SaleScalarFieldKeys']
    include: 'SaleIncludeFromSale'


class SaleItemIncludeFromJournalEntry(TypedDict, total=False):
    """Relational arguments for JournalEntry"""
    sale: Union[bool, 'SaleArgsFromJournalEntry']
    stock: Union[bool, 'StockArgsFromJournalEntry']
    ReturnItem: Union[bool, 'FindManyReturnItemArgsFromJournalEntry']


class SaleItemArgsFromJournalEntry(TypedDict, total=False):
    """Arguments for JournalEntry"""
    include: 'SaleItemIncludeFromSaleItem'


class FindManySaleItemArgsFromJournalEntry(TypedDict, total=False):
    """Arguments for JournalEntry"""
    take: int
    skip: int
    order_by: Union['SaleItemOrderByInput', List['SaleItemOrderByInput']]
    where: 'SaleItemWhereInput'
    cursor: 'SaleItemWhereUniqueInput'
    distinct: List['SaleItemScalarFieldKeys']
    include: 'SaleItemIncludeFromSaleItem'


class ReturnSaleIncludeFromJournalEntry(TypedDict, total=False):
    """Relational arguments for JournalEntry"""
    original: Union[bool, 'SaleArgsFromJournalEntry']
    items: Union[bool, 'FindManyReturnItemArgsFromJournalEntry']
    refund: Union[bool, 'FindManyPaymentArgsFromJournalEntry']


class ReturnSaleArgsFromJournalEntry(TypedDict, total=False):
    """Arguments for JournalEntry"""
    include: 'ReturnSaleIncludeFromReturnSale'


class FindManyReturnSaleArgsFromJournalEntry(TypedDict, total=False):
    """Arguments for JournalEntry"""
    take: int
    skip: int
    order_by: Union['ReturnSaleOrderByInput', List['ReturnSaleOrderByInput']]
    where: 'ReturnSaleWhereInput'
    cursor: 'ReturnSaleWhereUniqueInput'
    distinct: List['ReturnSaleScalarFieldKeys']
    include: 'ReturnSaleIncludeFromReturnSale'


class ReturnItemIncludeFromJournalEntry(TypedDict, total=False):
    """Relational arguments for JournalEntry"""
    returnSale: Union[bool, 'ReturnSaleArgsFromJournalEntry']
    saleItem: Union[bool, 'SaleItemArgsFromJournalEntry']


class ReturnItemArgsFromJournalEntry(TypedDict, total=False):
    """Arguments for JournalEntry"""
    include: 'ReturnItemIncludeFromReturnItem'


class FindManyReturnItemArgsFromJournalEntry(TypedDict, total=False):
    """Arguments for JournalEntry"""
    take: int
    skip: int
    order_by: Union['ReturnItemOrderByInput', List['ReturnItemOrderByInput']]
    where: 'ReturnItemWhereInput'
    cursor: 'ReturnItemWhereUniqueInput'
    distinct: List['ReturnItemScalarFieldKeys']
    include: 'ReturnItemIncludeFromReturnItem'


class PaymentIncludeFromJournalEntry(TypedDict, total=False):
    """Relational arguments for JournalEntry"""
    sale: Union[bool, 'SaleArgsFromJournalEntry']
    account: Union[bool, 'AccountArgsFromJournalEntry']
    returnSale: Union[bool, 'ReturnSaleArgsFromJournalEntry']
    user: Union[bool, 'UserArgsFromJournalEntry']


class PaymentArgsFromJournalEntry(TypedDict, total=False):
    """Arguments for JournalEntry"""
    include: 'PaymentIncludeFromPayment'


class FindManyPaymentArgsFromJournalEntry(TypedDict, total=False):
    """Arguments for JournalEntry"""
    take: int
    skip: int
    order_by: Union['PaymentOrderByInput', List['PaymentOrderByInput']]
    where: 'PaymentWhereInput'
    cursor: 'PaymentWhereUniqueInput'
    distinct: List['PaymentScalarFieldKeys']
    include: 'PaymentIncludeFromPayment'


class JournalEntryIncludeFromJournalEntry(TypedDict, total=False):
    """Relational arguments for JournalEntry"""
    lines: Union[bool, 'FindManyJournalEntryLineArgsFromJournalEntry']


class JournalEntryArgsFromJournalEntry(TypedDict, total=False):
    """Arguments for JournalEntry"""
    include: 'JournalEntryIncludeFromJournalEntry'


class FindManyJournalEntryArgsFromJournalEntry(TypedDict, total=False):
    """Arguments for JournalEntry"""
    take: int
    skip: int
    order_by: Union['JournalEntryOrderByInput', List['JournalEntryOrderByInput']]
    where: 'JournalEntryWhereInput'
    cursor: 'JournalEntryWhereUniqueInput'
    distinct: List['JournalEntryScalarFieldKeys']
    include: 'JournalEntryIncludeFromJournalEntry'


class JournalEntryLineIncludeFromJournalEntry(TypedDict, total=False):
    """Relational arguments for JournalEntry"""
    entry: Union[bool, 'JournalEntryArgsFromJournalEntry']
    account: Union[bool, 'AccountArgsFromJournalEntry']


class JournalEntryLineArgsFromJournalEntry(TypedDict, total=False):
    """Arguments for JournalEntry"""
    include: 'JournalEntryLineIncludeFromJournalEntryLine'


class FindManyJournalEntryLineArgsFromJournalEntry(TypedDict, total=False):
    """Arguments for JournalEntry"""
    take: int
    skip: int
    order_by: Union['JournalEntryLineOrderByInput', List['JournalEntryLineOrderByInput']]
    where: 'JournalEntryLineWhereInput'
    cursor: 'JournalEntryLineWhereUniqueInput'
    distinct: List['JournalEntryLineScalarFieldKeys']
    include: 'JournalEntryLineIncludeFromJournalEntryLine'


class AccountIncludeFromJournalEntry(TypedDict, total=False):
    """Relational arguments for JournalEntry"""
    branch: Union[bool, 'BranchArgsFromJournalEntry']
    entries: Union[bool, 'FindManyJournalEntryLineArgsFromJournalEntry']
    payments: Union[bool, 'FindManyPaymentArgsFromJournalEntry']
    outgoingTransfers: Union[bool, 'FindManyAccountTransferArgsFromJournalEntry']
    incomingTransfers: Union[bool, 'FindManyAccountTransferArgsFromJournalEntry']


class AccountArgsFromJournalEntry(TypedDict, total=False):
    """Arguments for JournalEntry"""
    include: 'AccountIncludeFromAccount'


class FindManyAccountArgsFromJournalEntry(TypedDict, total=False):
    """Arguments for JournalEntry"""
    take: int
    skip: int
    order_by: Union['AccountOrderByInput', List['AccountOrderByInput']]
    where: 'AccountWhereInput'
    cursor: 'AccountWhereUniqueInput'
    distinct: List['AccountScalarFieldKeys']
    include: 'AccountIncludeFromAccount'


class AccountTransferIncludeFromJournalEntry(TypedDict, total=False):
    """Relational arguments for JournalEntry"""
    fromAccount: Union[bool, 'AccountArgsFromJournalEntry']
    toAccount: Union[bool, 'AccountArgsFromJournalEntry']


class AccountTransferArgsFromJournalEntry(TypedDict, total=False):
    """Arguments for JournalEntry"""
    include: 'AccountTransferIncludeFromAccountTransfer'


class FindManyAccountTransferArgsFromJournalEntry(TypedDict, total=False):
    """Arguments for JournalEntry"""
    take: int
    skip: int
    order_by: Union['AccountTransferOrderByInput', List['AccountTransferOrderByInput']]
    where: 'AccountTransferWhereInput'
    cursor: 'AccountTransferWhereUniqueInput'
    distinct: List['AccountTransferScalarFieldKeys']
    include: 'AccountTransferIncludeFromAccountTransfer'


class BranchOrderIncludeFromJournalEntry(TypedDict, total=False):
    """Relational arguments for JournalEntry"""
    branch: Union[bool, 'BranchArgsFromJournalEntry']
    requestedBy: Union[bool, 'UserArgsFromJournalEntry']
    approvedBy: Union[bool, 'UserArgsFromJournalEntry']
    sentBy: Union[bool, 'UserArgsFromJournalEntry']
    receivedBy: Union[bool, 'UserArgsFromJournalEntry']
    items: Union[bool, 'FindManyBranchOrderItemArgsFromJournalEntry']


class BranchOrderArgsFromJournalEntry(TypedDict, total=False):
    """Arguments for JournalEntry"""
    include: 'BranchOrderIncludeFromBranchOrder'


class FindManyBranchOrderArgsFromJournalEntry(TypedDict, total=False):
    """Arguments for JournalEntry"""
    take: int
    skip: int
    order_by: Union['BranchOrderOrderByInput', List['BranchOrderOrderByInput']]
    where: 'BranchOrderWhereInput'
    cursor: 'BranchOrderWhereUniqueInput'
    distinct: List['BranchOrderScalarFieldKeys']
    include: 'BranchOrderIncludeFromBranchOrder'


class BranchOrderItemIncludeFromJournalEntry(TypedDict, total=False):
    """Relational arguments for JournalEntry"""
    branchOrder: Union[bool, 'BranchOrderArgsFromJournalEntry']
    stock: Union[bool, 'StockArgsFromJournalEntry']


class BranchOrderItemArgsFromJournalEntry(TypedDict, total=False):
    """Arguments for JournalEntry"""
    include: 'BranchOrderItemIncludeFromBranchOrderItem'


class FindManyBranchOrderItemArgsFromJournalEntry(TypedDict, total=False):
    """Arguments for JournalEntry"""
    take: int
    skip: int
    order_by: Union['BranchOrderItemOrderByInput', List['BranchOrderItemOrderByInput']]
    where: 'BranchOrderItemWhereInput'
    cursor: 'BranchOrderItemWhereUniqueInput'
    distinct: List['BranchOrderItemScalarFieldKeys']
    include: 'BranchOrderItemIncludeFromBranchOrderItem'


class AuditLogIncludeFromJournalEntry(TypedDict, total=False):
    """Relational arguments for JournalEntry"""
    user: Union[bool, 'UserArgsFromJournalEntry']


class AuditLogArgsFromJournalEntry(TypedDict, total=False):
    """Arguments for JournalEntry"""
    include: 'AuditLogIncludeFromAuditLog'


class FindManyAuditLogArgsFromJournalEntry(TypedDict, total=False):
    """Arguments for JournalEntry"""
    take: int
    skip: int
    order_by: Union['AuditLogOrderByInput', List['AuditLogOrderByInput']]
    where: 'AuditLogWhereInput'
    cursor: 'AuditLogWhereUniqueInput'
    distinct: List['AuditLogScalarFieldKeys']
    include: 'AuditLogIncludeFromAuditLog'


class SystemInfoIncludeFromJournalEntry(TypedDict, total=False):
    """Relational arguments for JournalEntry"""


class SystemInfoArgsFromJournalEntry(TypedDict, total=False):
    """Arguments for JournalEntry"""
    include: 'SystemInfoIncludeFromSystemInfo'


class FindManySystemInfoArgsFromJournalEntry(TypedDict, total=False):
    """Arguments for JournalEntry"""
    take: int
    skip: int
    order_by: Union['SystemInfoOrderByInput', List['SystemInfoOrderByInput']]
    where: 'SystemInfoWhereInput'
    cursor: 'SystemInfoWhereUniqueInput'
    distinct: List['SystemInfoScalarFieldKeys']
    include: 'SystemInfoIncludeFromSystemInfo'


class BackupIncludeFromJournalEntry(TypedDict, total=False):
    """Relational arguments for JournalEntry"""
    createdBy: Union[bool, 'UserArgsFromJournalEntry']


class BackupArgsFromJournalEntry(TypedDict, total=False):
    """Arguments for JournalEntry"""
    include: 'BackupIncludeFromBackup'


class FindManyBackupArgsFromJournalEntry(TypedDict, total=False):
    """Arguments for JournalEntry"""
    take: int
    skip: int
    order_by: Union['BackupOrderByInput', List['BackupOrderByInput']]
    where: 'BackupWhereInput'
    cursor: 'BackupWhereUniqueInput'
    distinct: List['BackupScalarFieldKeys']
    include: 'BackupIncludeFromBackup'


class RevokedTokenIncludeFromJournalEntry(TypedDict, total=False):
    """Relational arguments for JournalEntry"""
    user: Union[bool, 'UserArgsFromJournalEntry']


class RevokedTokenArgsFromJournalEntry(TypedDict, total=False):
    """Arguments for JournalEntry"""
    include: 'RevokedTokenIncludeFromRevokedToken'


class FindManyRevokedTokenArgsFromJournalEntry(TypedDict, total=False):
    """Arguments for JournalEntry"""
    take: int
    skip: int
    order_by: Union['RevokedTokenOrderByInput', List['RevokedTokenOrderByInput']]
    where: 'RevokedTokenWhereInput'
    cursor: 'RevokedTokenWhereUniqueInput'
    distinct: List['RevokedTokenScalarFieldKeys']
    include: 'RevokedTokenIncludeFromRevokedToken'


class SystemSettingIncludeFromJournalEntry(TypedDict, total=False):
    """Relational arguments for JournalEntry"""


class SystemSettingArgsFromJournalEntry(TypedDict, total=False):
    """Arguments for JournalEntry"""
    include: 'SystemSettingIncludeFromSystemSetting'


class FindManySystemSettingArgsFromJournalEntry(TypedDict, total=False):
    """Arguments for JournalEntry"""
    take: int
    skip: int
    order_by: Union['SystemSettingOrderByInput', List['SystemSettingOrderByInput']]
    where: 'SystemSettingWhereInput'
    cursor: 'SystemSettingWhereUniqueInput'
    distinct: List['SystemSettingScalarFieldKeys']
    include: 'SystemSettingIncludeFromSystemSetting'


class NotificationIncludeFromJournalEntry(TypedDict, total=False):
    """Relational arguments for JournalEntry"""
    user: Union[bool, 'UserArgsFromJournalEntry']


class NotificationArgsFromJournalEntry(TypedDict, total=False):
    """Arguments for JournalEntry"""
    include: 'NotificationIncludeFromNotification'


class FindManyNotificationArgsFromJournalEntry(TypedDict, total=False):
    """Arguments for JournalEntry"""
    take: int
    skip: int
    order_by: Union['NotificationOrderByInput', List['NotificationOrderByInput']]
    where: 'NotificationWhereInput'
    cursor: 'NotificationWhereUniqueInput'
    distinct: List['NotificationScalarFieldKeys']
    include: 'NotificationIncludeFromNotification'


class StockAdjustmentIncludeFromJournalEntry(TypedDict, total=False):
    """Relational arguments for JournalEntry"""
    product: Union[bool, 'ProductArgsFromJournalEntry']
    createdBy: Union[bool, 'UserArgsFromJournalEntry']


class StockAdjustmentArgsFromJournalEntry(TypedDict, total=False):
    """Arguments for JournalEntry"""
    include: 'StockAdjustmentIncludeFromStockAdjustment'


class FindManyStockAdjustmentArgsFromJournalEntry(TypedDict, total=False):
    """Arguments for JournalEntry"""
    take: int
    skip: int
    order_by: Union['StockAdjustmentOrderByInput', List['StockAdjustmentOrderByInput']]
    where: 'StockAdjustmentWhereInput'
    cursor: 'StockAdjustmentWhereUniqueInput'
    distinct: List['StockAdjustmentScalarFieldKeys']
    include: 'StockAdjustmentIncludeFromStockAdjustment'




FindManyJournalEntryArgs = FindManyJournalEntryArgsFromJournalEntry
FindFirstJournalEntryArgs = FindManyJournalEntryArgsFromJournalEntry


class JournalEntryWhereInput(TypedDict, total=False):
    """JournalEntry arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    referenceType: Union[None, _str, 'types.StringFilter']
    referenceId: Union[None, _int, 'types.IntFilter']
    lines: 'JournalEntryLineListRelationFilter'
    date: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['JournalEntryWhereInput', List['JournalEntryWhereInput']]
    # but this causes mypy to hang :/
    AND: List['JournalEntryWhereInput']
    OR: List['JournalEntryWhereInput']
    NOT: List['JournalEntryWhereInput']



# aggregate JournalEntry types


class JournalEntryScalarWhereWithAggregatesInput(TypedDict, total=False):
    """JournalEntry arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    referenceType: Union[_str, 'types.StringWithAggregatesFilter']
    referenceId: Union[_int, 'types.IntWithAggregatesFilter']
    date: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['JournalEntryScalarWhereWithAggregatesInput']
    OR: List['JournalEntryScalarWhereWithAggregatesInput']
    NOT: List['JournalEntryScalarWhereWithAggregatesInput']



class JournalEntryGroupByOutput(TypedDict, total=False):
    id: _int
    referenceType: _str
    referenceId: _int
    date: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'JournalEntrySumAggregateOutput'
    _avg: 'JournalEntryAvgAggregateOutput'
    _min: 'JournalEntryMinAggregateOutput'
    _max: 'JournalEntryMaxAggregateOutput'
    _count: 'JournalEntryCountAggregateOutput'


class JournalEntryAvgAggregateOutput(TypedDict, total=False):
    """JournalEntry output for aggregating averages"""
    id: float
    referenceId: float


class JournalEntrySumAggregateOutput(TypedDict, total=False):
    """JournalEntry output for aggregating sums"""
    id: _int
    referenceId: _int


class JournalEntryScalarAggregateOutput(TypedDict, total=False):
    """JournalEntry output including scalar fields"""
    id: _int
    referenceType: _str
    referenceId: _int
    date: datetime.datetime
    updatedAt: datetime.datetime


JournalEntryMinAggregateOutput = JournalEntryScalarAggregateOutput
JournalEntryMaxAggregateOutput = JournalEntryScalarAggregateOutput


class JournalEntryMaxAggregateInput(TypedDict, total=False):
    """JournalEntry input for aggregating by max"""
    id: bool
    referenceType: bool
    referenceId: bool
    date: bool
    updatedAt: bool


class JournalEntryMinAggregateInput(TypedDict, total=False):
    """JournalEntry input for aggregating by min"""
    id: bool
    referenceType: bool
    referenceId: bool
    date: bool
    updatedAt: bool


class JournalEntryNumberAggregateInput(TypedDict, total=False):
    """JournalEntry input for aggregating numbers"""
    id: bool
    referenceId: bool


JournalEntryAvgAggregateInput = JournalEntryNumberAggregateInput
JournalEntrySumAggregateInput = JournalEntryNumberAggregateInput


JournalEntryCountAggregateInput = TypedDict(
    'JournalEntryCountAggregateInput',
    {
        'id': bool,
        'referenceType': bool,
        'referenceId': bool,
        'date': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

JournalEntryCountAggregateOutput = TypedDict(
    'JournalEntryCountAggregateOutput',
    {
        'id': int,
        'referenceType': int,
        'referenceId': int,
        'date': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


JournalEntryKeys = Literal[
    'id',
    'referenceType',
    'referenceId',
    'lines',
    'date',
    'updatedAt',
]
JournalEntryScalarFieldKeys = Literal[
    'id',
    'referenceType',
    'referenceId',
    'date',
    'updatedAt',
]
JournalEntryScalarFieldKeysT = TypeVar('JournalEntryScalarFieldKeysT', bound=JournalEntryScalarFieldKeys)

JournalEntryRelationalFieldKeys = Literal[
        'lines',
    ]

# JournalEntryLine types

class JournalEntryLineOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the JournalEntryLine create method"""
    id: _int
    entryId: _int
    entry: 'JournalEntryCreateNestedWithoutRelationsInput'
    account: 'AccountCreateNestedWithoutRelationsInput'
    accountId: _int
    debit: decimal.Decimal
    credit: decimal.Decimal
    description: Optional[_str]


class JournalEntryLineCreateInput(JournalEntryLineOptionalCreateInput):
    """Required arguments to the JournalEntryLine create method"""


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class JournalEntryLineOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the JournalEntryLine create method, without relations"""
    id: _int
    entryId: _int
    accountId: _int
    debit: decimal.Decimal
    credit: decimal.Decimal
    description: Optional[_str]


class JournalEntryLineCreateWithoutRelationsInput(JournalEntryLineOptionalCreateWithoutRelationsInput):
    """Required arguments to the JournalEntryLine create method, without relations"""


class JournalEntryLineCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'JournalEntryLineCreateWithoutRelationsInput'
    connect: 'JournalEntryLineWhereUniqueInput'


class JournalEntryLineCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['JournalEntryLineCreateWithoutRelationsInput', List['JournalEntryLineCreateWithoutRelationsInput']]
    connect: Union['JournalEntryLineWhereUniqueInput', List['JournalEntryLineWhereUniqueInput']]


_JournalEntryLineWhereUnique_id_Input = TypedDict(
    '_JournalEntryLineWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

JournalEntryLineWhereUniqueInput = _JournalEntryLineWhereUnique_id_Input


class JournalEntryLineUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    entry: 'JournalEntryUpdateOneWithoutRelationsInput'
    account: 'AccountUpdateOneWithoutRelationsInput'
    debit: decimal.Decimal
    credit: decimal.Decimal
    description: Optional[_str]


class JournalEntryLineUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    debit: decimal.Decimal
    credit: decimal.Decimal
    description: Optional[_str]


class JournalEntryLineUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['JournalEntryLineCreateWithoutRelationsInput']
    connect: List['JournalEntryLineWhereUniqueInput']
    set: List['JournalEntryLineWhereUniqueInput']
    disconnect: List['JournalEntryLineWhereUniqueInput']
    delete: List['JournalEntryLineWhereUniqueInput']

    # TODO
    # update: List['JournalEntryLineUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['JournalEntryLineUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['JournalEntryLineScalarWhereInput']
    # upsert: List['JournalEntryLineUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['JournalEntryLineCreateOrConnectWithoutRelationsInput']


class JournalEntryLineUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'JournalEntryLineCreateWithoutRelationsInput'
    connect: 'JournalEntryLineWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'JournalEntryLineUpdateInput'
    # upsert: 'JournalEntryLineUpsertWithoutRelationsInput'
    # connectOrCreate: 'JournalEntryLineCreateOrConnectWithoutRelationsInput'


class JournalEntryLineUpsertInput(TypedDict):
    create: 'JournalEntryLineCreateInput'
    update: 'JournalEntryLineUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_JournalEntryLine_id_OrderByInput = TypedDict(
    '_JournalEntryLine_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_JournalEntryLine_entryId_OrderByInput = TypedDict(
    '_JournalEntryLine_entryId_OrderByInput',
    {
        'entryId': 'SortOrder',
    },
    total=True
)

_JournalEntryLine_accountId_OrderByInput = TypedDict(
    '_JournalEntryLine_accountId_OrderByInput',
    {
        'accountId': 'SortOrder',
    },
    total=True
)

_JournalEntryLine_debit_OrderByInput = TypedDict(
    '_JournalEntryLine_debit_OrderByInput',
    {
        'debit': 'SortOrder',
    },
    total=True
)

_JournalEntryLine_credit_OrderByInput = TypedDict(
    '_JournalEntryLine_credit_OrderByInput',
    {
        'credit': 'SortOrder',
    },
    total=True
)

_JournalEntryLine_description_OrderByInput = TypedDict(
    '_JournalEntryLine_description_OrderByInput',
    {
        'description': 'SortOrder',
    },
    total=True
)

JournalEntryLineOrderByInput = Union[
    '_JournalEntryLine_id_OrderByInput',
    '_JournalEntryLine_entryId_OrderByInput',
    '_JournalEntryLine_accountId_OrderByInput',
    '_JournalEntryLine_debit_OrderByInput',
    '_JournalEntryLine_credit_OrderByInput',
    '_JournalEntryLine_description_OrderByInput',
]



# recursive JournalEntryLine types
# TODO: cleanup these types



JournalEntryLineRelationFilter = TypedDict(
    'JournalEntryLineRelationFilter',
    {
        'is': 'JournalEntryLineWhereInput',
        'is_not': 'JournalEntryLineWhereInput',
    },
    total=False,
)


class JournalEntryLineListRelationFilter(TypedDict, total=False):
    some: 'JournalEntryLineWhereInput'
    none: 'JournalEntryLineWhereInput'
    every: 'JournalEntryLineWhereInput'


class JournalEntryLineInclude(TypedDict, total=False):
    """JournalEntryLine relational arguments"""
    entry: Union[bool, 'JournalEntryArgsFromJournalEntryLine']
    account: Union[bool, 'AccountArgsFromJournalEntryLine']


class UserIncludeFromJournalEntryLine(TypedDict, total=False):
    """Relational arguments for JournalEntryLine"""
    branch: Union[bool, 'BranchArgsFromJournalEntryLine']
    auditLogs: Union[bool, 'FindManyAuditLogArgsFromJournalEntryLine']
    permissions: Union[bool, 'FindManyUserPermissionArgsFromJournalEntryLine']
    notifications: Union[bool, 'FindManyNotificationArgsFromJournalEntryLine']
    revokedTokens: Union[bool, 'FindManyRevokedTokenArgsFromJournalEntryLine']
    stockAdjustments: Union[bool, 'FindManyStockAdjustmentArgsFromJournalEntryLine']
    Sale: Union[bool, 'FindManySaleArgsFromJournalEntryLine']
    deletedSales: Union[bool, 'FindManySaleArgsFromJournalEntryLine']
    Payment: Union[bool, 'FindManyPaymentArgsFromJournalEntryLine']
    Backup: Union[bool, 'FindManyBackupArgsFromJournalEntryLine']
    requestedOrders: Union[bool, 'FindManyBranchOrderArgsFromJournalEntryLine']
    approvedOrders: Union[bool, 'FindManyBranchOrderArgsFromJournalEntryLine']
    sentOrders: Union[bool, 'FindManyBranchOrderArgsFromJournalEntryLine']
    receivedOrders: Union[bool, 'FindManyBranchOrderArgsFromJournalEntryLine']


class UserArgsFromJournalEntryLine(TypedDict, total=False):
    """Arguments for JournalEntryLine"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromJournalEntryLine(TypedDict, total=False):
    """Arguments for JournalEntryLine"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class UserPermissionIncludeFromJournalEntryLine(TypedDict, total=False):
    """Relational arguments for JournalEntryLine"""
    user: Union[bool, 'UserArgsFromJournalEntryLine']


class UserPermissionArgsFromJournalEntryLine(TypedDict, total=False):
    """Arguments for JournalEntryLine"""
    include: 'UserPermissionIncludeFromUserPermission'


class FindManyUserPermissionArgsFromJournalEntryLine(TypedDict, total=False):
    """Arguments for JournalEntryLine"""
    take: int
    skip: int
    order_by: Union['UserPermissionOrderByInput', List['UserPermissionOrderByInput']]
    where: 'UserPermissionWhereInput'
    cursor: 'UserPermissionWhereUniqueInput'
    distinct: List['UserPermissionScalarFieldKeys']
    include: 'UserPermissionIncludeFromUserPermission'


class BranchIncludeFromJournalEntryLine(TypedDict, total=False):
    """Relational arguments for JournalEntryLine"""
    users: Union[bool, 'FindManyUserArgsFromJournalEntryLine']
    Sale: Union[bool, 'FindManySaleArgsFromJournalEntryLine']
    Account: Union[bool, 'FindManyAccountArgsFromJournalEntryLine']
    BranchOrder: Union[bool, 'FindManyBranchOrderArgsFromJournalEntryLine']


class BranchArgsFromJournalEntryLine(TypedDict, total=False):
    """Arguments for JournalEntryLine"""
    include: 'BranchIncludeFromBranch'


class FindManyBranchArgsFromJournalEntryLine(TypedDict, total=False):
    """Arguments for JournalEntryLine"""
    take: int
    skip: int
    order_by: Union['BranchOrderByInput', List['BranchOrderByInput']]
    where: 'BranchWhereInput'
    cursor: 'BranchWhereUniqueInput'
    distinct: List['BranchScalarFieldKeys']
    include: 'BranchIncludeFromBranch'


class ProductIncludeFromJournalEntryLine(TypedDict, total=False):
    """Relational arguments for JournalEntryLine"""
    category: Union[bool, 'CategoryArgsFromJournalEntryLine']
    stocks: Union[bool, 'FindManyStockArgsFromJournalEntryLine']
    stockAdjustments: Union[bool, 'FindManyStockAdjustmentArgsFromJournalEntryLine']


class ProductArgsFromJournalEntryLine(TypedDict, total=False):
    """Arguments for JournalEntryLine"""
    include: 'ProductIncludeFromProduct'


class FindManyProductArgsFromJournalEntryLine(TypedDict, total=False):
    """Arguments for JournalEntryLine"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProduct'


class CategoryIncludeFromJournalEntryLine(TypedDict, total=False):
    """Relational arguments for JournalEntryLine"""
    products: Union[bool, 'FindManyProductArgsFromJournalEntryLine']


class CategoryArgsFromJournalEntryLine(TypedDict, total=False):
    """Arguments for JournalEntryLine"""
    include: 'CategoryIncludeFromCategory'


class FindManyCategoryArgsFromJournalEntryLine(TypedDict, total=False):
    """Arguments for JournalEntryLine"""
    take: int
    skip: int
    order_by: Union['CategoryOrderByInput', List['CategoryOrderByInput']]
    where: 'CategoryWhereInput'
    cursor: 'CategoryWhereUniqueInput'
    distinct: List['CategoryScalarFieldKeys']
    include: 'CategoryIncludeFromCategory'


class StockIncludeFromJournalEntryLine(TypedDict, total=False):
    """Relational arguments for JournalEntryLine"""
    product: Union[bool, 'ProductArgsFromJournalEntryLine']
    SaleItem: Union[bool, 'FindManySaleItemArgsFromJournalEntryLine']
    BranchOrderItem: Union[bool, 'FindManyBranchOrderItemArgsFromJournalEntryLine']


class StockArgsFromJournalEntryLine(TypedDict, total=False):
    """Arguments for JournalEntryLine"""
    include: 'StockIncludeFromStock'


class FindManyStockArgsFromJournalEntryLine(TypedDict, total=False):
    """Arguments for JournalEntryLine"""
    take: int
    skip: int
    order_by: Union['StockOrderByInput', List['StockOrderByInput']]
    where: 'StockWhereInput'
    cursor: 'StockWhereUniqueInput'
    distinct: List['StockScalarFieldKeys']
    include: 'StockIncludeFromStock'


class CustomerIncludeFromJournalEntryLine(TypedDict, total=False):
    """Relational arguments for JournalEntryLine"""
    Sale: Union[bool, 'FindManySaleArgsFromJournalEntryLine']


class CustomerArgsFromJournalEntryLine(TypedDict, total=False):
    """Arguments for JournalEntryLine"""
    include: 'CustomerIncludeFromCustomer'


class FindManyCustomerArgsFromJournalEntryLine(TypedDict, total=False):
    """Arguments for JournalEntryLine"""
    take: int
    skip: int
    order_by: Union['CustomerOrderByInput', List['CustomerOrderByInput']]
    where: 'CustomerWhereInput'
    cursor: 'CustomerWhereUniqueInput'
    distinct: List['CustomerScalarFieldKeys']
    include: 'CustomerIncludeFromCustomer'


class SaleIncludeFromJournalEntryLine(TypedDict, total=False):
    """Relational arguments for JournalEntryLine"""
    branch: Union[bool, 'BranchArgsFromJournalEntryLine']
    customer: Union[bool, 'CustomerArgsFromJournalEntryLine']
    user: Union[bool, 'UserArgsFromJournalEntryLine']
    items: Union[bool, 'FindManySaleItemArgsFromJournalEntryLine']
    payments: Union[bool, 'FindManyPaymentArgsFromJournalEntryLine']
    returns: Union[bool, 'FindManyReturnSaleArgsFromJournalEntryLine']
    deletedBy: Union[bool, 'UserArgsFromJournalEntryLine']


class SaleArgsFromJournalEntryLine(TypedDict, total=False):
    """Arguments for JournalEntryLine"""
    include: 'SaleIncludeFromSale'


class FindManySaleArgsFromJournalEntryLine(TypedDict, total=False):
    """Arguments for JournalEntryLine"""
    take: int
    skip: int
    order_by: Union['SaleOrderByInput', List['SaleOrderByInput']]
    where: 'SaleWhereInput'
    cursor: 'SaleWhereUniqueInput'
    distinct: List['SaleScalarFieldKeys']
    include: 'SaleIncludeFromSale'


class SaleItemIncludeFromJournalEntryLine(TypedDict, total=False):
    """Relational arguments for JournalEntryLine"""
    sale: Union[bool, 'SaleArgsFromJournalEntryLine']
    stock: Union[bool, 'StockArgsFromJournalEntryLine']
    ReturnItem: Union[bool, 'FindManyReturnItemArgsFromJournalEntryLine']


class SaleItemArgsFromJournalEntryLine(TypedDict, total=False):
    """Arguments for JournalEntryLine"""
    include: 'SaleItemIncludeFromSaleItem'


class FindManySaleItemArgsFromJournalEntryLine(TypedDict, total=False):
    """Arguments for JournalEntryLine"""
    take: int
    skip: int
    order_by: Union['SaleItemOrderByInput', List['SaleItemOrderByInput']]
    where: 'SaleItemWhereInput'
    cursor: 'SaleItemWhereUniqueInput'
    distinct: List['SaleItemScalarFieldKeys']
    include: 'SaleItemIncludeFromSaleItem'


class ReturnSaleIncludeFromJournalEntryLine(TypedDict, total=False):
    """Relational arguments for JournalEntryLine"""
    original: Union[bool, 'SaleArgsFromJournalEntryLine']
    items: Union[bool, 'FindManyReturnItemArgsFromJournalEntryLine']
    refund: Union[bool, 'FindManyPaymentArgsFromJournalEntryLine']


class ReturnSaleArgsFromJournalEntryLine(TypedDict, total=False):
    """Arguments for JournalEntryLine"""
    include: 'ReturnSaleIncludeFromReturnSale'


class FindManyReturnSaleArgsFromJournalEntryLine(TypedDict, total=False):
    """Arguments for JournalEntryLine"""
    take: int
    skip: int
    order_by: Union['ReturnSaleOrderByInput', List['ReturnSaleOrderByInput']]
    where: 'ReturnSaleWhereInput'
    cursor: 'ReturnSaleWhereUniqueInput'
    distinct: List['ReturnSaleScalarFieldKeys']
    include: 'ReturnSaleIncludeFromReturnSale'


class ReturnItemIncludeFromJournalEntryLine(TypedDict, total=False):
    """Relational arguments for JournalEntryLine"""
    returnSale: Union[bool, 'ReturnSaleArgsFromJournalEntryLine']
    saleItem: Union[bool, 'SaleItemArgsFromJournalEntryLine']


class ReturnItemArgsFromJournalEntryLine(TypedDict, total=False):
    """Arguments for JournalEntryLine"""
    include: 'ReturnItemIncludeFromReturnItem'


class FindManyReturnItemArgsFromJournalEntryLine(TypedDict, total=False):
    """Arguments for JournalEntryLine"""
    take: int
    skip: int
    order_by: Union['ReturnItemOrderByInput', List['ReturnItemOrderByInput']]
    where: 'ReturnItemWhereInput'
    cursor: 'ReturnItemWhereUniqueInput'
    distinct: List['ReturnItemScalarFieldKeys']
    include: 'ReturnItemIncludeFromReturnItem'


class PaymentIncludeFromJournalEntryLine(TypedDict, total=False):
    """Relational arguments for JournalEntryLine"""
    sale: Union[bool, 'SaleArgsFromJournalEntryLine']
    account: Union[bool, 'AccountArgsFromJournalEntryLine']
    returnSale: Union[bool, 'ReturnSaleArgsFromJournalEntryLine']
    user: Union[bool, 'UserArgsFromJournalEntryLine']


class PaymentArgsFromJournalEntryLine(TypedDict, total=False):
    """Arguments for JournalEntryLine"""
    include: 'PaymentIncludeFromPayment'


class FindManyPaymentArgsFromJournalEntryLine(TypedDict, total=False):
    """Arguments for JournalEntryLine"""
    take: int
    skip: int
    order_by: Union['PaymentOrderByInput', List['PaymentOrderByInput']]
    where: 'PaymentWhereInput'
    cursor: 'PaymentWhereUniqueInput'
    distinct: List['PaymentScalarFieldKeys']
    include: 'PaymentIncludeFromPayment'


class JournalEntryIncludeFromJournalEntryLine(TypedDict, total=False):
    """Relational arguments for JournalEntryLine"""
    lines: Union[bool, 'FindManyJournalEntryLineArgsFromJournalEntryLine']


class JournalEntryArgsFromJournalEntryLine(TypedDict, total=False):
    """Arguments for JournalEntryLine"""
    include: 'JournalEntryIncludeFromJournalEntry'


class FindManyJournalEntryArgsFromJournalEntryLine(TypedDict, total=False):
    """Arguments for JournalEntryLine"""
    take: int
    skip: int
    order_by: Union['JournalEntryOrderByInput', List['JournalEntryOrderByInput']]
    where: 'JournalEntryWhereInput'
    cursor: 'JournalEntryWhereUniqueInput'
    distinct: List['JournalEntryScalarFieldKeys']
    include: 'JournalEntryIncludeFromJournalEntry'


class JournalEntryLineIncludeFromJournalEntryLine(TypedDict, total=False):
    """Relational arguments for JournalEntryLine"""
    entry: Union[bool, 'JournalEntryArgsFromJournalEntryLine']
    account: Union[bool, 'AccountArgsFromJournalEntryLine']


class JournalEntryLineArgsFromJournalEntryLine(TypedDict, total=False):
    """Arguments for JournalEntryLine"""
    include: 'JournalEntryLineIncludeFromJournalEntryLine'


class FindManyJournalEntryLineArgsFromJournalEntryLine(TypedDict, total=False):
    """Arguments for JournalEntryLine"""
    take: int
    skip: int
    order_by: Union['JournalEntryLineOrderByInput', List['JournalEntryLineOrderByInput']]
    where: 'JournalEntryLineWhereInput'
    cursor: 'JournalEntryLineWhereUniqueInput'
    distinct: List['JournalEntryLineScalarFieldKeys']
    include: 'JournalEntryLineIncludeFromJournalEntryLine'


class AccountIncludeFromJournalEntryLine(TypedDict, total=False):
    """Relational arguments for JournalEntryLine"""
    branch: Union[bool, 'BranchArgsFromJournalEntryLine']
    entries: Union[bool, 'FindManyJournalEntryLineArgsFromJournalEntryLine']
    payments: Union[bool, 'FindManyPaymentArgsFromJournalEntryLine']
    outgoingTransfers: Union[bool, 'FindManyAccountTransferArgsFromJournalEntryLine']
    incomingTransfers: Union[bool, 'FindManyAccountTransferArgsFromJournalEntryLine']


class AccountArgsFromJournalEntryLine(TypedDict, total=False):
    """Arguments for JournalEntryLine"""
    include: 'AccountIncludeFromAccount'


class FindManyAccountArgsFromJournalEntryLine(TypedDict, total=False):
    """Arguments for JournalEntryLine"""
    take: int
    skip: int
    order_by: Union['AccountOrderByInput', List['AccountOrderByInput']]
    where: 'AccountWhereInput'
    cursor: 'AccountWhereUniqueInput'
    distinct: List['AccountScalarFieldKeys']
    include: 'AccountIncludeFromAccount'


class AccountTransferIncludeFromJournalEntryLine(TypedDict, total=False):
    """Relational arguments for JournalEntryLine"""
    fromAccount: Union[bool, 'AccountArgsFromJournalEntryLine']
    toAccount: Union[bool, 'AccountArgsFromJournalEntryLine']


class AccountTransferArgsFromJournalEntryLine(TypedDict, total=False):
    """Arguments for JournalEntryLine"""
    include: 'AccountTransferIncludeFromAccountTransfer'


class FindManyAccountTransferArgsFromJournalEntryLine(TypedDict, total=False):
    """Arguments for JournalEntryLine"""
    take: int
    skip: int
    order_by: Union['AccountTransferOrderByInput', List['AccountTransferOrderByInput']]
    where: 'AccountTransferWhereInput'
    cursor: 'AccountTransferWhereUniqueInput'
    distinct: List['AccountTransferScalarFieldKeys']
    include: 'AccountTransferIncludeFromAccountTransfer'


class BranchOrderIncludeFromJournalEntryLine(TypedDict, total=False):
    """Relational arguments for JournalEntryLine"""
    branch: Union[bool, 'BranchArgsFromJournalEntryLine']
    requestedBy: Union[bool, 'UserArgsFromJournalEntryLine']
    approvedBy: Union[bool, 'UserArgsFromJournalEntryLine']
    sentBy: Union[bool, 'UserArgsFromJournalEntryLine']
    receivedBy: Union[bool, 'UserArgsFromJournalEntryLine']
    items: Union[bool, 'FindManyBranchOrderItemArgsFromJournalEntryLine']


class BranchOrderArgsFromJournalEntryLine(TypedDict, total=False):
    """Arguments for JournalEntryLine"""
    include: 'BranchOrderIncludeFromBranchOrder'


class FindManyBranchOrderArgsFromJournalEntryLine(TypedDict, total=False):
    """Arguments for JournalEntryLine"""
    take: int
    skip: int
    order_by: Union['BranchOrderOrderByInput', List['BranchOrderOrderByInput']]
    where: 'BranchOrderWhereInput'
    cursor: 'BranchOrderWhereUniqueInput'
    distinct: List['BranchOrderScalarFieldKeys']
    include: 'BranchOrderIncludeFromBranchOrder'


class BranchOrderItemIncludeFromJournalEntryLine(TypedDict, total=False):
    """Relational arguments for JournalEntryLine"""
    branchOrder: Union[bool, 'BranchOrderArgsFromJournalEntryLine']
    stock: Union[bool, 'StockArgsFromJournalEntryLine']


class BranchOrderItemArgsFromJournalEntryLine(TypedDict, total=False):
    """Arguments for JournalEntryLine"""
    include: 'BranchOrderItemIncludeFromBranchOrderItem'


class FindManyBranchOrderItemArgsFromJournalEntryLine(TypedDict, total=False):
    """Arguments for JournalEntryLine"""
    take: int
    skip: int
    order_by: Union['BranchOrderItemOrderByInput', List['BranchOrderItemOrderByInput']]
    where: 'BranchOrderItemWhereInput'
    cursor: 'BranchOrderItemWhereUniqueInput'
    distinct: List['BranchOrderItemScalarFieldKeys']
    include: 'BranchOrderItemIncludeFromBranchOrderItem'


class AuditLogIncludeFromJournalEntryLine(TypedDict, total=False):
    """Relational arguments for JournalEntryLine"""
    user: Union[bool, 'UserArgsFromJournalEntryLine']


class AuditLogArgsFromJournalEntryLine(TypedDict, total=False):
    """Arguments for JournalEntryLine"""
    include: 'AuditLogIncludeFromAuditLog'


class FindManyAuditLogArgsFromJournalEntryLine(TypedDict, total=False):
    """Arguments for JournalEntryLine"""
    take: int
    skip: int
    order_by: Union['AuditLogOrderByInput', List['AuditLogOrderByInput']]
    where: 'AuditLogWhereInput'
    cursor: 'AuditLogWhereUniqueInput'
    distinct: List['AuditLogScalarFieldKeys']
    include: 'AuditLogIncludeFromAuditLog'


class SystemInfoIncludeFromJournalEntryLine(TypedDict, total=False):
    """Relational arguments for JournalEntryLine"""


class SystemInfoArgsFromJournalEntryLine(TypedDict, total=False):
    """Arguments for JournalEntryLine"""
    include: 'SystemInfoIncludeFromSystemInfo'


class FindManySystemInfoArgsFromJournalEntryLine(TypedDict, total=False):
    """Arguments for JournalEntryLine"""
    take: int
    skip: int
    order_by: Union['SystemInfoOrderByInput', List['SystemInfoOrderByInput']]
    where: 'SystemInfoWhereInput'
    cursor: 'SystemInfoWhereUniqueInput'
    distinct: List['SystemInfoScalarFieldKeys']
    include: 'SystemInfoIncludeFromSystemInfo'


class BackupIncludeFromJournalEntryLine(TypedDict, total=False):
    """Relational arguments for JournalEntryLine"""
    createdBy: Union[bool, 'UserArgsFromJournalEntryLine']


class BackupArgsFromJournalEntryLine(TypedDict, total=False):
    """Arguments for JournalEntryLine"""
    include: 'BackupIncludeFromBackup'


class FindManyBackupArgsFromJournalEntryLine(TypedDict, total=False):
    """Arguments for JournalEntryLine"""
    take: int
    skip: int
    order_by: Union['BackupOrderByInput', List['BackupOrderByInput']]
    where: 'BackupWhereInput'
    cursor: 'BackupWhereUniqueInput'
    distinct: List['BackupScalarFieldKeys']
    include: 'BackupIncludeFromBackup'


class RevokedTokenIncludeFromJournalEntryLine(TypedDict, total=False):
    """Relational arguments for JournalEntryLine"""
    user: Union[bool, 'UserArgsFromJournalEntryLine']


class RevokedTokenArgsFromJournalEntryLine(TypedDict, total=False):
    """Arguments for JournalEntryLine"""
    include: 'RevokedTokenIncludeFromRevokedToken'


class FindManyRevokedTokenArgsFromJournalEntryLine(TypedDict, total=False):
    """Arguments for JournalEntryLine"""
    take: int
    skip: int
    order_by: Union['RevokedTokenOrderByInput', List['RevokedTokenOrderByInput']]
    where: 'RevokedTokenWhereInput'
    cursor: 'RevokedTokenWhereUniqueInput'
    distinct: List['RevokedTokenScalarFieldKeys']
    include: 'RevokedTokenIncludeFromRevokedToken'


class SystemSettingIncludeFromJournalEntryLine(TypedDict, total=False):
    """Relational arguments for JournalEntryLine"""


class SystemSettingArgsFromJournalEntryLine(TypedDict, total=False):
    """Arguments for JournalEntryLine"""
    include: 'SystemSettingIncludeFromSystemSetting'


class FindManySystemSettingArgsFromJournalEntryLine(TypedDict, total=False):
    """Arguments for JournalEntryLine"""
    take: int
    skip: int
    order_by: Union['SystemSettingOrderByInput', List['SystemSettingOrderByInput']]
    where: 'SystemSettingWhereInput'
    cursor: 'SystemSettingWhereUniqueInput'
    distinct: List['SystemSettingScalarFieldKeys']
    include: 'SystemSettingIncludeFromSystemSetting'


class NotificationIncludeFromJournalEntryLine(TypedDict, total=False):
    """Relational arguments for JournalEntryLine"""
    user: Union[bool, 'UserArgsFromJournalEntryLine']


class NotificationArgsFromJournalEntryLine(TypedDict, total=False):
    """Arguments for JournalEntryLine"""
    include: 'NotificationIncludeFromNotification'


class FindManyNotificationArgsFromJournalEntryLine(TypedDict, total=False):
    """Arguments for JournalEntryLine"""
    take: int
    skip: int
    order_by: Union['NotificationOrderByInput', List['NotificationOrderByInput']]
    where: 'NotificationWhereInput'
    cursor: 'NotificationWhereUniqueInput'
    distinct: List['NotificationScalarFieldKeys']
    include: 'NotificationIncludeFromNotification'


class StockAdjustmentIncludeFromJournalEntryLine(TypedDict, total=False):
    """Relational arguments for JournalEntryLine"""
    product: Union[bool, 'ProductArgsFromJournalEntryLine']
    createdBy: Union[bool, 'UserArgsFromJournalEntryLine']


class StockAdjustmentArgsFromJournalEntryLine(TypedDict, total=False):
    """Arguments for JournalEntryLine"""
    include: 'StockAdjustmentIncludeFromStockAdjustment'


class FindManyStockAdjustmentArgsFromJournalEntryLine(TypedDict, total=False):
    """Arguments for JournalEntryLine"""
    take: int
    skip: int
    order_by: Union['StockAdjustmentOrderByInput', List['StockAdjustmentOrderByInput']]
    where: 'StockAdjustmentWhereInput'
    cursor: 'StockAdjustmentWhereUniqueInput'
    distinct: List['StockAdjustmentScalarFieldKeys']
    include: 'StockAdjustmentIncludeFromStockAdjustment'




FindManyJournalEntryLineArgs = FindManyJournalEntryLineArgsFromJournalEntryLine
FindFirstJournalEntryLineArgs = FindManyJournalEntryLineArgsFromJournalEntryLine


class JournalEntryLineWhereInput(TypedDict, total=False):
    """JournalEntryLine arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    entryId: Union[_int, 'types.IntFilter']
    entry: 'JournalEntryRelationFilter'
    account: 'AccountRelationFilter'
    accountId: Union[_int, 'types.IntFilter']
    debit: Union[decimal.Decimal, 'types.DecimalFilter']
    credit: Union[decimal.Decimal, 'types.DecimalFilter']
    description: Union[None, _str, 'types.StringFilter']

    # should be noted that AND and NOT should be Union['JournalEntryLineWhereInput', List['JournalEntryLineWhereInput']]
    # but this causes mypy to hang :/
    AND: List['JournalEntryLineWhereInput']
    OR: List['JournalEntryLineWhereInput']
    NOT: List['JournalEntryLineWhereInput']



# aggregate JournalEntryLine types


class JournalEntryLineScalarWhereWithAggregatesInput(TypedDict, total=False):
    """JournalEntryLine arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    entryId: Union[_int, 'types.IntWithAggregatesFilter']
    accountId: Union[_int, 'types.IntWithAggregatesFilter']
    debit: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    credit: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['JournalEntryLineScalarWhereWithAggregatesInput']
    OR: List['JournalEntryLineScalarWhereWithAggregatesInput']
    NOT: List['JournalEntryLineScalarWhereWithAggregatesInput']



class JournalEntryLineGroupByOutput(TypedDict, total=False):
    id: _int
    entryId: _int
    accountId: _int
    debit: decimal.Decimal
    credit: decimal.Decimal
    description: _str
    _sum: 'JournalEntryLineSumAggregateOutput'
    _avg: 'JournalEntryLineAvgAggregateOutput'
    _min: 'JournalEntryLineMinAggregateOutput'
    _max: 'JournalEntryLineMaxAggregateOutput'
    _count: 'JournalEntryLineCountAggregateOutput'


class JournalEntryLineAvgAggregateOutput(TypedDict, total=False):
    """JournalEntryLine output for aggregating averages"""
    id: float
    entryId: float
    accountId: float


class JournalEntryLineSumAggregateOutput(TypedDict, total=False):
    """JournalEntryLine output for aggregating sums"""
    id: _int
    entryId: _int
    accountId: _int


class JournalEntryLineScalarAggregateOutput(TypedDict, total=False):
    """JournalEntryLine output including scalar fields"""
    id: _int
    entryId: _int
    accountId: _int
    debit: decimal.Decimal
    credit: decimal.Decimal
    description: _str


JournalEntryLineMinAggregateOutput = JournalEntryLineScalarAggregateOutput
JournalEntryLineMaxAggregateOutput = JournalEntryLineScalarAggregateOutput


class JournalEntryLineMaxAggregateInput(TypedDict, total=False):
    """JournalEntryLine input for aggregating by max"""
    id: bool
    entryId: bool
    accountId: bool
    debit: bool
    credit: bool
    description: bool


class JournalEntryLineMinAggregateInput(TypedDict, total=False):
    """JournalEntryLine input for aggregating by min"""
    id: bool
    entryId: bool
    accountId: bool
    debit: bool
    credit: bool
    description: bool


class JournalEntryLineNumberAggregateInput(TypedDict, total=False):
    """JournalEntryLine input for aggregating numbers"""
    id: bool
    entryId: bool
    accountId: bool


JournalEntryLineAvgAggregateInput = JournalEntryLineNumberAggregateInput
JournalEntryLineSumAggregateInput = JournalEntryLineNumberAggregateInput


JournalEntryLineCountAggregateInput = TypedDict(
    'JournalEntryLineCountAggregateInput',
    {
        'id': bool,
        'entryId': bool,
        'accountId': bool,
        'debit': bool,
        'credit': bool,
        'description': bool,
        '_all': bool,
    },
    total=False,
)

JournalEntryLineCountAggregateOutput = TypedDict(
    'JournalEntryLineCountAggregateOutput',
    {
        'id': int,
        'entryId': int,
        'accountId': int,
        'debit': int,
        'credit': int,
        'description': int,
        '_all': int,
    },
    total=False,
)


JournalEntryLineKeys = Literal[
    'id',
    'entryId',
    'entry',
    'account',
    'accountId',
    'debit',
    'credit',
    'description',
]
JournalEntryLineScalarFieldKeys = Literal[
    'id',
    'entryId',
    'accountId',
    'debit',
    'credit',
    'description',
]
JournalEntryLineScalarFieldKeysT = TypeVar('JournalEntryLineScalarFieldKeysT', bound=JournalEntryLineScalarFieldKeys)

JournalEntryLineRelationalFieldKeys = Literal[
        'entry',
        'account',
    ]

# Account types

class AccountOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Account create method"""
    id: _int
    currency: 'enums.Currency'
    balance: decimal.Decimal
    active: _bool
    branchId: Optional[_int]
    branch: 'BranchCreateNestedWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    entries: 'JournalEntryLineCreateManyNestedWithoutRelationsInput'
    payments: 'PaymentCreateManyNestedWithoutRelationsInput'
    outgoingTransfers: 'AccountTransferCreateManyNestedWithoutRelationsInput'
    incomingTransfers: 'AccountTransferCreateManyNestedWithoutRelationsInput'


class AccountCreateInput(AccountOptionalCreateInput):
    """Required arguments to the Account create method"""
    name: _str
    type: 'enums.AccountType'


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class AccountOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Account create method, without relations"""
    id: _int
    currency: 'enums.Currency'
    balance: decimal.Decimal
    active: _bool
    branchId: Optional[_int]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class AccountCreateWithoutRelationsInput(AccountOptionalCreateWithoutRelationsInput):
    """Required arguments to the Account create method, without relations"""
    name: _str
    type: 'enums.AccountType'


class AccountCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'AccountCreateWithoutRelationsInput'
    connect: 'AccountWhereUniqueInput'


class AccountCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['AccountCreateWithoutRelationsInput', List['AccountCreateWithoutRelationsInput']]
    connect: Union['AccountWhereUniqueInput', List['AccountWhereUniqueInput']]


_AccountWhereUnique_id_Input = TypedDict(
    '_AccountWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

AccountWhereUniqueInput = _AccountWhereUnique_id_Input


class AccountUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    name: _str
    type: 'enums.AccountType'
    currency: 'enums.Currency'
    balance: decimal.Decimal
    active: _bool
    branch: 'BranchUpdateOneWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    entries: 'JournalEntryLineUpdateManyWithoutRelationsInput'
    payments: 'PaymentUpdateManyWithoutRelationsInput'
    outgoingTransfers: 'AccountTransferUpdateManyWithoutRelationsInput'
    incomingTransfers: 'AccountTransferUpdateManyWithoutRelationsInput'


class AccountUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    name: _str
    type: 'enums.AccountType'
    currency: 'enums.Currency'
    balance: decimal.Decimal
    active: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class AccountUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['AccountCreateWithoutRelationsInput']
    connect: List['AccountWhereUniqueInput']
    set: List['AccountWhereUniqueInput']
    disconnect: List['AccountWhereUniqueInput']
    delete: List['AccountWhereUniqueInput']

    # TODO
    # update: List['AccountUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['AccountUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['AccountScalarWhereInput']
    # upsert: List['AccountUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['AccountCreateOrConnectWithoutRelationsInput']


class AccountUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'AccountCreateWithoutRelationsInput'
    connect: 'AccountWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'AccountUpdateInput'
    # upsert: 'AccountUpsertWithoutRelationsInput'
    # connectOrCreate: 'AccountCreateOrConnectWithoutRelationsInput'


class AccountUpsertInput(TypedDict):
    create: 'AccountCreateInput'
    update: 'AccountUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Account_id_OrderByInput = TypedDict(
    '_Account_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Account_name_OrderByInput = TypedDict(
    '_Account_name_OrderByInput',
    {
        'name': 'SortOrder',
    },
    total=True
)

_Account_type_OrderByInput = TypedDict(
    '_Account_type_OrderByInput',
    {
        'type': 'SortOrder',
    },
    total=True
)

_Account_currency_OrderByInput = TypedDict(
    '_Account_currency_OrderByInput',
    {
        'currency': 'SortOrder',
    },
    total=True
)

_Account_balance_OrderByInput = TypedDict(
    '_Account_balance_OrderByInput',
    {
        'balance': 'SortOrder',
    },
    total=True
)

_Account_active_OrderByInput = TypedDict(
    '_Account_active_OrderByInput',
    {
        'active': 'SortOrder',
    },
    total=True
)

_Account_branchId_OrderByInput = TypedDict(
    '_Account_branchId_OrderByInput',
    {
        'branchId': 'SortOrder',
    },
    total=True
)

_Account_createdAt_OrderByInput = TypedDict(
    '_Account_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Account_updatedAt_OrderByInput = TypedDict(
    '_Account_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

AccountOrderByInput = Union[
    '_Account_id_OrderByInput',
    '_Account_name_OrderByInput',
    '_Account_type_OrderByInput',
    '_Account_currency_OrderByInput',
    '_Account_balance_OrderByInput',
    '_Account_active_OrderByInput',
    '_Account_branchId_OrderByInput',
    '_Account_createdAt_OrderByInput',
    '_Account_updatedAt_OrderByInput',
]



# recursive Account types
# TODO: cleanup these types



AccountRelationFilter = TypedDict(
    'AccountRelationFilter',
    {
        'is': 'AccountWhereInput',
        'is_not': 'AccountWhereInput',
    },
    total=False,
)


class AccountListRelationFilter(TypedDict, total=False):
    some: 'AccountWhereInput'
    none: 'AccountWhereInput'
    every: 'AccountWhereInput'


class AccountInclude(TypedDict, total=False):
    """Account relational arguments"""
    branch: Union[bool, 'BranchArgsFromAccount']
    entries: Union[bool, 'FindManyJournalEntryLineArgsFromAccount']
    payments: Union[bool, 'FindManyPaymentArgsFromAccount']
    outgoingTransfers: Union[bool, 'FindManyAccountTransferArgsFromAccount']
    incomingTransfers: Union[bool, 'FindManyAccountTransferArgsFromAccount']


class UserIncludeFromAccount(TypedDict, total=False):
    """Relational arguments for Account"""
    branch: Union[bool, 'BranchArgsFromAccount']
    auditLogs: Union[bool, 'FindManyAuditLogArgsFromAccount']
    permissions: Union[bool, 'FindManyUserPermissionArgsFromAccount']
    notifications: Union[bool, 'FindManyNotificationArgsFromAccount']
    revokedTokens: Union[bool, 'FindManyRevokedTokenArgsFromAccount']
    stockAdjustments: Union[bool, 'FindManyStockAdjustmentArgsFromAccount']
    Sale: Union[bool, 'FindManySaleArgsFromAccount']
    deletedSales: Union[bool, 'FindManySaleArgsFromAccount']
    Payment: Union[bool, 'FindManyPaymentArgsFromAccount']
    Backup: Union[bool, 'FindManyBackupArgsFromAccount']
    requestedOrders: Union[bool, 'FindManyBranchOrderArgsFromAccount']
    approvedOrders: Union[bool, 'FindManyBranchOrderArgsFromAccount']
    sentOrders: Union[bool, 'FindManyBranchOrderArgsFromAccount']
    receivedOrders: Union[bool, 'FindManyBranchOrderArgsFromAccount']


class UserArgsFromAccount(TypedDict, total=False):
    """Arguments for Account"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromAccount(TypedDict, total=False):
    """Arguments for Account"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class UserPermissionIncludeFromAccount(TypedDict, total=False):
    """Relational arguments for Account"""
    user: Union[bool, 'UserArgsFromAccount']


class UserPermissionArgsFromAccount(TypedDict, total=False):
    """Arguments for Account"""
    include: 'UserPermissionIncludeFromUserPermission'


class FindManyUserPermissionArgsFromAccount(TypedDict, total=False):
    """Arguments for Account"""
    take: int
    skip: int
    order_by: Union['UserPermissionOrderByInput', List['UserPermissionOrderByInput']]
    where: 'UserPermissionWhereInput'
    cursor: 'UserPermissionWhereUniqueInput'
    distinct: List['UserPermissionScalarFieldKeys']
    include: 'UserPermissionIncludeFromUserPermission'


class BranchIncludeFromAccount(TypedDict, total=False):
    """Relational arguments for Account"""
    users: Union[bool, 'FindManyUserArgsFromAccount']
    Sale: Union[bool, 'FindManySaleArgsFromAccount']
    Account: Union[bool, 'FindManyAccountArgsFromAccount']
    BranchOrder: Union[bool, 'FindManyBranchOrderArgsFromAccount']


class BranchArgsFromAccount(TypedDict, total=False):
    """Arguments for Account"""
    include: 'BranchIncludeFromBranch'


class FindManyBranchArgsFromAccount(TypedDict, total=False):
    """Arguments for Account"""
    take: int
    skip: int
    order_by: Union['BranchOrderByInput', List['BranchOrderByInput']]
    where: 'BranchWhereInput'
    cursor: 'BranchWhereUniqueInput'
    distinct: List['BranchScalarFieldKeys']
    include: 'BranchIncludeFromBranch'


class ProductIncludeFromAccount(TypedDict, total=False):
    """Relational arguments for Account"""
    category: Union[bool, 'CategoryArgsFromAccount']
    stocks: Union[bool, 'FindManyStockArgsFromAccount']
    stockAdjustments: Union[bool, 'FindManyStockAdjustmentArgsFromAccount']


class ProductArgsFromAccount(TypedDict, total=False):
    """Arguments for Account"""
    include: 'ProductIncludeFromProduct'


class FindManyProductArgsFromAccount(TypedDict, total=False):
    """Arguments for Account"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProduct'


class CategoryIncludeFromAccount(TypedDict, total=False):
    """Relational arguments for Account"""
    products: Union[bool, 'FindManyProductArgsFromAccount']


class CategoryArgsFromAccount(TypedDict, total=False):
    """Arguments for Account"""
    include: 'CategoryIncludeFromCategory'


class FindManyCategoryArgsFromAccount(TypedDict, total=False):
    """Arguments for Account"""
    take: int
    skip: int
    order_by: Union['CategoryOrderByInput', List['CategoryOrderByInput']]
    where: 'CategoryWhereInput'
    cursor: 'CategoryWhereUniqueInput'
    distinct: List['CategoryScalarFieldKeys']
    include: 'CategoryIncludeFromCategory'


class StockIncludeFromAccount(TypedDict, total=False):
    """Relational arguments for Account"""
    product: Union[bool, 'ProductArgsFromAccount']
    SaleItem: Union[bool, 'FindManySaleItemArgsFromAccount']
    BranchOrderItem: Union[bool, 'FindManyBranchOrderItemArgsFromAccount']


class StockArgsFromAccount(TypedDict, total=False):
    """Arguments for Account"""
    include: 'StockIncludeFromStock'


class FindManyStockArgsFromAccount(TypedDict, total=False):
    """Arguments for Account"""
    take: int
    skip: int
    order_by: Union['StockOrderByInput', List['StockOrderByInput']]
    where: 'StockWhereInput'
    cursor: 'StockWhereUniqueInput'
    distinct: List['StockScalarFieldKeys']
    include: 'StockIncludeFromStock'


class CustomerIncludeFromAccount(TypedDict, total=False):
    """Relational arguments for Account"""
    Sale: Union[bool, 'FindManySaleArgsFromAccount']


class CustomerArgsFromAccount(TypedDict, total=False):
    """Arguments for Account"""
    include: 'CustomerIncludeFromCustomer'


class FindManyCustomerArgsFromAccount(TypedDict, total=False):
    """Arguments for Account"""
    take: int
    skip: int
    order_by: Union['CustomerOrderByInput', List['CustomerOrderByInput']]
    where: 'CustomerWhereInput'
    cursor: 'CustomerWhereUniqueInput'
    distinct: List['CustomerScalarFieldKeys']
    include: 'CustomerIncludeFromCustomer'


class SaleIncludeFromAccount(TypedDict, total=False):
    """Relational arguments for Account"""
    branch: Union[bool, 'BranchArgsFromAccount']
    customer: Union[bool, 'CustomerArgsFromAccount']
    user: Union[bool, 'UserArgsFromAccount']
    items: Union[bool, 'FindManySaleItemArgsFromAccount']
    payments: Union[bool, 'FindManyPaymentArgsFromAccount']
    returns: Union[bool, 'FindManyReturnSaleArgsFromAccount']
    deletedBy: Union[bool, 'UserArgsFromAccount']


class SaleArgsFromAccount(TypedDict, total=False):
    """Arguments for Account"""
    include: 'SaleIncludeFromSale'


class FindManySaleArgsFromAccount(TypedDict, total=False):
    """Arguments for Account"""
    take: int
    skip: int
    order_by: Union['SaleOrderByInput', List['SaleOrderByInput']]
    where: 'SaleWhereInput'
    cursor: 'SaleWhereUniqueInput'
    distinct: List['SaleScalarFieldKeys']
    include: 'SaleIncludeFromSale'


class SaleItemIncludeFromAccount(TypedDict, total=False):
    """Relational arguments for Account"""
    sale: Union[bool, 'SaleArgsFromAccount']
    stock: Union[bool, 'StockArgsFromAccount']
    ReturnItem: Union[bool, 'FindManyReturnItemArgsFromAccount']


class SaleItemArgsFromAccount(TypedDict, total=False):
    """Arguments for Account"""
    include: 'SaleItemIncludeFromSaleItem'


class FindManySaleItemArgsFromAccount(TypedDict, total=False):
    """Arguments for Account"""
    take: int
    skip: int
    order_by: Union['SaleItemOrderByInput', List['SaleItemOrderByInput']]
    where: 'SaleItemWhereInput'
    cursor: 'SaleItemWhereUniqueInput'
    distinct: List['SaleItemScalarFieldKeys']
    include: 'SaleItemIncludeFromSaleItem'


class ReturnSaleIncludeFromAccount(TypedDict, total=False):
    """Relational arguments for Account"""
    original: Union[bool, 'SaleArgsFromAccount']
    items: Union[bool, 'FindManyReturnItemArgsFromAccount']
    refund: Union[bool, 'FindManyPaymentArgsFromAccount']


class ReturnSaleArgsFromAccount(TypedDict, total=False):
    """Arguments for Account"""
    include: 'ReturnSaleIncludeFromReturnSale'


class FindManyReturnSaleArgsFromAccount(TypedDict, total=False):
    """Arguments for Account"""
    take: int
    skip: int
    order_by: Union['ReturnSaleOrderByInput', List['ReturnSaleOrderByInput']]
    where: 'ReturnSaleWhereInput'
    cursor: 'ReturnSaleWhereUniqueInput'
    distinct: List['ReturnSaleScalarFieldKeys']
    include: 'ReturnSaleIncludeFromReturnSale'


class ReturnItemIncludeFromAccount(TypedDict, total=False):
    """Relational arguments for Account"""
    returnSale: Union[bool, 'ReturnSaleArgsFromAccount']
    saleItem: Union[bool, 'SaleItemArgsFromAccount']


class ReturnItemArgsFromAccount(TypedDict, total=False):
    """Arguments for Account"""
    include: 'ReturnItemIncludeFromReturnItem'


class FindManyReturnItemArgsFromAccount(TypedDict, total=False):
    """Arguments for Account"""
    take: int
    skip: int
    order_by: Union['ReturnItemOrderByInput', List['ReturnItemOrderByInput']]
    where: 'ReturnItemWhereInput'
    cursor: 'ReturnItemWhereUniqueInput'
    distinct: List['ReturnItemScalarFieldKeys']
    include: 'ReturnItemIncludeFromReturnItem'


class PaymentIncludeFromAccount(TypedDict, total=False):
    """Relational arguments for Account"""
    sale: Union[bool, 'SaleArgsFromAccount']
    account: Union[bool, 'AccountArgsFromAccount']
    returnSale: Union[bool, 'ReturnSaleArgsFromAccount']
    user: Union[bool, 'UserArgsFromAccount']


class PaymentArgsFromAccount(TypedDict, total=False):
    """Arguments for Account"""
    include: 'PaymentIncludeFromPayment'


class FindManyPaymentArgsFromAccount(TypedDict, total=False):
    """Arguments for Account"""
    take: int
    skip: int
    order_by: Union['PaymentOrderByInput', List['PaymentOrderByInput']]
    where: 'PaymentWhereInput'
    cursor: 'PaymentWhereUniqueInput'
    distinct: List['PaymentScalarFieldKeys']
    include: 'PaymentIncludeFromPayment'


class JournalEntryIncludeFromAccount(TypedDict, total=False):
    """Relational arguments for Account"""
    lines: Union[bool, 'FindManyJournalEntryLineArgsFromAccount']


class JournalEntryArgsFromAccount(TypedDict, total=False):
    """Arguments for Account"""
    include: 'JournalEntryIncludeFromJournalEntry'


class FindManyJournalEntryArgsFromAccount(TypedDict, total=False):
    """Arguments for Account"""
    take: int
    skip: int
    order_by: Union['JournalEntryOrderByInput', List['JournalEntryOrderByInput']]
    where: 'JournalEntryWhereInput'
    cursor: 'JournalEntryWhereUniqueInput'
    distinct: List['JournalEntryScalarFieldKeys']
    include: 'JournalEntryIncludeFromJournalEntry'


class JournalEntryLineIncludeFromAccount(TypedDict, total=False):
    """Relational arguments for Account"""
    entry: Union[bool, 'JournalEntryArgsFromAccount']
    account: Union[bool, 'AccountArgsFromAccount']


class JournalEntryLineArgsFromAccount(TypedDict, total=False):
    """Arguments for Account"""
    include: 'JournalEntryLineIncludeFromJournalEntryLine'


class FindManyJournalEntryLineArgsFromAccount(TypedDict, total=False):
    """Arguments for Account"""
    take: int
    skip: int
    order_by: Union['JournalEntryLineOrderByInput', List['JournalEntryLineOrderByInput']]
    where: 'JournalEntryLineWhereInput'
    cursor: 'JournalEntryLineWhereUniqueInput'
    distinct: List['JournalEntryLineScalarFieldKeys']
    include: 'JournalEntryLineIncludeFromJournalEntryLine'


class AccountIncludeFromAccount(TypedDict, total=False):
    """Relational arguments for Account"""
    branch: Union[bool, 'BranchArgsFromAccount']
    entries: Union[bool, 'FindManyJournalEntryLineArgsFromAccount']
    payments: Union[bool, 'FindManyPaymentArgsFromAccount']
    outgoingTransfers: Union[bool, 'FindManyAccountTransferArgsFromAccount']
    incomingTransfers: Union[bool, 'FindManyAccountTransferArgsFromAccount']


class AccountArgsFromAccount(TypedDict, total=False):
    """Arguments for Account"""
    include: 'AccountIncludeFromAccount'


class FindManyAccountArgsFromAccount(TypedDict, total=False):
    """Arguments for Account"""
    take: int
    skip: int
    order_by: Union['AccountOrderByInput', List['AccountOrderByInput']]
    where: 'AccountWhereInput'
    cursor: 'AccountWhereUniqueInput'
    distinct: List['AccountScalarFieldKeys']
    include: 'AccountIncludeFromAccount'


class AccountTransferIncludeFromAccount(TypedDict, total=False):
    """Relational arguments for Account"""
    fromAccount: Union[bool, 'AccountArgsFromAccount']
    toAccount: Union[bool, 'AccountArgsFromAccount']


class AccountTransferArgsFromAccount(TypedDict, total=False):
    """Arguments for Account"""
    include: 'AccountTransferIncludeFromAccountTransfer'


class FindManyAccountTransferArgsFromAccount(TypedDict, total=False):
    """Arguments for Account"""
    take: int
    skip: int
    order_by: Union['AccountTransferOrderByInput', List['AccountTransferOrderByInput']]
    where: 'AccountTransferWhereInput'
    cursor: 'AccountTransferWhereUniqueInput'
    distinct: List['AccountTransferScalarFieldKeys']
    include: 'AccountTransferIncludeFromAccountTransfer'


class BranchOrderIncludeFromAccount(TypedDict, total=False):
    """Relational arguments for Account"""
    branch: Union[bool, 'BranchArgsFromAccount']
    requestedBy: Union[bool, 'UserArgsFromAccount']
    approvedBy: Union[bool, 'UserArgsFromAccount']
    sentBy: Union[bool, 'UserArgsFromAccount']
    receivedBy: Union[bool, 'UserArgsFromAccount']
    items: Union[bool, 'FindManyBranchOrderItemArgsFromAccount']


class BranchOrderArgsFromAccount(TypedDict, total=False):
    """Arguments for Account"""
    include: 'BranchOrderIncludeFromBranchOrder'


class FindManyBranchOrderArgsFromAccount(TypedDict, total=False):
    """Arguments for Account"""
    take: int
    skip: int
    order_by: Union['BranchOrderOrderByInput', List['BranchOrderOrderByInput']]
    where: 'BranchOrderWhereInput'
    cursor: 'BranchOrderWhereUniqueInput'
    distinct: List['BranchOrderScalarFieldKeys']
    include: 'BranchOrderIncludeFromBranchOrder'


class BranchOrderItemIncludeFromAccount(TypedDict, total=False):
    """Relational arguments for Account"""
    branchOrder: Union[bool, 'BranchOrderArgsFromAccount']
    stock: Union[bool, 'StockArgsFromAccount']


class BranchOrderItemArgsFromAccount(TypedDict, total=False):
    """Arguments for Account"""
    include: 'BranchOrderItemIncludeFromBranchOrderItem'


class FindManyBranchOrderItemArgsFromAccount(TypedDict, total=False):
    """Arguments for Account"""
    take: int
    skip: int
    order_by: Union['BranchOrderItemOrderByInput', List['BranchOrderItemOrderByInput']]
    where: 'BranchOrderItemWhereInput'
    cursor: 'BranchOrderItemWhereUniqueInput'
    distinct: List['BranchOrderItemScalarFieldKeys']
    include: 'BranchOrderItemIncludeFromBranchOrderItem'


class AuditLogIncludeFromAccount(TypedDict, total=False):
    """Relational arguments for Account"""
    user: Union[bool, 'UserArgsFromAccount']


class AuditLogArgsFromAccount(TypedDict, total=False):
    """Arguments for Account"""
    include: 'AuditLogIncludeFromAuditLog'


class FindManyAuditLogArgsFromAccount(TypedDict, total=False):
    """Arguments for Account"""
    take: int
    skip: int
    order_by: Union['AuditLogOrderByInput', List['AuditLogOrderByInput']]
    where: 'AuditLogWhereInput'
    cursor: 'AuditLogWhereUniqueInput'
    distinct: List['AuditLogScalarFieldKeys']
    include: 'AuditLogIncludeFromAuditLog'


class SystemInfoIncludeFromAccount(TypedDict, total=False):
    """Relational arguments for Account"""


class SystemInfoArgsFromAccount(TypedDict, total=False):
    """Arguments for Account"""
    include: 'SystemInfoIncludeFromSystemInfo'


class FindManySystemInfoArgsFromAccount(TypedDict, total=False):
    """Arguments for Account"""
    take: int
    skip: int
    order_by: Union['SystemInfoOrderByInput', List['SystemInfoOrderByInput']]
    where: 'SystemInfoWhereInput'
    cursor: 'SystemInfoWhereUniqueInput'
    distinct: List['SystemInfoScalarFieldKeys']
    include: 'SystemInfoIncludeFromSystemInfo'


class BackupIncludeFromAccount(TypedDict, total=False):
    """Relational arguments for Account"""
    createdBy: Union[bool, 'UserArgsFromAccount']


class BackupArgsFromAccount(TypedDict, total=False):
    """Arguments for Account"""
    include: 'BackupIncludeFromBackup'


class FindManyBackupArgsFromAccount(TypedDict, total=False):
    """Arguments for Account"""
    take: int
    skip: int
    order_by: Union['BackupOrderByInput', List['BackupOrderByInput']]
    where: 'BackupWhereInput'
    cursor: 'BackupWhereUniqueInput'
    distinct: List['BackupScalarFieldKeys']
    include: 'BackupIncludeFromBackup'


class RevokedTokenIncludeFromAccount(TypedDict, total=False):
    """Relational arguments for Account"""
    user: Union[bool, 'UserArgsFromAccount']


class RevokedTokenArgsFromAccount(TypedDict, total=False):
    """Arguments for Account"""
    include: 'RevokedTokenIncludeFromRevokedToken'


class FindManyRevokedTokenArgsFromAccount(TypedDict, total=False):
    """Arguments for Account"""
    take: int
    skip: int
    order_by: Union['RevokedTokenOrderByInput', List['RevokedTokenOrderByInput']]
    where: 'RevokedTokenWhereInput'
    cursor: 'RevokedTokenWhereUniqueInput'
    distinct: List['RevokedTokenScalarFieldKeys']
    include: 'RevokedTokenIncludeFromRevokedToken'


class SystemSettingIncludeFromAccount(TypedDict, total=False):
    """Relational arguments for Account"""


class SystemSettingArgsFromAccount(TypedDict, total=False):
    """Arguments for Account"""
    include: 'SystemSettingIncludeFromSystemSetting'


class FindManySystemSettingArgsFromAccount(TypedDict, total=False):
    """Arguments for Account"""
    take: int
    skip: int
    order_by: Union['SystemSettingOrderByInput', List['SystemSettingOrderByInput']]
    where: 'SystemSettingWhereInput'
    cursor: 'SystemSettingWhereUniqueInput'
    distinct: List['SystemSettingScalarFieldKeys']
    include: 'SystemSettingIncludeFromSystemSetting'


class NotificationIncludeFromAccount(TypedDict, total=False):
    """Relational arguments for Account"""
    user: Union[bool, 'UserArgsFromAccount']


class NotificationArgsFromAccount(TypedDict, total=False):
    """Arguments for Account"""
    include: 'NotificationIncludeFromNotification'


class FindManyNotificationArgsFromAccount(TypedDict, total=False):
    """Arguments for Account"""
    take: int
    skip: int
    order_by: Union['NotificationOrderByInput', List['NotificationOrderByInput']]
    where: 'NotificationWhereInput'
    cursor: 'NotificationWhereUniqueInput'
    distinct: List['NotificationScalarFieldKeys']
    include: 'NotificationIncludeFromNotification'


class StockAdjustmentIncludeFromAccount(TypedDict, total=False):
    """Relational arguments for Account"""
    product: Union[bool, 'ProductArgsFromAccount']
    createdBy: Union[bool, 'UserArgsFromAccount']


class StockAdjustmentArgsFromAccount(TypedDict, total=False):
    """Arguments for Account"""
    include: 'StockAdjustmentIncludeFromStockAdjustment'


class FindManyStockAdjustmentArgsFromAccount(TypedDict, total=False):
    """Arguments for Account"""
    take: int
    skip: int
    order_by: Union['StockAdjustmentOrderByInput', List['StockAdjustmentOrderByInput']]
    where: 'StockAdjustmentWhereInput'
    cursor: 'StockAdjustmentWhereUniqueInput'
    distinct: List['StockAdjustmentScalarFieldKeys']
    include: 'StockAdjustmentIncludeFromStockAdjustment'




FindManyAccountArgs = FindManyAccountArgsFromAccount
FindFirstAccountArgs = FindManyAccountArgsFromAccount


class AccountWhereInput(TypedDict, total=False):
    """Account arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    name: Union[_str, 'types.StringFilter']
    type: 'enums.AccountType'
    currency: 'enums.Currency'
    balance: Union[decimal.Decimal, 'types.DecimalFilter']
    active: Union[_bool, 'types.BooleanFilter']
    branchId: Union[None, _int, 'types.IntFilter']
    branch: 'BranchRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    entries: 'JournalEntryLineListRelationFilter'
    payments: 'PaymentListRelationFilter'
    outgoingTransfers: 'AccountTransferListRelationFilter'
    incomingTransfers: 'AccountTransferListRelationFilter'

    # should be noted that AND and NOT should be Union['AccountWhereInput', List['AccountWhereInput']]
    # but this causes mypy to hang :/
    AND: List['AccountWhereInput']
    OR: List['AccountWhereInput']
    NOT: List['AccountWhereInput']



# aggregate Account types


class AccountScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Account arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    type: 'enums.AccountType'
    currency: 'enums.Currency'
    balance: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    active: Union[_bool, 'types.BooleanWithAggregatesFilter']
    branchId: Union[_int, 'types.IntWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['AccountScalarWhereWithAggregatesInput']
    OR: List['AccountScalarWhereWithAggregatesInput']
    NOT: List['AccountScalarWhereWithAggregatesInput']



class AccountGroupByOutput(TypedDict, total=False):
    id: _int
    name: _str
    type: 'enums.AccountType'
    currency: 'enums.Currency'
    balance: decimal.Decimal
    active: _bool
    branchId: _int
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'AccountSumAggregateOutput'
    _avg: 'AccountAvgAggregateOutput'
    _min: 'AccountMinAggregateOutput'
    _max: 'AccountMaxAggregateOutput'
    _count: 'AccountCountAggregateOutput'


class AccountAvgAggregateOutput(TypedDict, total=False):
    """Account output for aggregating averages"""
    id: float
    branchId: float


class AccountSumAggregateOutput(TypedDict, total=False):
    """Account output for aggregating sums"""
    id: _int
    branchId: _int


class AccountScalarAggregateOutput(TypedDict, total=False):
    """Account output including scalar fields"""
    id: _int
    name: _str
    type: 'enums.AccountType'
    currency: 'enums.Currency'
    balance: decimal.Decimal
    active: _bool
    branchId: _int
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


AccountMinAggregateOutput = AccountScalarAggregateOutput
AccountMaxAggregateOutput = AccountScalarAggregateOutput


class AccountMaxAggregateInput(TypedDict, total=False):
    """Account input for aggregating by max"""
    id: bool
    name: bool
    type: bool
    currency: bool
    balance: bool
    active: bool
    branchId: bool
    createdAt: bool
    updatedAt: bool


class AccountMinAggregateInput(TypedDict, total=False):
    """Account input for aggregating by min"""
    id: bool
    name: bool
    type: bool
    currency: bool
    balance: bool
    active: bool
    branchId: bool
    createdAt: bool
    updatedAt: bool


class AccountNumberAggregateInput(TypedDict, total=False):
    """Account input for aggregating numbers"""
    id: bool
    branchId: bool


AccountAvgAggregateInput = AccountNumberAggregateInput
AccountSumAggregateInput = AccountNumberAggregateInput


AccountCountAggregateInput = TypedDict(
    'AccountCountAggregateInput',
    {
        'id': bool,
        'name': bool,
        'type': bool,
        'currency': bool,
        'balance': bool,
        'active': bool,
        'branchId': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

AccountCountAggregateOutput = TypedDict(
    'AccountCountAggregateOutput',
    {
        'id': int,
        'name': int,
        'type': int,
        'currency': int,
        'balance': int,
        'active': int,
        'branchId': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


AccountKeys = Literal[
    'id',
    'name',
    'type',
    'currency',
    'balance',
    'active',
    'branchId',
    'branch',
    'createdAt',
    'updatedAt',
    'entries',
    'payments',
    'outgoingTransfers',
    'incomingTransfers',
]
AccountScalarFieldKeys = Literal[
    'id',
    'name',
    'type',
    'currency',
    'balance',
    'active',
    'branchId',
    'createdAt',
    'updatedAt',
]
AccountScalarFieldKeysT = TypeVar('AccountScalarFieldKeysT', bound=AccountScalarFieldKeys)

AccountRelationalFieldKeys = Literal[
        'branch',
        'entries',
        'payments',
        'outgoingTransfers',
        'incomingTransfers',
    ]

# AccountTransfer types

class AccountTransferOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the AccountTransfer create method"""
    id: _int
    fromAccount: 'AccountCreateNestedWithoutRelationsInput'
    fromAccountId: _int
    toAccount: 'AccountCreateNestedWithoutRelationsInput'
    toAccountId: _int
    rateApplied: Optional[decimal.Decimal]
    note: Optional[_str]
    status: 'enums.TransferStatus'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class AccountTransferCreateInput(AccountTransferOptionalCreateInput):
    """Required arguments to the AccountTransfer create method"""
    amount: decimal.Decimal
    currency: 'enums.Currency'


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class AccountTransferOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the AccountTransfer create method, without relations"""
    id: _int
    fromAccountId: _int
    toAccountId: _int
    rateApplied: Optional[decimal.Decimal]
    note: Optional[_str]
    status: 'enums.TransferStatus'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class AccountTransferCreateWithoutRelationsInput(AccountTransferOptionalCreateWithoutRelationsInput):
    """Required arguments to the AccountTransfer create method, without relations"""
    amount: decimal.Decimal
    currency: 'enums.Currency'


class AccountTransferCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'AccountTransferCreateWithoutRelationsInput'
    connect: 'AccountTransferWhereUniqueInput'


class AccountTransferCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['AccountTransferCreateWithoutRelationsInput', List['AccountTransferCreateWithoutRelationsInput']]
    connect: Union['AccountTransferWhereUniqueInput', List['AccountTransferWhereUniqueInput']]


_AccountTransferWhereUnique_id_Input = TypedDict(
    '_AccountTransferWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

AccountTransferWhereUniqueInput = _AccountTransferWhereUnique_id_Input


class AccountTransferUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    fromAccount: 'AccountUpdateOneWithoutRelationsInput'
    toAccount: 'AccountUpdateOneWithoutRelationsInput'
    amount: decimal.Decimal
    currency: 'enums.Currency'
    rateApplied: Optional[decimal.Decimal]
    note: Optional[_str]
    status: 'enums.TransferStatus'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class AccountTransferUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    amount: decimal.Decimal
    currency: 'enums.Currency'
    rateApplied: Optional[decimal.Decimal]
    note: Optional[_str]
    status: 'enums.TransferStatus'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class AccountTransferUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['AccountTransferCreateWithoutRelationsInput']
    connect: List['AccountTransferWhereUniqueInput']
    set: List['AccountTransferWhereUniqueInput']
    disconnect: List['AccountTransferWhereUniqueInput']
    delete: List['AccountTransferWhereUniqueInput']

    # TODO
    # update: List['AccountTransferUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['AccountTransferUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['AccountTransferScalarWhereInput']
    # upsert: List['AccountTransferUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['AccountTransferCreateOrConnectWithoutRelationsInput']


class AccountTransferUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'AccountTransferCreateWithoutRelationsInput'
    connect: 'AccountTransferWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'AccountTransferUpdateInput'
    # upsert: 'AccountTransferUpsertWithoutRelationsInput'
    # connectOrCreate: 'AccountTransferCreateOrConnectWithoutRelationsInput'


class AccountTransferUpsertInput(TypedDict):
    create: 'AccountTransferCreateInput'
    update: 'AccountTransferUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_AccountTransfer_id_OrderByInput = TypedDict(
    '_AccountTransfer_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_AccountTransfer_fromAccountId_OrderByInput = TypedDict(
    '_AccountTransfer_fromAccountId_OrderByInput',
    {
        'fromAccountId': 'SortOrder',
    },
    total=True
)

_AccountTransfer_toAccountId_OrderByInput = TypedDict(
    '_AccountTransfer_toAccountId_OrderByInput',
    {
        'toAccountId': 'SortOrder',
    },
    total=True
)

_AccountTransfer_amount_OrderByInput = TypedDict(
    '_AccountTransfer_amount_OrderByInput',
    {
        'amount': 'SortOrder',
    },
    total=True
)

_AccountTransfer_currency_OrderByInput = TypedDict(
    '_AccountTransfer_currency_OrderByInput',
    {
        'currency': 'SortOrder',
    },
    total=True
)

_AccountTransfer_rateApplied_OrderByInput = TypedDict(
    '_AccountTransfer_rateApplied_OrderByInput',
    {
        'rateApplied': 'SortOrder',
    },
    total=True
)

_AccountTransfer_note_OrderByInput = TypedDict(
    '_AccountTransfer_note_OrderByInput',
    {
        'note': 'SortOrder',
    },
    total=True
)

_AccountTransfer_status_OrderByInput = TypedDict(
    '_AccountTransfer_status_OrderByInput',
    {
        'status': 'SortOrder',
    },
    total=True
)

_AccountTransfer_createdAt_OrderByInput = TypedDict(
    '_AccountTransfer_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_AccountTransfer_updatedAt_OrderByInput = TypedDict(
    '_AccountTransfer_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

AccountTransferOrderByInput = Union[
    '_AccountTransfer_id_OrderByInput',
    '_AccountTransfer_fromAccountId_OrderByInput',
    '_AccountTransfer_toAccountId_OrderByInput',
    '_AccountTransfer_amount_OrderByInput',
    '_AccountTransfer_currency_OrderByInput',
    '_AccountTransfer_rateApplied_OrderByInput',
    '_AccountTransfer_note_OrderByInput',
    '_AccountTransfer_status_OrderByInput',
    '_AccountTransfer_createdAt_OrderByInput',
    '_AccountTransfer_updatedAt_OrderByInput',
]



# recursive AccountTransfer types
# TODO: cleanup these types



AccountTransferRelationFilter = TypedDict(
    'AccountTransferRelationFilter',
    {
        'is': 'AccountTransferWhereInput',
        'is_not': 'AccountTransferWhereInput',
    },
    total=False,
)


class AccountTransferListRelationFilter(TypedDict, total=False):
    some: 'AccountTransferWhereInput'
    none: 'AccountTransferWhereInput'
    every: 'AccountTransferWhereInput'


class AccountTransferInclude(TypedDict, total=False):
    """AccountTransfer relational arguments"""
    fromAccount: Union[bool, 'AccountArgsFromAccountTransfer']
    toAccount: Union[bool, 'AccountArgsFromAccountTransfer']


class UserIncludeFromAccountTransfer(TypedDict, total=False):
    """Relational arguments for AccountTransfer"""
    branch: Union[bool, 'BranchArgsFromAccountTransfer']
    auditLogs: Union[bool, 'FindManyAuditLogArgsFromAccountTransfer']
    permissions: Union[bool, 'FindManyUserPermissionArgsFromAccountTransfer']
    notifications: Union[bool, 'FindManyNotificationArgsFromAccountTransfer']
    revokedTokens: Union[bool, 'FindManyRevokedTokenArgsFromAccountTransfer']
    stockAdjustments: Union[bool, 'FindManyStockAdjustmentArgsFromAccountTransfer']
    Sale: Union[bool, 'FindManySaleArgsFromAccountTransfer']
    deletedSales: Union[bool, 'FindManySaleArgsFromAccountTransfer']
    Payment: Union[bool, 'FindManyPaymentArgsFromAccountTransfer']
    Backup: Union[bool, 'FindManyBackupArgsFromAccountTransfer']
    requestedOrders: Union[bool, 'FindManyBranchOrderArgsFromAccountTransfer']
    approvedOrders: Union[bool, 'FindManyBranchOrderArgsFromAccountTransfer']
    sentOrders: Union[bool, 'FindManyBranchOrderArgsFromAccountTransfer']
    receivedOrders: Union[bool, 'FindManyBranchOrderArgsFromAccountTransfer']


class UserArgsFromAccountTransfer(TypedDict, total=False):
    """Arguments for AccountTransfer"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromAccountTransfer(TypedDict, total=False):
    """Arguments for AccountTransfer"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class UserPermissionIncludeFromAccountTransfer(TypedDict, total=False):
    """Relational arguments for AccountTransfer"""
    user: Union[bool, 'UserArgsFromAccountTransfer']


class UserPermissionArgsFromAccountTransfer(TypedDict, total=False):
    """Arguments for AccountTransfer"""
    include: 'UserPermissionIncludeFromUserPermission'


class FindManyUserPermissionArgsFromAccountTransfer(TypedDict, total=False):
    """Arguments for AccountTransfer"""
    take: int
    skip: int
    order_by: Union['UserPermissionOrderByInput', List['UserPermissionOrderByInput']]
    where: 'UserPermissionWhereInput'
    cursor: 'UserPermissionWhereUniqueInput'
    distinct: List['UserPermissionScalarFieldKeys']
    include: 'UserPermissionIncludeFromUserPermission'


class BranchIncludeFromAccountTransfer(TypedDict, total=False):
    """Relational arguments for AccountTransfer"""
    users: Union[bool, 'FindManyUserArgsFromAccountTransfer']
    Sale: Union[bool, 'FindManySaleArgsFromAccountTransfer']
    Account: Union[bool, 'FindManyAccountArgsFromAccountTransfer']
    BranchOrder: Union[bool, 'FindManyBranchOrderArgsFromAccountTransfer']


class BranchArgsFromAccountTransfer(TypedDict, total=False):
    """Arguments for AccountTransfer"""
    include: 'BranchIncludeFromBranch'


class FindManyBranchArgsFromAccountTransfer(TypedDict, total=False):
    """Arguments for AccountTransfer"""
    take: int
    skip: int
    order_by: Union['BranchOrderByInput', List['BranchOrderByInput']]
    where: 'BranchWhereInput'
    cursor: 'BranchWhereUniqueInput'
    distinct: List['BranchScalarFieldKeys']
    include: 'BranchIncludeFromBranch'


class ProductIncludeFromAccountTransfer(TypedDict, total=False):
    """Relational arguments for AccountTransfer"""
    category: Union[bool, 'CategoryArgsFromAccountTransfer']
    stocks: Union[bool, 'FindManyStockArgsFromAccountTransfer']
    stockAdjustments: Union[bool, 'FindManyStockAdjustmentArgsFromAccountTransfer']


class ProductArgsFromAccountTransfer(TypedDict, total=False):
    """Arguments for AccountTransfer"""
    include: 'ProductIncludeFromProduct'


class FindManyProductArgsFromAccountTransfer(TypedDict, total=False):
    """Arguments for AccountTransfer"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProduct'


class CategoryIncludeFromAccountTransfer(TypedDict, total=False):
    """Relational arguments for AccountTransfer"""
    products: Union[bool, 'FindManyProductArgsFromAccountTransfer']


class CategoryArgsFromAccountTransfer(TypedDict, total=False):
    """Arguments for AccountTransfer"""
    include: 'CategoryIncludeFromCategory'


class FindManyCategoryArgsFromAccountTransfer(TypedDict, total=False):
    """Arguments for AccountTransfer"""
    take: int
    skip: int
    order_by: Union['CategoryOrderByInput', List['CategoryOrderByInput']]
    where: 'CategoryWhereInput'
    cursor: 'CategoryWhereUniqueInput'
    distinct: List['CategoryScalarFieldKeys']
    include: 'CategoryIncludeFromCategory'


class StockIncludeFromAccountTransfer(TypedDict, total=False):
    """Relational arguments for AccountTransfer"""
    product: Union[bool, 'ProductArgsFromAccountTransfer']
    SaleItem: Union[bool, 'FindManySaleItemArgsFromAccountTransfer']
    BranchOrderItem: Union[bool, 'FindManyBranchOrderItemArgsFromAccountTransfer']


class StockArgsFromAccountTransfer(TypedDict, total=False):
    """Arguments for AccountTransfer"""
    include: 'StockIncludeFromStock'


class FindManyStockArgsFromAccountTransfer(TypedDict, total=False):
    """Arguments for AccountTransfer"""
    take: int
    skip: int
    order_by: Union['StockOrderByInput', List['StockOrderByInput']]
    where: 'StockWhereInput'
    cursor: 'StockWhereUniqueInput'
    distinct: List['StockScalarFieldKeys']
    include: 'StockIncludeFromStock'


class CustomerIncludeFromAccountTransfer(TypedDict, total=False):
    """Relational arguments for AccountTransfer"""
    Sale: Union[bool, 'FindManySaleArgsFromAccountTransfer']


class CustomerArgsFromAccountTransfer(TypedDict, total=False):
    """Arguments for AccountTransfer"""
    include: 'CustomerIncludeFromCustomer'


class FindManyCustomerArgsFromAccountTransfer(TypedDict, total=False):
    """Arguments for AccountTransfer"""
    take: int
    skip: int
    order_by: Union['CustomerOrderByInput', List['CustomerOrderByInput']]
    where: 'CustomerWhereInput'
    cursor: 'CustomerWhereUniqueInput'
    distinct: List['CustomerScalarFieldKeys']
    include: 'CustomerIncludeFromCustomer'


class SaleIncludeFromAccountTransfer(TypedDict, total=False):
    """Relational arguments for AccountTransfer"""
    branch: Union[bool, 'BranchArgsFromAccountTransfer']
    customer: Union[bool, 'CustomerArgsFromAccountTransfer']
    user: Union[bool, 'UserArgsFromAccountTransfer']
    items: Union[bool, 'FindManySaleItemArgsFromAccountTransfer']
    payments: Union[bool, 'FindManyPaymentArgsFromAccountTransfer']
    returns: Union[bool, 'FindManyReturnSaleArgsFromAccountTransfer']
    deletedBy: Union[bool, 'UserArgsFromAccountTransfer']


class SaleArgsFromAccountTransfer(TypedDict, total=False):
    """Arguments for AccountTransfer"""
    include: 'SaleIncludeFromSale'


class FindManySaleArgsFromAccountTransfer(TypedDict, total=False):
    """Arguments for AccountTransfer"""
    take: int
    skip: int
    order_by: Union['SaleOrderByInput', List['SaleOrderByInput']]
    where: 'SaleWhereInput'
    cursor: 'SaleWhereUniqueInput'
    distinct: List['SaleScalarFieldKeys']
    include: 'SaleIncludeFromSale'


class SaleItemIncludeFromAccountTransfer(TypedDict, total=False):
    """Relational arguments for AccountTransfer"""
    sale: Union[bool, 'SaleArgsFromAccountTransfer']
    stock: Union[bool, 'StockArgsFromAccountTransfer']
    ReturnItem: Union[bool, 'FindManyReturnItemArgsFromAccountTransfer']


class SaleItemArgsFromAccountTransfer(TypedDict, total=False):
    """Arguments for AccountTransfer"""
    include: 'SaleItemIncludeFromSaleItem'


class FindManySaleItemArgsFromAccountTransfer(TypedDict, total=False):
    """Arguments for AccountTransfer"""
    take: int
    skip: int
    order_by: Union['SaleItemOrderByInput', List['SaleItemOrderByInput']]
    where: 'SaleItemWhereInput'
    cursor: 'SaleItemWhereUniqueInput'
    distinct: List['SaleItemScalarFieldKeys']
    include: 'SaleItemIncludeFromSaleItem'


class ReturnSaleIncludeFromAccountTransfer(TypedDict, total=False):
    """Relational arguments for AccountTransfer"""
    original: Union[bool, 'SaleArgsFromAccountTransfer']
    items: Union[bool, 'FindManyReturnItemArgsFromAccountTransfer']
    refund: Union[bool, 'FindManyPaymentArgsFromAccountTransfer']


class ReturnSaleArgsFromAccountTransfer(TypedDict, total=False):
    """Arguments for AccountTransfer"""
    include: 'ReturnSaleIncludeFromReturnSale'


class FindManyReturnSaleArgsFromAccountTransfer(TypedDict, total=False):
    """Arguments for AccountTransfer"""
    take: int
    skip: int
    order_by: Union['ReturnSaleOrderByInput', List['ReturnSaleOrderByInput']]
    where: 'ReturnSaleWhereInput'
    cursor: 'ReturnSaleWhereUniqueInput'
    distinct: List['ReturnSaleScalarFieldKeys']
    include: 'ReturnSaleIncludeFromReturnSale'


class ReturnItemIncludeFromAccountTransfer(TypedDict, total=False):
    """Relational arguments for AccountTransfer"""
    returnSale: Union[bool, 'ReturnSaleArgsFromAccountTransfer']
    saleItem: Union[bool, 'SaleItemArgsFromAccountTransfer']


class ReturnItemArgsFromAccountTransfer(TypedDict, total=False):
    """Arguments for AccountTransfer"""
    include: 'ReturnItemIncludeFromReturnItem'


class FindManyReturnItemArgsFromAccountTransfer(TypedDict, total=False):
    """Arguments for AccountTransfer"""
    take: int
    skip: int
    order_by: Union['ReturnItemOrderByInput', List['ReturnItemOrderByInput']]
    where: 'ReturnItemWhereInput'
    cursor: 'ReturnItemWhereUniqueInput'
    distinct: List['ReturnItemScalarFieldKeys']
    include: 'ReturnItemIncludeFromReturnItem'


class PaymentIncludeFromAccountTransfer(TypedDict, total=False):
    """Relational arguments for AccountTransfer"""
    sale: Union[bool, 'SaleArgsFromAccountTransfer']
    account: Union[bool, 'AccountArgsFromAccountTransfer']
    returnSale: Union[bool, 'ReturnSaleArgsFromAccountTransfer']
    user: Union[bool, 'UserArgsFromAccountTransfer']


class PaymentArgsFromAccountTransfer(TypedDict, total=False):
    """Arguments for AccountTransfer"""
    include: 'PaymentIncludeFromPayment'


class FindManyPaymentArgsFromAccountTransfer(TypedDict, total=False):
    """Arguments for AccountTransfer"""
    take: int
    skip: int
    order_by: Union['PaymentOrderByInput', List['PaymentOrderByInput']]
    where: 'PaymentWhereInput'
    cursor: 'PaymentWhereUniqueInput'
    distinct: List['PaymentScalarFieldKeys']
    include: 'PaymentIncludeFromPayment'


class JournalEntryIncludeFromAccountTransfer(TypedDict, total=False):
    """Relational arguments for AccountTransfer"""
    lines: Union[bool, 'FindManyJournalEntryLineArgsFromAccountTransfer']


class JournalEntryArgsFromAccountTransfer(TypedDict, total=False):
    """Arguments for AccountTransfer"""
    include: 'JournalEntryIncludeFromJournalEntry'


class FindManyJournalEntryArgsFromAccountTransfer(TypedDict, total=False):
    """Arguments for AccountTransfer"""
    take: int
    skip: int
    order_by: Union['JournalEntryOrderByInput', List['JournalEntryOrderByInput']]
    where: 'JournalEntryWhereInput'
    cursor: 'JournalEntryWhereUniqueInput'
    distinct: List['JournalEntryScalarFieldKeys']
    include: 'JournalEntryIncludeFromJournalEntry'


class JournalEntryLineIncludeFromAccountTransfer(TypedDict, total=False):
    """Relational arguments for AccountTransfer"""
    entry: Union[bool, 'JournalEntryArgsFromAccountTransfer']
    account: Union[bool, 'AccountArgsFromAccountTransfer']


class JournalEntryLineArgsFromAccountTransfer(TypedDict, total=False):
    """Arguments for AccountTransfer"""
    include: 'JournalEntryLineIncludeFromJournalEntryLine'


class FindManyJournalEntryLineArgsFromAccountTransfer(TypedDict, total=False):
    """Arguments for AccountTransfer"""
    take: int
    skip: int
    order_by: Union['JournalEntryLineOrderByInput', List['JournalEntryLineOrderByInput']]
    where: 'JournalEntryLineWhereInput'
    cursor: 'JournalEntryLineWhereUniqueInput'
    distinct: List['JournalEntryLineScalarFieldKeys']
    include: 'JournalEntryLineIncludeFromJournalEntryLine'


class AccountIncludeFromAccountTransfer(TypedDict, total=False):
    """Relational arguments for AccountTransfer"""
    branch: Union[bool, 'BranchArgsFromAccountTransfer']
    entries: Union[bool, 'FindManyJournalEntryLineArgsFromAccountTransfer']
    payments: Union[bool, 'FindManyPaymentArgsFromAccountTransfer']
    outgoingTransfers: Union[bool, 'FindManyAccountTransferArgsFromAccountTransfer']
    incomingTransfers: Union[bool, 'FindManyAccountTransferArgsFromAccountTransfer']


class AccountArgsFromAccountTransfer(TypedDict, total=False):
    """Arguments for AccountTransfer"""
    include: 'AccountIncludeFromAccount'


class FindManyAccountArgsFromAccountTransfer(TypedDict, total=False):
    """Arguments for AccountTransfer"""
    take: int
    skip: int
    order_by: Union['AccountOrderByInput', List['AccountOrderByInput']]
    where: 'AccountWhereInput'
    cursor: 'AccountWhereUniqueInput'
    distinct: List['AccountScalarFieldKeys']
    include: 'AccountIncludeFromAccount'


class AccountTransferIncludeFromAccountTransfer(TypedDict, total=False):
    """Relational arguments for AccountTransfer"""
    fromAccount: Union[bool, 'AccountArgsFromAccountTransfer']
    toAccount: Union[bool, 'AccountArgsFromAccountTransfer']


class AccountTransferArgsFromAccountTransfer(TypedDict, total=False):
    """Arguments for AccountTransfer"""
    include: 'AccountTransferIncludeFromAccountTransfer'


class FindManyAccountTransferArgsFromAccountTransfer(TypedDict, total=False):
    """Arguments for AccountTransfer"""
    take: int
    skip: int
    order_by: Union['AccountTransferOrderByInput', List['AccountTransferOrderByInput']]
    where: 'AccountTransferWhereInput'
    cursor: 'AccountTransferWhereUniqueInput'
    distinct: List['AccountTransferScalarFieldKeys']
    include: 'AccountTransferIncludeFromAccountTransfer'


class BranchOrderIncludeFromAccountTransfer(TypedDict, total=False):
    """Relational arguments for AccountTransfer"""
    branch: Union[bool, 'BranchArgsFromAccountTransfer']
    requestedBy: Union[bool, 'UserArgsFromAccountTransfer']
    approvedBy: Union[bool, 'UserArgsFromAccountTransfer']
    sentBy: Union[bool, 'UserArgsFromAccountTransfer']
    receivedBy: Union[bool, 'UserArgsFromAccountTransfer']
    items: Union[bool, 'FindManyBranchOrderItemArgsFromAccountTransfer']


class BranchOrderArgsFromAccountTransfer(TypedDict, total=False):
    """Arguments for AccountTransfer"""
    include: 'BranchOrderIncludeFromBranchOrder'


class FindManyBranchOrderArgsFromAccountTransfer(TypedDict, total=False):
    """Arguments for AccountTransfer"""
    take: int
    skip: int
    order_by: Union['BranchOrderOrderByInput', List['BranchOrderOrderByInput']]
    where: 'BranchOrderWhereInput'
    cursor: 'BranchOrderWhereUniqueInput'
    distinct: List['BranchOrderScalarFieldKeys']
    include: 'BranchOrderIncludeFromBranchOrder'


class BranchOrderItemIncludeFromAccountTransfer(TypedDict, total=False):
    """Relational arguments for AccountTransfer"""
    branchOrder: Union[bool, 'BranchOrderArgsFromAccountTransfer']
    stock: Union[bool, 'StockArgsFromAccountTransfer']


class BranchOrderItemArgsFromAccountTransfer(TypedDict, total=False):
    """Arguments for AccountTransfer"""
    include: 'BranchOrderItemIncludeFromBranchOrderItem'


class FindManyBranchOrderItemArgsFromAccountTransfer(TypedDict, total=False):
    """Arguments for AccountTransfer"""
    take: int
    skip: int
    order_by: Union['BranchOrderItemOrderByInput', List['BranchOrderItemOrderByInput']]
    where: 'BranchOrderItemWhereInput'
    cursor: 'BranchOrderItemWhereUniqueInput'
    distinct: List['BranchOrderItemScalarFieldKeys']
    include: 'BranchOrderItemIncludeFromBranchOrderItem'


class AuditLogIncludeFromAccountTransfer(TypedDict, total=False):
    """Relational arguments for AccountTransfer"""
    user: Union[bool, 'UserArgsFromAccountTransfer']


class AuditLogArgsFromAccountTransfer(TypedDict, total=False):
    """Arguments for AccountTransfer"""
    include: 'AuditLogIncludeFromAuditLog'


class FindManyAuditLogArgsFromAccountTransfer(TypedDict, total=False):
    """Arguments for AccountTransfer"""
    take: int
    skip: int
    order_by: Union['AuditLogOrderByInput', List['AuditLogOrderByInput']]
    where: 'AuditLogWhereInput'
    cursor: 'AuditLogWhereUniqueInput'
    distinct: List['AuditLogScalarFieldKeys']
    include: 'AuditLogIncludeFromAuditLog'


class SystemInfoIncludeFromAccountTransfer(TypedDict, total=False):
    """Relational arguments for AccountTransfer"""


class SystemInfoArgsFromAccountTransfer(TypedDict, total=False):
    """Arguments for AccountTransfer"""
    include: 'SystemInfoIncludeFromSystemInfo'


class FindManySystemInfoArgsFromAccountTransfer(TypedDict, total=False):
    """Arguments for AccountTransfer"""
    take: int
    skip: int
    order_by: Union['SystemInfoOrderByInput', List['SystemInfoOrderByInput']]
    where: 'SystemInfoWhereInput'
    cursor: 'SystemInfoWhereUniqueInput'
    distinct: List['SystemInfoScalarFieldKeys']
    include: 'SystemInfoIncludeFromSystemInfo'


class BackupIncludeFromAccountTransfer(TypedDict, total=False):
    """Relational arguments for AccountTransfer"""
    createdBy: Union[bool, 'UserArgsFromAccountTransfer']


class BackupArgsFromAccountTransfer(TypedDict, total=False):
    """Arguments for AccountTransfer"""
    include: 'BackupIncludeFromBackup'


class FindManyBackupArgsFromAccountTransfer(TypedDict, total=False):
    """Arguments for AccountTransfer"""
    take: int
    skip: int
    order_by: Union['BackupOrderByInput', List['BackupOrderByInput']]
    where: 'BackupWhereInput'
    cursor: 'BackupWhereUniqueInput'
    distinct: List['BackupScalarFieldKeys']
    include: 'BackupIncludeFromBackup'


class RevokedTokenIncludeFromAccountTransfer(TypedDict, total=False):
    """Relational arguments for AccountTransfer"""
    user: Union[bool, 'UserArgsFromAccountTransfer']


class RevokedTokenArgsFromAccountTransfer(TypedDict, total=False):
    """Arguments for AccountTransfer"""
    include: 'RevokedTokenIncludeFromRevokedToken'


class FindManyRevokedTokenArgsFromAccountTransfer(TypedDict, total=False):
    """Arguments for AccountTransfer"""
    take: int
    skip: int
    order_by: Union['RevokedTokenOrderByInput', List['RevokedTokenOrderByInput']]
    where: 'RevokedTokenWhereInput'
    cursor: 'RevokedTokenWhereUniqueInput'
    distinct: List['RevokedTokenScalarFieldKeys']
    include: 'RevokedTokenIncludeFromRevokedToken'


class SystemSettingIncludeFromAccountTransfer(TypedDict, total=False):
    """Relational arguments for AccountTransfer"""


class SystemSettingArgsFromAccountTransfer(TypedDict, total=False):
    """Arguments for AccountTransfer"""
    include: 'SystemSettingIncludeFromSystemSetting'


class FindManySystemSettingArgsFromAccountTransfer(TypedDict, total=False):
    """Arguments for AccountTransfer"""
    take: int
    skip: int
    order_by: Union['SystemSettingOrderByInput', List['SystemSettingOrderByInput']]
    where: 'SystemSettingWhereInput'
    cursor: 'SystemSettingWhereUniqueInput'
    distinct: List['SystemSettingScalarFieldKeys']
    include: 'SystemSettingIncludeFromSystemSetting'


class NotificationIncludeFromAccountTransfer(TypedDict, total=False):
    """Relational arguments for AccountTransfer"""
    user: Union[bool, 'UserArgsFromAccountTransfer']


class NotificationArgsFromAccountTransfer(TypedDict, total=False):
    """Arguments for AccountTransfer"""
    include: 'NotificationIncludeFromNotification'


class FindManyNotificationArgsFromAccountTransfer(TypedDict, total=False):
    """Arguments for AccountTransfer"""
    take: int
    skip: int
    order_by: Union['NotificationOrderByInput', List['NotificationOrderByInput']]
    where: 'NotificationWhereInput'
    cursor: 'NotificationWhereUniqueInput'
    distinct: List['NotificationScalarFieldKeys']
    include: 'NotificationIncludeFromNotification'


class StockAdjustmentIncludeFromAccountTransfer(TypedDict, total=False):
    """Relational arguments for AccountTransfer"""
    product: Union[bool, 'ProductArgsFromAccountTransfer']
    createdBy: Union[bool, 'UserArgsFromAccountTransfer']


class StockAdjustmentArgsFromAccountTransfer(TypedDict, total=False):
    """Arguments for AccountTransfer"""
    include: 'StockAdjustmentIncludeFromStockAdjustment'


class FindManyStockAdjustmentArgsFromAccountTransfer(TypedDict, total=False):
    """Arguments for AccountTransfer"""
    take: int
    skip: int
    order_by: Union['StockAdjustmentOrderByInput', List['StockAdjustmentOrderByInput']]
    where: 'StockAdjustmentWhereInput'
    cursor: 'StockAdjustmentWhereUniqueInput'
    distinct: List['StockAdjustmentScalarFieldKeys']
    include: 'StockAdjustmentIncludeFromStockAdjustment'




FindManyAccountTransferArgs = FindManyAccountTransferArgsFromAccountTransfer
FindFirstAccountTransferArgs = FindManyAccountTransferArgsFromAccountTransfer


class AccountTransferWhereInput(TypedDict, total=False):
    """AccountTransfer arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    fromAccount: 'AccountRelationFilter'
    fromAccountId: Union[_int, 'types.IntFilter']
    toAccount: 'AccountRelationFilter'
    toAccountId: Union[_int, 'types.IntFilter']
    amount: Union[decimal.Decimal, 'types.DecimalFilter']
    currency: 'enums.Currency'
    rateApplied: Union[None, decimal.Decimal, 'types.DecimalFilter']
    note: Union[None, _str, 'types.StringFilter']
    status: 'enums.TransferStatus'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['AccountTransferWhereInput', List['AccountTransferWhereInput']]
    # but this causes mypy to hang :/
    AND: List['AccountTransferWhereInput']
    OR: List['AccountTransferWhereInput']
    NOT: List['AccountTransferWhereInput']



# aggregate AccountTransfer types


class AccountTransferScalarWhereWithAggregatesInput(TypedDict, total=False):
    """AccountTransfer arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    fromAccountId: Union[_int, 'types.IntWithAggregatesFilter']
    toAccountId: Union[_int, 'types.IntWithAggregatesFilter']
    amount: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    currency: 'enums.Currency'
    rateApplied: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    note: Union[_str, 'types.StringWithAggregatesFilter']
    status: 'enums.TransferStatus'
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['AccountTransferScalarWhereWithAggregatesInput']
    OR: List['AccountTransferScalarWhereWithAggregatesInput']
    NOT: List['AccountTransferScalarWhereWithAggregatesInput']



class AccountTransferGroupByOutput(TypedDict, total=False):
    id: _int
    fromAccountId: _int
    toAccountId: _int
    amount: decimal.Decimal
    currency: 'enums.Currency'
    rateApplied: decimal.Decimal
    note: _str
    status: 'enums.TransferStatus'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'AccountTransferSumAggregateOutput'
    _avg: 'AccountTransferAvgAggregateOutput'
    _min: 'AccountTransferMinAggregateOutput'
    _max: 'AccountTransferMaxAggregateOutput'
    _count: 'AccountTransferCountAggregateOutput'


class AccountTransferAvgAggregateOutput(TypedDict, total=False):
    """AccountTransfer output for aggregating averages"""
    id: float
    fromAccountId: float
    toAccountId: float


class AccountTransferSumAggregateOutput(TypedDict, total=False):
    """AccountTransfer output for aggregating sums"""
    id: _int
    fromAccountId: _int
    toAccountId: _int


class AccountTransferScalarAggregateOutput(TypedDict, total=False):
    """AccountTransfer output including scalar fields"""
    id: _int
    fromAccountId: _int
    toAccountId: _int
    amount: decimal.Decimal
    currency: 'enums.Currency'
    rateApplied: decimal.Decimal
    note: _str
    status: 'enums.TransferStatus'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


AccountTransferMinAggregateOutput = AccountTransferScalarAggregateOutput
AccountTransferMaxAggregateOutput = AccountTransferScalarAggregateOutput


class AccountTransferMaxAggregateInput(TypedDict, total=False):
    """AccountTransfer input for aggregating by max"""
    id: bool
    fromAccountId: bool
    toAccountId: bool
    amount: bool
    currency: bool
    rateApplied: bool
    note: bool
    status: bool
    createdAt: bool
    updatedAt: bool


class AccountTransferMinAggregateInput(TypedDict, total=False):
    """AccountTransfer input for aggregating by min"""
    id: bool
    fromAccountId: bool
    toAccountId: bool
    amount: bool
    currency: bool
    rateApplied: bool
    note: bool
    status: bool
    createdAt: bool
    updatedAt: bool


class AccountTransferNumberAggregateInput(TypedDict, total=False):
    """AccountTransfer input for aggregating numbers"""
    id: bool
    fromAccountId: bool
    toAccountId: bool


AccountTransferAvgAggregateInput = AccountTransferNumberAggregateInput
AccountTransferSumAggregateInput = AccountTransferNumberAggregateInput


AccountTransferCountAggregateInput = TypedDict(
    'AccountTransferCountAggregateInput',
    {
        'id': bool,
        'fromAccountId': bool,
        'toAccountId': bool,
        'amount': bool,
        'currency': bool,
        'rateApplied': bool,
        'note': bool,
        'status': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

AccountTransferCountAggregateOutput = TypedDict(
    'AccountTransferCountAggregateOutput',
    {
        'id': int,
        'fromAccountId': int,
        'toAccountId': int,
        'amount': int,
        'currency': int,
        'rateApplied': int,
        'note': int,
        'status': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


AccountTransferKeys = Literal[
    'id',
    'fromAccount',
    'fromAccountId',
    'toAccount',
    'toAccountId',
    'amount',
    'currency',
    'rateApplied',
    'note',
    'status',
    'createdAt',
    'updatedAt',
]
AccountTransferScalarFieldKeys = Literal[
    'id',
    'fromAccountId',
    'toAccountId',
    'amount',
    'currency',
    'rateApplied',
    'note',
    'status',
    'createdAt',
    'updatedAt',
]
AccountTransferScalarFieldKeysT = TypeVar('AccountTransferScalarFieldKeysT', bound=AccountTransferScalarFieldKeys)

AccountTransferRelationalFieldKeys = Literal[
        'fromAccount',
        'toAccount',
    ]

# BranchOrder types

class BranchOrderOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the BranchOrder create method"""
    id: _int
    branchId: _int
    branch: 'BranchCreateNestedWithoutRelationsInput'
    requestedById: _int
    requestedBy: 'UserCreateNestedWithoutRelationsInput'
    approvedById: Optional[_int]
    approvedBy: 'UserCreateNestedWithoutRelationsInput'
    sentById: Optional[_int]
    sentBy: 'UserCreateNestedWithoutRelationsInput'
    receivedById: Optional[_int]
    receivedBy: 'UserCreateNestedWithoutRelationsInput'
    items: 'BranchOrderItemCreateManyNestedWithoutRelationsInput'
    status: 'enums.BranchOrderStatus'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class BranchOrderCreateInput(BranchOrderOptionalCreateInput):
    """Required arguments to the BranchOrder create method"""


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class BranchOrderOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the BranchOrder create method, without relations"""
    id: _int
    branchId: _int
    requestedById: _int
    approvedById: Optional[_int]
    sentById: Optional[_int]
    receivedById: Optional[_int]
    status: 'enums.BranchOrderStatus'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class BranchOrderCreateWithoutRelationsInput(BranchOrderOptionalCreateWithoutRelationsInput):
    """Required arguments to the BranchOrder create method, without relations"""


class BranchOrderCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'BranchOrderCreateWithoutRelationsInput'
    connect: 'BranchOrderWhereUniqueInput'


class BranchOrderCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['BranchOrderCreateWithoutRelationsInput', List['BranchOrderCreateWithoutRelationsInput']]
    connect: Union['BranchOrderWhereUniqueInput', List['BranchOrderWhereUniqueInput']]


_BranchOrderWhereUnique_id_Input = TypedDict(
    '_BranchOrderWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

BranchOrderWhereUniqueInput = _BranchOrderWhereUnique_id_Input


class BranchOrderUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    branch: 'BranchUpdateOneWithoutRelationsInput'
    requestedBy: 'UserUpdateOneWithoutRelationsInput'
    approvedBy: 'UserUpdateOneWithoutRelationsInput'
    sentBy: 'UserUpdateOneWithoutRelationsInput'
    receivedBy: 'UserUpdateOneWithoutRelationsInput'
    items: 'BranchOrderItemUpdateManyWithoutRelationsInput'
    status: 'enums.BranchOrderStatus'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class BranchOrderUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    status: 'enums.BranchOrderStatus'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class BranchOrderUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['BranchOrderCreateWithoutRelationsInput']
    connect: List['BranchOrderWhereUniqueInput']
    set: List['BranchOrderWhereUniqueInput']
    disconnect: List['BranchOrderWhereUniqueInput']
    delete: List['BranchOrderWhereUniqueInput']

    # TODO
    # update: List['BranchOrderUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['BranchOrderUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['BranchOrderScalarWhereInput']
    # upsert: List['BranchOrderUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['BranchOrderCreateOrConnectWithoutRelationsInput']


class BranchOrderUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'BranchOrderCreateWithoutRelationsInput'
    connect: 'BranchOrderWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'BranchOrderUpdateInput'
    # upsert: 'BranchOrderUpsertWithoutRelationsInput'
    # connectOrCreate: 'BranchOrderCreateOrConnectWithoutRelationsInput'


class BranchOrderUpsertInput(TypedDict):
    create: 'BranchOrderCreateInput'
    update: 'BranchOrderUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_BranchOrder_id_OrderByInput = TypedDict(
    '_BranchOrder_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_BranchOrder_branchId_OrderByInput = TypedDict(
    '_BranchOrder_branchId_OrderByInput',
    {
        'branchId': 'SortOrder',
    },
    total=True
)

_BranchOrder_requestedById_OrderByInput = TypedDict(
    '_BranchOrder_requestedById_OrderByInput',
    {
        'requestedById': 'SortOrder',
    },
    total=True
)

_BranchOrder_approvedById_OrderByInput = TypedDict(
    '_BranchOrder_approvedById_OrderByInput',
    {
        'approvedById': 'SortOrder',
    },
    total=True
)

_BranchOrder_sentById_OrderByInput = TypedDict(
    '_BranchOrder_sentById_OrderByInput',
    {
        'sentById': 'SortOrder',
    },
    total=True
)

_BranchOrder_receivedById_OrderByInput = TypedDict(
    '_BranchOrder_receivedById_OrderByInput',
    {
        'receivedById': 'SortOrder',
    },
    total=True
)

_BranchOrder_status_OrderByInput = TypedDict(
    '_BranchOrder_status_OrderByInput',
    {
        'status': 'SortOrder',
    },
    total=True
)

_BranchOrder_createdAt_OrderByInput = TypedDict(
    '_BranchOrder_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_BranchOrder_updatedAt_OrderByInput = TypedDict(
    '_BranchOrder_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

BranchOrderOrderByInput = Union[
    '_BranchOrder_id_OrderByInput',
    '_BranchOrder_branchId_OrderByInput',
    '_BranchOrder_requestedById_OrderByInput',
    '_BranchOrder_approvedById_OrderByInput',
    '_BranchOrder_sentById_OrderByInput',
    '_BranchOrder_receivedById_OrderByInput',
    '_BranchOrder_status_OrderByInput',
    '_BranchOrder_createdAt_OrderByInput',
    '_BranchOrder_updatedAt_OrderByInput',
]



# recursive BranchOrder types
# TODO: cleanup these types



BranchOrderRelationFilter = TypedDict(
    'BranchOrderRelationFilter',
    {
        'is': 'BranchOrderWhereInput',
        'is_not': 'BranchOrderWhereInput',
    },
    total=False,
)


class BranchOrderListRelationFilter(TypedDict, total=False):
    some: 'BranchOrderWhereInput'
    none: 'BranchOrderWhereInput'
    every: 'BranchOrderWhereInput'


class BranchOrderInclude(TypedDict, total=False):
    """BranchOrder relational arguments"""
    branch: Union[bool, 'BranchArgsFromBranchOrder']
    requestedBy: Union[bool, 'UserArgsFromBranchOrder']
    approvedBy: Union[bool, 'UserArgsFromBranchOrder']
    sentBy: Union[bool, 'UserArgsFromBranchOrder']
    receivedBy: Union[bool, 'UserArgsFromBranchOrder']
    items: Union[bool, 'FindManyBranchOrderItemArgsFromBranchOrder']


class UserIncludeFromBranchOrder(TypedDict, total=False):
    """Relational arguments for BranchOrder"""
    branch: Union[bool, 'BranchArgsFromBranchOrder']
    auditLogs: Union[bool, 'FindManyAuditLogArgsFromBranchOrder']
    permissions: Union[bool, 'FindManyUserPermissionArgsFromBranchOrder']
    notifications: Union[bool, 'FindManyNotificationArgsFromBranchOrder']
    revokedTokens: Union[bool, 'FindManyRevokedTokenArgsFromBranchOrder']
    stockAdjustments: Union[bool, 'FindManyStockAdjustmentArgsFromBranchOrder']
    Sale: Union[bool, 'FindManySaleArgsFromBranchOrder']
    deletedSales: Union[bool, 'FindManySaleArgsFromBranchOrder']
    Payment: Union[bool, 'FindManyPaymentArgsFromBranchOrder']
    Backup: Union[bool, 'FindManyBackupArgsFromBranchOrder']
    requestedOrders: Union[bool, 'FindManyBranchOrderArgsFromBranchOrder']
    approvedOrders: Union[bool, 'FindManyBranchOrderArgsFromBranchOrder']
    sentOrders: Union[bool, 'FindManyBranchOrderArgsFromBranchOrder']
    receivedOrders: Union[bool, 'FindManyBranchOrderArgsFromBranchOrder']


class UserArgsFromBranchOrder(TypedDict, total=False):
    """Arguments for BranchOrder"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromBranchOrder(TypedDict, total=False):
    """Arguments for BranchOrder"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class UserPermissionIncludeFromBranchOrder(TypedDict, total=False):
    """Relational arguments for BranchOrder"""
    user: Union[bool, 'UserArgsFromBranchOrder']


class UserPermissionArgsFromBranchOrder(TypedDict, total=False):
    """Arguments for BranchOrder"""
    include: 'UserPermissionIncludeFromUserPermission'


class FindManyUserPermissionArgsFromBranchOrder(TypedDict, total=False):
    """Arguments for BranchOrder"""
    take: int
    skip: int
    order_by: Union['UserPermissionOrderByInput', List['UserPermissionOrderByInput']]
    where: 'UserPermissionWhereInput'
    cursor: 'UserPermissionWhereUniqueInput'
    distinct: List['UserPermissionScalarFieldKeys']
    include: 'UserPermissionIncludeFromUserPermission'


class BranchIncludeFromBranchOrder(TypedDict, total=False):
    """Relational arguments for BranchOrder"""
    users: Union[bool, 'FindManyUserArgsFromBranchOrder']
    Sale: Union[bool, 'FindManySaleArgsFromBranchOrder']
    Account: Union[bool, 'FindManyAccountArgsFromBranchOrder']
    BranchOrder: Union[bool, 'FindManyBranchOrderArgsFromBranchOrder']


class BranchArgsFromBranchOrder(TypedDict, total=False):
    """Arguments for BranchOrder"""
    include: 'BranchIncludeFromBranch'


class FindManyBranchArgsFromBranchOrder(TypedDict, total=False):
    """Arguments for BranchOrder"""
    take: int
    skip: int
    order_by: Union['BranchOrderByInput', List['BranchOrderByInput']]
    where: 'BranchWhereInput'
    cursor: 'BranchWhereUniqueInput'
    distinct: List['BranchScalarFieldKeys']
    include: 'BranchIncludeFromBranch'


class ProductIncludeFromBranchOrder(TypedDict, total=False):
    """Relational arguments for BranchOrder"""
    category: Union[bool, 'CategoryArgsFromBranchOrder']
    stocks: Union[bool, 'FindManyStockArgsFromBranchOrder']
    stockAdjustments: Union[bool, 'FindManyStockAdjustmentArgsFromBranchOrder']


class ProductArgsFromBranchOrder(TypedDict, total=False):
    """Arguments for BranchOrder"""
    include: 'ProductIncludeFromProduct'


class FindManyProductArgsFromBranchOrder(TypedDict, total=False):
    """Arguments for BranchOrder"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProduct'


class CategoryIncludeFromBranchOrder(TypedDict, total=False):
    """Relational arguments for BranchOrder"""
    products: Union[bool, 'FindManyProductArgsFromBranchOrder']


class CategoryArgsFromBranchOrder(TypedDict, total=False):
    """Arguments for BranchOrder"""
    include: 'CategoryIncludeFromCategory'


class FindManyCategoryArgsFromBranchOrder(TypedDict, total=False):
    """Arguments for BranchOrder"""
    take: int
    skip: int
    order_by: Union['CategoryOrderByInput', List['CategoryOrderByInput']]
    where: 'CategoryWhereInput'
    cursor: 'CategoryWhereUniqueInput'
    distinct: List['CategoryScalarFieldKeys']
    include: 'CategoryIncludeFromCategory'


class StockIncludeFromBranchOrder(TypedDict, total=False):
    """Relational arguments for BranchOrder"""
    product: Union[bool, 'ProductArgsFromBranchOrder']
    SaleItem: Union[bool, 'FindManySaleItemArgsFromBranchOrder']
    BranchOrderItem: Union[bool, 'FindManyBranchOrderItemArgsFromBranchOrder']


class StockArgsFromBranchOrder(TypedDict, total=False):
    """Arguments for BranchOrder"""
    include: 'StockIncludeFromStock'


class FindManyStockArgsFromBranchOrder(TypedDict, total=False):
    """Arguments for BranchOrder"""
    take: int
    skip: int
    order_by: Union['StockOrderByInput', List['StockOrderByInput']]
    where: 'StockWhereInput'
    cursor: 'StockWhereUniqueInput'
    distinct: List['StockScalarFieldKeys']
    include: 'StockIncludeFromStock'


class CustomerIncludeFromBranchOrder(TypedDict, total=False):
    """Relational arguments for BranchOrder"""
    Sale: Union[bool, 'FindManySaleArgsFromBranchOrder']


class CustomerArgsFromBranchOrder(TypedDict, total=False):
    """Arguments for BranchOrder"""
    include: 'CustomerIncludeFromCustomer'


class FindManyCustomerArgsFromBranchOrder(TypedDict, total=False):
    """Arguments for BranchOrder"""
    take: int
    skip: int
    order_by: Union['CustomerOrderByInput', List['CustomerOrderByInput']]
    where: 'CustomerWhereInput'
    cursor: 'CustomerWhereUniqueInput'
    distinct: List['CustomerScalarFieldKeys']
    include: 'CustomerIncludeFromCustomer'


class SaleIncludeFromBranchOrder(TypedDict, total=False):
    """Relational arguments for BranchOrder"""
    branch: Union[bool, 'BranchArgsFromBranchOrder']
    customer: Union[bool, 'CustomerArgsFromBranchOrder']
    user: Union[bool, 'UserArgsFromBranchOrder']
    items: Union[bool, 'FindManySaleItemArgsFromBranchOrder']
    payments: Union[bool, 'FindManyPaymentArgsFromBranchOrder']
    returns: Union[bool, 'FindManyReturnSaleArgsFromBranchOrder']
    deletedBy: Union[bool, 'UserArgsFromBranchOrder']


class SaleArgsFromBranchOrder(TypedDict, total=False):
    """Arguments for BranchOrder"""
    include: 'SaleIncludeFromSale'


class FindManySaleArgsFromBranchOrder(TypedDict, total=False):
    """Arguments for BranchOrder"""
    take: int
    skip: int
    order_by: Union['SaleOrderByInput', List['SaleOrderByInput']]
    where: 'SaleWhereInput'
    cursor: 'SaleWhereUniqueInput'
    distinct: List['SaleScalarFieldKeys']
    include: 'SaleIncludeFromSale'


class SaleItemIncludeFromBranchOrder(TypedDict, total=False):
    """Relational arguments for BranchOrder"""
    sale: Union[bool, 'SaleArgsFromBranchOrder']
    stock: Union[bool, 'StockArgsFromBranchOrder']
    ReturnItem: Union[bool, 'FindManyReturnItemArgsFromBranchOrder']


class SaleItemArgsFromBranchOrder(TypedDict, total=False):
    """Arguments for BranchOrder"""
    include: 'SaleItemIncludeFromSaleItem'


class FindManySaleItemArgsFromBranchOrder(TypedDict, total=False):
    """Arguments for BranchOrder"""
    take: int
    skip: int
    order_by: Union['SaleItemOrderByInput', List['SaleItemOrderByInput']]
    where: 'SaleItemWhereInput'
    cursor: 'SaleItemWhereUniqueInput'
    distinct: List['SaleItemScalarFieldKeys']
    include: 'SaleItemIncludeFromSaleItem'


class ReturnSaleIncludeFromBranchOrder(TypedDict, total=False):
    """Relational arguments for BranchOrder"""
    original: Union[bool, 'SaleArgsFromBranchOrder']
    items: Union[bool, 'FindManyReturnItemArgsFromBranchOrder']
    refund: Union[bool, 'FindManyPaymentArgsFromBranchOrder']


class ReturnSaleArgsFromBranchOrder(TypedDict, total=False):
    """Arguments for BranchOrder"""
    include: 'ReturnSaleIncludeFromReturnSale'


class FindManyReturnSaleArgsFromBranchOrder(TypedDict, total=False):
    """Arguments for BranchOrder"""
    take: int
    skip: int
    order_by: Union['ReturnSaleOrderByInput', List['ReturnSaleOrderByInput']]
    where: 'ReturnSaleWhereInput'
    cursor: 'ReturnSaleWhereUniqueInput'
    distinct: List['ReturnSaleScalarFieldKeys']
    include: 'ReturnSaleIncludeFromReturnSale'


class ReturnItemIncludeFromBranchOrder(TypedDict, total=False):
    """Relational arguments for BranchOrder"""
    returnSale: Union[bool, 'ReturnSaleArgsFromBranchOrder']
    saleItem: Union[bool, 'SaleItemArgsFromBranchOrder']


class ReturnItemArgsFromBranchOrder(TypedDict, total=False):
    """Arguments for BranchOrder"""
    include: 'ReturnItemIncludeFromReturnItem'


class FindManyReturnItemArgsFromBranchOrder(TypedDict, total=False):
    """Arguments for BranchOrder"""
    take: int
    skip: int
    order_by: Union['ReturnItemOrderByInput', List['ReturnItemOrderByInput']]
    where: 'ReturnItemWhereInput'
    cursor: 'ReturnItemWhereUniqueInput'
    distinct: List['ReturnItemScalarFieldKeys']
    include: 'ReturnItemIncludeFromReturnItem'


class PaymentIncludeFromBranchOrder(TypedDict, total=False):
    """Relational arguments for BranchOrder"""
    sale: Union[bool, 'SaleArgsFromBranchOrder']
    account: Union[bool, 'AccountArgsFromBranchOrder']
    returnSale: Union[bool, 'ReturnSaleArgsFromBranchOrder']
    user: Union[bool, 'UserArgsFromBranchOrder']


class PaymentArgsFromBranchOrder(TypedDict, total=False):
    """Arguments for BranchOrder"""
    include: 'PaymentIncludeFromPayment'


class FindManyPaymentArgsFromBranchOrder(TypedDict, total=False):
    """Arguments for BranchOrder"""
    take: int
    skip: int
    order_by: Union['PaymentOrderByInput', List['PaymentOrderByInput']]
    where: 'PaymentWhereInput'
    cursor: 'PaymentWhereUniqueInput'
    distinct: List['PaymentScalarFieldKeys']
    include: 'PaymentIncludeFromPayment'


class JournalEntryIncludeFromBranchOrder(TypedDict, total=False):
    """Relational arguments for BranchOrder"""
    lines: Union[bool, 'FindManyJournalEntryLineArgsFromBranchOrder']


class JournalEntryArgsFromBranchOrder(TypedDict, total=False):
    """Arguments for BranchOrder"""
    include: 'JournalEntryIncludeFromJournalEntry'


class FindManyJournalEntryArgsFromBranchOrder(TypedDict, total=False):
    """Arguments for BranchOrder"""
    take: int
    skip: int
    order_by: Union['JournalEntryOrderByInput', List['JournalEntryOrderByInput']]
    where: 'JournalEntryWhereInput'
    cursor: 'JournalEntryWhereUniqueInput'
    distinct: List['JournalEntryScalarFieldKeys']
    include: 'JournalEntryIncludeFromJournalEntry'


class JournalEntryLineIncludeFromBranchOrder(TypedDict, total=False):
    """Relational arguments for BranchOrder"""
    entry: Union[bool, 'JournalEntryArgsFromBranchOrder']
    account: Union[bool, 'AccountArgsFromBranchOrder']


class JournalEntryLineArgsFromBranchOrder(TypedDict, total=False):
    """Arguments for BranchOrder"""
    include: 'JournalEntryLineIncludeFromJournalEntryLine'


class FindManyJournalEntryLineArgsFromBranchOrder(TypedDict, total=False):
    """Arguments for BranchOrder"""
    take: int
    skip: int
    order_by: Union['JournalEntryLineOrderByInput', List['JournalEntryLineOrderByInput']]
    where: 'JournalEntryLineWhereInput'
    cursor: 'JournalEntryLineWhereUniqueInput'
    distinct: List['JournalEntryLineScalarFieldKeys']
    include: 'JournalEntryLineIncludeFromJournalEntryLine'


class AccountIncludeFromBranchOrder(TypedDict, total=False):
    """Relational arguments for BranchOrder"""
    branch: Union[bool, 'BranchArgsFromBranchOrder']
    entries: Union[bool, 'FindManyJournalEntryLineArgsFromBranchOrder']
    payments: Union[bool, 'FindManyPaymentArgsFromBranchOrder']
    outgoingTransfers: Union[bool, 'FindManyAccountTransferArgsFromBranchOrder']
    incomingTransfers: Union[bool, 'FindManyAccountTransferArgsFromBranchOrder']


class AccountArgsFromBranchOrder(TypedDict, total=False):
    """Arguments for BranchOrder"""
    include: 'AccountIncludeFromAccount'


class FindManyAccountArgsFromBranchOrder(TypedDict, total=False):
    """Arguments for BranchOrder"""
    take: int
    skip: int
    order_by: Union['AccountOrderByInput', List['AccountOrderByInput']]
    where: 'AccountWhereInput'
    cursor: 'AccountWhereUniqueInput'
    distinct: List['AccountScalarFieldKeys']
    include: 'AccountIncludeFromAccount'


class AccountTransferIncludeFromBranchOrder(TypedDict, total=False):
    """Relational arguments for BranchOrder"""
    fromAccount: Union[bool, 'AccountArgsFromBranchOrder']
    toAccount: Union[bool, 'AccountArgsFromBranchOrder']


class AccountTransferArgsFromBranchOrder(TypedDict, total=False):
    """Arguments for BranchOrder"""
    include: 'AccountTransferIncludeFromAccountTransfer'


class FindManyAccountTransferArgsFromBranchOrder(TypedDict, total=False):
    """Arguments for BranchOrder"""
    take: int
    skip: int
    order_by: Union['AccountTransferOrderByInput', List['AccountTransferOrderByInput']]
    where: 'AccountTransferWhereInput'
    cursor: 'AccountTransferWhereUniqueInput'
    distinct: List['AccountTransferScalarFieldKeys']
    include: 'AccountTransferIncludeFromAccountTransfer'


class BranchOrderIncludeFromBranchOrder(TypedDict, total=False):
    """Relational arguments for BranchOrder"""
    branch: Union[bool, 'BranchArgsFromBranchOrder']
    requestedBy: Union[bool, 'UserArgsFromBranchOrder']
    approvedBy: Union[bool, 'UserArgsFromBranchOrder']
    sentBy: Union[bool, 'UserArgsFromBranchOrder']
    receivedBy: Union[bool, 'UserArgsFromBranchOrder']
    items: Union[bool, 'FindManyBranchOrderItemArgsFromBranchOrder']


class BranchOrderArgsFromBranchOrder(TypedDict, total=False):
    """Arguments for BranchOrder"""
    include: 'BranchOrderIncludeFromBranchOrder'


class FindManyBranchOrderArgsFromBranchOrder(TypedDict, total=False):
    """Arguments for BranchOrder"""
    take: int
    skip: int
    order_by: Union['BranchOrderOrderByInput', List['BranchOrderOrderByInput']]
    where: 'BranchOrderWhereInput'
    cursor: 'BranchOrderWhereUniqueInput'
    distinct: List['BranchOrderScalarFieldKeys']
    include: 'BranchOrderIncludeFromBranchOrder'


class BranchOrderItemIncludeFromBranchOrder(TypedDict, total=False):
    """Relational arguments for BranchOrder"""
    branchOrder: Union[bool, 'BranchOrderArgsFromBranchOrder']
    stock: Union[bool, 'StockArgsFromBranchOrder']


class BranchOrderItemArgsFromBranchOrder(TypedDict, total=False):
    """Arguments for BranchOrder"""
    include: 'BranchOrderItemIncludeFromBranchOrderItem'


class FindManyBranchOrderItemArgsFromBranchOrder(TypedDict, total=False):
    """Arguments for BranchOrder"""
    take: int
    skip: int
    order_by: Union['BranchOrderItemOrderByInput', List['BranchOrderItemOrderByInput']]
    where: 'BranchOrderItemWhereInput'
    cursor: 'BranchOrderItemWhereUniqueInput'
    distinct: List['BranchOrderItemScalarFieldKeys']
    include: 'BranchOrderItemIncludeFromBranchOrderItem'


class AuditLogIncludeFromBranchOrder(TypedDict, total=False):
    """Relational arguments for BranchOrder"""
    user: Union[bool, 'UserArgsFromBranchOrder']


class AuditLogArgsFromBranchOrder(TypedDict, total=False):
    """Arguments for BranchOrder"""
    include: 'AuditLogIncludeFromAuditLog'


class FindManyAuditLogArgsFromBranchOrder(TypedDict, total=False):
    """Arguments for BranchOrder"""
    take: int
    skip: int
    order_by: Union['AuditLogOrderByInput', List['AuditLogOrderByInput']]
    where: 'AuditLogWhereInput'
    cursor: 'AuditLogWhereUniqueInput'
    distinct: List['AuditLogScalarFieldKeys']
    include: 'AuditLogIncludeFromAuditLog'


class SystemInfoIncludeFromBranchOrder(TypedDict, total=False):
    """Relational arguments for BranchOrder"""


class SystemInfoArgsFromBranchOrder(TypedDict, total=False):
    """Arguments for BranchOrder"""
    include: 'SystemInfoIncludeFromSystemInfo'


class FindManySystemInfoArgsFromBranchOrder(TypedDict, total=False):
    """Arguments for BranchOrder"""
    take: int
    skip: int
    order_by: Union['SystemInfoOrderByInput', List['SystemInfoOrderByInput']]
    where: 'SystemInfoWhereInput'
    cursor: 'SystemInfoWhereUniqueInput'
    distinct: List['SystemInfoScalarFieldKeys']
    include: 'SystemInfoIncludeFromSystemInfo'


class BackupIncludeFromBranchOrder(TypedDict, total=False):
    """Relational arguments for BranchOrder"""
    createdBy: Union[bool, 'UserArgsFromBranchOrder']


class BackupArgsFromBranchOrder(TypedDict, total=False):
    """Arguments for BranchOrder"""
    include: 'BackupIncludeFromBackup'


class FindManyBackupArgsFromBranchOrder(TypedDict, total=False):
    """Arguments for BranchOrder"""
    take: int
    skip: int
    order_by: Union['BackupOrderByInput', List['BackupOrderByInput']]
    where: 'BackupWhereInput'
    cursor: 'BackupWhereUniqueInput'
    distinct: List['BackupScalarFieldKeys']
    include: 'BackupIncludeFromBackup'


class RevokedTokenIncludeFromBranchOrder(TypedDict, total=False):
    """Relational arguments for BranchOrder"""
    user: Union[bool, 'UserArgsFromBranchOrder']


class RevokedTokenArgsFromBranchOrder(TypedDict, total=False):
    """Arguments for BranchOrder"""
    include: 'RevokedTokenIncludeFromRevokedToken'


class FindManyRevokedTokenArgsFromBranchOrder(TypedDict, total=False):
    """Arguments for BranchOrder"""
    take: int
    skip: int
    order_by: Union['RevokedTokenOrderByInput', List['RevokedTokenOrderByInput']]
    where: 'RevokedTokenWhereInput'
    cursor: 'RevokedTokenWhereUniqueInput'
    distinct: List['RevokedTokenScalarFieldKeys']
    include: 'RevokedTokenIncludeFromRevokedToken'


class SystemSettingIncludeFromBranchOrder(TypedDict, total=False):
    """Relational arguments for BranchOrder"""


class SystemSettingArgsFromBranchOrder(TypedDict, total=False):
    """Arguments for BranchOrder"""
    include: 'SystemSettingIncludeFromSystemSetting'


class FindManySystemSettingArgsFromBranchOrder(TypedDict, total=False):
    """Arguments for BranchOrder"""
    take: int
    skip: int
    order_by: Union['SystemSettingOrderByInput', List['SystemSettingOrderByInput']]
    where: 'SystemSettingWhereInput'
    cursor: 'SystemSettingWhereUniqueInput'
    distinct: List['SystemSettingScalarFieldKeys']
    include: 'SystemSettingIncludeFromSystemSetting'


class NotificationIncludeFromBranchOrder(TypedDict, total=False):
    """Relational arguments for BranchOrder"""
    user: Union[bool, 'UserArgsFromBranchOrder']


class NotificationArgsFromBranchOrder(TypedDict, total=False):
    """Arguments for BranchOrder"""
    include: 'NotificationIncludeFromNotification'


class FindManyNotificationArgsFromBranchOrder(TypedDict, total=False):
    """Arguments for BranchOrder"""
    take: int
    skip: int
    order_by: Union['NotificationOrderByInput', List['NotificationOrderByInput']]
    where: 'NotificationWhereInput'
    cursor: 'NotificationWhereUniqueInput'
    distinct: List['NotificationScalarFieldKeys']
    include: 'NotificationIncludeFromNotification'


class StockAdjustmentIncludeFromBranchOrder(TypedDict, total=False):
    """Relational arguments for BranchOrder"""
    product: Union[bool, 'ProductArgsFromBranchOrder']
    createdBy: Union[bool, 'UserArgsFromBranchOrder']


class StockAdjustmentArgsFromBranchOrder(TypedDict, total=False):
    """Arguments for BranchOrder"""
    include: 'StockAdjustmentIncludeFromStockAdjustment'


class FindManyStockAdjustmentArgsFromBranchOrder(TypedDict, total=False):
    """Arguments for BranchOrder"""
    take: int
    skip: int
    order_by: Union['StockAdjustmentOrderByInput', List['StockAdjustmentOrderByInput']]
    where: 'StockAdjustmentWhereInput'
    cursor: 'StockAdjustmentWhereUniqueInput'
    distinct: List['StockAdjustmentScalarFieldKeys']
    include: 'StockAdjustmentIncludeFromStockAdjustment'




FindManyBranchOrderArgs = FindManyBranchOrderArgsFromBranchOrder
FindFirstBranchOrderArgs = FindManyBranchOrderArgsFromBranchOrder


class BranchOrderWhereInput(TypedDict, total=False):
    """BranchOrder arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    branchId: Union[_int, 'types.IntFilter']
    branch: 'BranchRelationFilter'
    requestedById: Union[_int, 'types.IntFilter']
    requestedBy: 'UserRelationFilter'
    approvedById: Union[None, _int, 'types.IntFilter']
    approvedBy: 'UserRelationFilter'
    sentById: Union[None, _int, 'types.IntFilter']
    sentBy: 'UserRelationFilter'
    receivedById: Union[None, _int, 'types.IntFilter']
    receivedBy: 'UserRelationFilter'
    items: 'BranchOrderItemListRelationFilter'
    status: 'enums.BranchOrderStatus'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['BranchOrderWhereInput', List['BranchOrderWhereInput']]
    # but this causes mypy to hang :/
    AND: List['BranchOrderWhereInput']
    OR: List['BranchOrderWhereInput']
    NOT: List['BranchOrderWhereInput']



# aggregate BranchOrder types


class BranchOrderScalarWhereWithAggregatesInput(TypedDict, total=False):
    """BranchOrder arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    branchId: Union[_int, 'types.IntWithAggregatesFilter']
    requestedById: Union[_int, 'types.IntWithAggregatesFilter']
    approvedById: Union[_int, 'types.IntWithAggregatesFilter']
    sentById: Union[_int, 'types.IntWithAggregatesFilter']
    receivedById: Union[_int, 'types.IntWithAggregatesFilter']
    status: 'enums.BranchOrderStatus'
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['BranchOrderScalarWhereWithAggregatesInput']
    OR: List['BranchOrderScalarWhereWithAggregatesInput']
    NOT: List['BranchOrderScalarWhereWithAggregatesInput']



class BranchOrderGroupByOutput(TypedDict, total=False):
    id: _int
    branchId: _int
    requestedById: _int
    approvedById: _int
    sentById: _int
    receivedById: _int
    status: 'enums.BranchOrderStatus'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'BranchOrderSumAggregateOutput'
    _avg: 'BranchOrderAvgAggregateOutput'
    _min: 'BranchOrderMinAggregateOutput'
    _max: 'BranchOrderMaxAggregateOutput'
    _count: 'BranchOrderCountAggregateOutput'


class BranchOrderAvgAggregateOutput(TypedDict, total=False):
    """BranchOrder output for aggregating averages"""
    id: float
    branchId: float
    requestedById: float
    approvedById: float
    sentById: float
    receivedById: float


class BranchOrderSumAggregateOutput(TypedDict, total=False):
    """BranchOrder output for aggregating sums"""
    id: _int
    branchId: _int
    requestedById: _int
    approvedById: _int
    sentById: _int
    receivedById: _int


class BranchOrderScalarAggregateOutput(TypedDict, total=False):
    """BranchOrder output including scalar fields"""
    id: _int
    branchId: _int
    requestedById: _int
    approvedById: _int
    sentById: _int
    receivedById: _int
    status: 'enums.BranchOrderStatus'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


BranchOrderMinAggregateOutput = BranchOrderScalarAggregateOutput
BranchOrderMaxAggregateOutput = BranchOrderScalarAggregateOutput


class BranchOrderMaxAggregateInput(TypedDict, total=False):
    """BranchOrder input for aggregating by max"""
    id: bool
    branchId: bool
    requestedById: bool
    approvedById: bool
    sentById: bool
    receivedById: bool
    status: bool
    createdAt: bool
    updatedAt: bool


class BranchOrderMinAggregateInput(TypedDict, total=False):
    """BranchOrder input for aggregating by min"""
    id: bool
    branchId: bool
    requestedById: bool
    approvedById: bool
    sentById: bool
    receivedById: bool
    status: bool
    createdAt: bool
    updatedAt: bool


class BranchOrderNumberAggregateInput(TypedDict, total=False):
    """BranchOrder input for aggregating numbers"""
    id: bool
    branchId: bool
    requestedById: bool
    approvedById: bool
    sentById: bool
    receivedById: bool


BranchOrderAvgAggregateInput = BranchOrderNumberAggregateInput
BranchOrderSumAggregateInput = BranchOrderNumberAggregateInput


BranchOrderCountAggregateInput = TypedDict(
    'BranchOrderCountAggregateInput',
    {
        'id': bool,
        'branchId': bool,
        'requestedById': bool,
        'approvedById': bool,
        'sentById': bool,
        'receivedById': bool,
        'status': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

BranchOrderCountAggregateOutput = TypedDict(
    'BranchOrderCountAggregateOutput',
    {
        'id': int,
        'branchId': int,
        'requestedById': int,
        'approvedById': int,
        'sentById': int,
        'receivedById': int,
        'status': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


BranchOrderKeys = Literal[
    'id',
    'branchId',
    'branch',
    'requestedById',
    'requestedBy',
    'approvedById',
    'approvedBy',
    'sentById',
    'sentBy',
    'receivedById',
    'receivedBy',
    'items',
    'status',
    'createdAt',
    'updatedAt',
]
BranchOrderScalarFieldKeys = Literal[
    'id',
    'branchId',
    'requestedById',
    'approvedById',
    'sentById',
    'receivedById',
    'status',
    'createdAt',
    'updatedAt',
]
BranchOrderScalarFieldKeysT = TypeVar('BranchOrderScalarFieldKeysT', bound=BranchOrderScalarFieldKeys)

BranchOrderRelationalFieldKeys = Literal[
        'branch',
        'requestedBy',
        'approvedBy',
        'sentBy',
        'receivedBy',
        'items',
    ]

# BranchOrderItem types

class BranchOrderItemOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the BranchOrderItem create method"""
    id: _int
    branchOrderId: _int
    branchOrder: 'BranchOrderCreateNestedWithoutRelationsInput'
    stockId: _int
    stock: 'StockCreateNestedWithoutRelationsInput'
    approvedQty: Optional[_int]
    sentQty: Optional[_int]
    receivedQty: Optional[_int]


class BranchOrderItemCreateInput(BranchOrderItemOptionalCreateInput):
    """Required arguments to the BranchOrderItem create method"""
    requestedQty: _int


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class BranchOrderItemOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the BranchOrderItem create method, without relations"""
    id: _int
    branchOrderId: _int
    stockId: _int
    approvedQty: Optional[_int]
    sentQty: Optional[_int]
    receivedQty: Optional[_int]


class BranchOrderItemCreateWithoutRelationsInput(BranchOrderItemOptionalCreateWithoutRelationsInput):
    """Required arguments to the BranchOrderItem create method, without relations"""
    requestedQty: _int


class BranchOrderItemCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'BranchOrderItemCreateWithoutRelationsInput'
    connect: 'BranchOrderItemWhereUniqueInput'


class BranchOrderItemCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['BranchOrderItemCreateWithoutRelationsInput', List['BranchOrderItemCreateWithoutRelationsInput']]
    connect: Union['BranchOrderItemWhereUniqueInput', List['BranchOrderItemWhereUniqueInput']]


_BranchOrderItemWhereUnique_id_Input = TypedDict(
    '_BranchOrderItemWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

BranchOrderItemWhereUniqueInput = _BranchOrderItemWhereUnique_id_Input


class BranchOrderItemUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    branchOrder: 'BranchOrderUpdateOneWithoutRelationsInput'
    stock: 'StockUpdateOneWithoutRelationsInput'
    requestedQty: Union[AtomicIntInput, _int]
    approvedQty: Optional[Union[AtomicIntInput, _int]]
    sentQty: Optional[Union[AtomicIntInput, _int]]
    receivedQty: Optional[Union[AtomicIntInput, _int]]


class BranchOrderItemUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    requestedQty: Union[AtomicIntInput, _int]
    approvedQty: Optional[Union[AtomicIntInput, _int]]
    sentQty: Optional[Union[AtomicIntInput, _int]]
    receivedQty: Optional[Union[AtomicIntInput, _int]]


class BranchOrderItemUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['BranchOrderItemCreateWithoutRelationsInput']
    connect: List['BranchOrderItemWhereUniqueInput']
    set: List['BranchOrderItemWhereUniqueInput']
    disconnect: List['BranchOrderItemWhereUniqueInput']
    delete: List['BranchOrderItemWhereUniqueInput']

    # TODO
    # update: List['BranchOrderItemUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['BranchOrderItemUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['BranchOrderItemScalarWhereInput']
    # upsert: List['BranchOrderItemUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['BranchOrderItemCreateOrConnectWithoutRelationsInput']


class BranchOrderItemUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'BranchOrderItemCreateWithoutRelationsInput'
    connect: 'BranchOrderItemWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'BranchOrderItemUpdateInput'
    # upsert: 'BranchOrderItemUpsertWithoutRelationsInput'
    # connectOrCreate: 'BranchOrderItemCreateOrConnectWithoutRelationsInput'


class BranchOrderItemUpsertInput(TypedDict):
    create: 'BranchOrderItemCreateInput'
    update: 'BranchOrderItemUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_BranchOrderItem_id_OrderByInput = TypedDict(
    '_BranchOrderItem_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_BranchOrderItem_branchOrderId_OrderByInput = TypedDict(
    '_BranchOrderItem_branchOrderId_OrderByInput',
    {
        'branchOrderId': 'SortOrder',
    },
    total=True
)

_BranchOrderItem_stockId_OrderByInput = TypedDict(
    '_BranchOrderItem_stockId_OrderByInput',
    {
        'stockId': 'SortOrder',
    },
    total=True
)

_BranchOrderItem_requestedQty_OrderByInput = TypedDict(
    '_BranchOrderItem_requestedQty_OrderByInput',
    {
        'requestedQty': 'SortOrder',
    },
    total=True
)

_BranchOrderItem_approvedQty_OrderByInput = TypedDict(
    '_BranchOrderItem_approvedQty_OrderByInput',
    {
        'approvedQty': 'SortOrder',
    },
    total=True
)

_BranchOrderItem_sentQty_OrderByInput = TypedDict(
    '_BranchOrderItem_sentQty_OrderByInput',
    {
        'sentQty': 'SortOrder',
    },
    total=True
)

_BranchOrderItem_receivedQty_OrderByInput = TypedDict(
    '_BranchOrderItem_receivedQty_OrderByInput',
    {
        'receivedQty': 'SortOrder',
    },
    total=True
)

BranchOrderItemOrderByInput = Union[
    '_BranchOrderItem_id_OrderByInput',
    '_BranchOrderItem_branchOrderId_OrderByInput',
    '_BranchOrderItem_stockId_OrderByInput',
    '_BranchOrderItem_requestedQty_OrderByInput',
    '_BranchOrderItem_approvedQty_OrderByInput',
    '_BranchOrderItem_sentQty_OrderByInput',
    '_BranchOrderItem_receivedQty_OrderByInput',
]



# recursive BranchOrderItem types
# TODO: cleanup these types



BranchOrderItemRelationFilter = TypedDict(
    'BranchOrderItemRelationFilter',
    {
        'is': 'BranchOrderItemWhereInput',
        'is_not': 'BranchOrderItemWhereInput',
    },
    total=False,
)


class BranchOrderItemListRelationFilter(TypedDict, total=False):
    some: 'BranchOrderItemWhereInput'
    none: 'BranchOrderItemWhereInput'
    every: 'BranchOrderItemWhereInput'


class BranchOrderItemInclude(TypedDict, total=False):
    """BranchOrderItem relational arguments"""
    branchOrder: Union[bool, 'BranchOrderArgsFromBranchOrderItem']
    stock: Union[bool, 'StockArgsFromBranchOrderItem']


class UserIncludeFromBranchOrderItem(TypedDict, total=False):
    """Relational arguments for BranchOrderItem"""
    branch: Union[bool, 'BranchArgsFromBranchOrderItem']
    auditLogs: Union[bool, 'FindManyAuditLogArgsFromBranchOrderItem']
    permissions: Union[bool, 'FindManyUserPermissionArgsFromBranchOrderItem']
    notifications: Union[bool, 'FindManyNotificationArgsFromBranchOrderItem']
    revokedTokens: Union[bool, 'FindManyRevokedTokenArgsFromBranchOrderItem']
    stockAdjustments: Union[bool, 'FindManyStockAdjustmentArgsFromBranchOrderItem']
    Sale: Union[bool, 'FindManySaleArgsFromBranchOrderItem']
    deletedSales: Union[bool, 'FindManySaleArgsFromBranchOrderItem']
    Payment: Union[bool, 'FindManyPaymentArgsFromBranchOrderItem']
    Backup: Union[bool, 'FindManyBackupArgsFromBranchOrderItem']
    requestedOrders: Union[bool, 'FindManyBranchOrderArgsFromBranchOrderItem']
    approvedOrders: Union[bool, 'FindManyBranchOrderArgsFromBranchOrderItem']
    sentOrders: Union[bool, 'FindManyBranchOrderArgsFromBranchOrderItem']
    receivedOrders: Union[bool, 'FindManyBranchOrderArgsFromBranchOrderItem']


class UserArgsFromBranchOrderItem(TypedDict, total=False):
    """Arguments for BranchOrderItem"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromBranchOrderItem(TypedDict, total=False):
    """Arguments for BranchOrderItem"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class UserPermissionIncludeFromBranchOrderItem(TypedDict, total=False):
    """Relational arguments for BranchOrderItem"""
    user: Union[bool, 'UserArgsFromBranchOrderItem']


class UserPermissionArgsFromBranchOrderItem(TypedDict, total=False):
    """Arguments for BranchOrderItem"""
    include: 'UserPermissionIncludeFromUserPermission'


class FindManyUserPermissionArgsFromBranchOrderItem(TypedDict, total=False):
    """Arguments for BranchOrderItem"""
    take: int
    skip: int
    order_by: Union['UserPermissionOrderByInput', List['UserPermissionOrderByInput']]
    where: 'UserPermissionWhereInput'
    cursor: 'UserPermissionWhereUniqueInput'
    distinct: List['UserPermissionScalarFieldKeys']
    include: 'UserPermissionIncludeFromUserPermission'


class BranchIncludeFromBranchOrderItem(TypedDict, total=False):
    """Relational arguments for BranchOrderItem"""
    users: Union[bool, 'FindManyUserArgsFromBranchOrderItem']
    Sale: Union[bool, 'FindManySaleArgsFromBranchOrderItem']
    Account: Union[bool, 'FindManyAccountArgsFromBranchOrderItem']
    BranchOrder: Union[bool, 'FindManyBranchOrderArgsFromBranchOrderItem']


class BranchArgsFromBranchOrderItem(TypedDict, total=False):
    """Arguments for BranchOrderItem"""
    include: 'BranchIncludeFromBranch'


class FindManyBranchArgsFromBranchOrderItem(TypedDict, total=False):
    """Arguments for BranchOrderItem"""
    take: int
    skip: int
    order_by: Union['BranchOrderByInput', List['BranchOrderByInput']]
    where: 'BranchWhereInput'
    cursor: 'BranchWhereUniqueInput'
    distinct: List['BranchScalarFieldKeys']
    include: 'BranchIncludeFromBranch'


class ProductIncludeFromBranchOrderItem(TypedDict, total=False):
    """Relational arguments for BranchOrderItem"""
    category: Union[bool, 'CategoryArgsFromBranchOrderItem']
    stocks: Union[bool, 'FindManyStockArgsFromBranchOrderItem']
    stockAdjustments: Union[bool, 'FindManyStockAdjustmentArgsFromBranchOrderItem']


class ProductArgsFromBranchOrderItem(TypedDict, total=False):
    """Arguments for BranchOrderItem"""
    include: 'ProductIncludeFromProduct'


class FindManyProductArgsFromBranchOrderItem(TypedDict, total=False):
    """Arguments for BranchOrderItem"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProduct'


class CategoryIncludeFromBranchOrderItem(TypedDict, total=False):
    """Relational arguments for BranchOrderItem"""
    products: Union[bool, 'FindManyProductArgsFromBranchOrderItem']


class CategoryArgsFromBranchOrderItem(TypedDict, total=False):
    """Arguments for BranchOrderItem"""
    include: 'CategoryIncludeFromCategory'


class FindManyCategoryArgsFromBranchOrderItem(TypedDict, total=False):
    """Arguments for BranchOrderItem"""
    take: int
    skip: int
    order_by: Union['CategoryOrderByInput', List['CategoryOrderByInput']]
    where: 'CategoryWhereInput'
    cursor: 'CategoryWhereUniqueInput'
    distinct: List['CategoryScalarFieldKeys']
    include: 'CategoryIncludeFromCategory'


class StockIncludeFromBranchOrderItem(TypedDict, total=False):
    """Relational arguments for BranchOrderItem"""
    product: Union[bool, 'ProductArgsFromBranchOrderItem']
    SaleItem: Union[bool, 'FindManySaleItemArgsFromBranchOrderItem']
    BranchOrderItem: Union[bool, 'FindManyBranchOrderItemArgsFromBranchOrderItem']


class StockArgsFromBranchOrderItem(TypedDict, total=False):
    """Arguments for BranchOrderItem"""
    include: 'StockIncludeFromStock'


class FindManyStockArgsFromBranchOrderItem(TypedDict, total=False):
    """Arguments for BranchOrderItem"""
    take: int
    skip: int
    order_by: Union['StockOrderByInput', List['StockOrderByInput']]
    where: 'StockWhereInput'
    cursor: 'StockWhereUniqueInput'
    distinct: List['StockScalarFieldKeys']
    include: 'StockIncludeFromStock'


class CustomerIncludeFromBranchOrderItem(TypedDict, total=False):
    """Relational arguments for BranchOrderItem"""
    Sale: Union[bool, 'FindManySaleArgsFromBranchOrderItem']


class CustomerArgsFromBranchOrderItem(TypedDict, total=False):
    """Arguments for BranchOrderItem"""
    include: 'CustomerIncludeFromCustomer'


class FindManyCustomerArgsFromBranchOrderItem(TypedDict, total=False):
    """Arguments for BranchOrderItem"""
    take: int
    skip: int
    order_by: Union['CustomerOrderByInput', List['CustomerOrderByInput']]
    where: 'CustomerWhereInput'
    cursor: 'CustomerWhereUniqueInput'
    distinct: List['CustomerScalarFieldKeys']
    include: 'CustomerIncludeFromCustomer'


class SaleIncludeFromBranchOrderItem(TypedDict, total=False):
    """Relational arguments for BranchOrderItem"""
    branch: Union[bool, 'BranchArgsFromBranchOrderItem']
    customer: Union[bool, 'CustomerArgsFromBranchOrderItem']
    user: Union[bool, 'UserArgsFromBranchOrderItem']
    items: Union[bool, 'FindManySaleItemArgsFromBranchOrderItem']
    payments: Union[bool, 'FindManyPaymentArgsFromBranchOrderItem']
    returns: Union[bool, 'FindManyReturnSaleArgsFromBranchOrderItem']
    deletedBy: Union[bool, 'UserArgsFromBranchOrderItem']


class SaleArgsFromBranchOrderItem(TypedDict, total=False):
    """Arguments for BranchOrderItem"""
    include: 'SaleIncludeFromSale'


class FindManySaleArgsFromBranchOrderItem(TypedDict, total=False):
    """Arguments for BranchOrderItem"""
    take: int
    skip: int
    order_by: Union['SaleOrderByInput', List['SaleOrderByInput']]
    where: 'SaleWhereInput'
    cursor: 'SaleWhereUniqueInput'
    distinct: List['SaleScalarFieldKeys']
    include: 'SaleIncludeFromSale'


class SaleItemIncludeFromBranchOrderItem(TypedDict, total=False):
    """Relational arguments for BranchOrderItem"""
    sale: Union[bool, 'SaleArgsFromBranchOrderItem']
    stock: Union[bool, 'StockArgsFromBranchOrderItem']
    ReturnItem: Union[bool, 'FindManyReturnItemArgsFromBranchOrderItem']


class SaleItemArgsFromBranchOrderItem(TypedDict, total=False):
    """Arguments for BranchOrderItem"""
    include: 'SaleItemIncludeFromSaleItem'


class FindManySaleItemArgsFromBranchOrderItem(TypedDict, total=False):
    """Arguments for BranchOrderItem"""
    take: int
    skip: int
    order_by: Union['SaleItemOrderByInput', List['SaleItemOrderByInput']]
    where: 'SaleItemWhereInput'
    cursor: 'SaleItemWhereUniqueInput'
    distinct: List['SaleItemScalarFieldKeys']
    include: 'SaleItemIncludeFromSaleItem'


class ReturnSaleIncludeFromBranchOrderItem(TypedDict, total=False):
    """Relational arguments for BranchOrderItem"""
    original: Union[bool, 'SaleArgsFromBranchOrderItem']
    items: Union[bool, 'FindManyReturnItemArgsFromBranchOrderItem']
    refund: Union[bool, 'FindManyPaymentArgsFromBranchOrderItem']


class ReturnSaleArgsFromBranchOrderItem(TypedDict, total=False):
    """Arguments for BranchOrderItem"""
    include: 'ReturnSaleIncludeFromReturnSale'


class FindManyReturnSaleArgsFromBranchOrderItem(TypedDict, total=False):
    """Arguments for BranchOrderItem"""
    take: int
    skip: int
    order_by: Union['ReturnSaleOrderByInput', List['ReturnSaleOrderByInput']]
    where: 'ReturnSaleWhereInput'
    cursor: 'ReturnSaleWhereUniqueInput'
    distinct: List['ReturnSaleScalarFieldKeys']
    include: 'ReturnSaleIncludeFromReturnSale'


class ReturnItemIncludeFromBranchOrderItem(TypedDict, total=False):
    """Relational arguments for BranchOrderItem"""
    returnSale: Union[bool, 'ReturnSaleArgsFromBranchOrderItem']
    saleItem: Union[bool, 'SaleItemArgsFromBranchOrderItem']


class ReturnItemArgsFromBranchOrderItem(TypedDict, total=False):
    """Arguments for BranchOrderItem"""
    include: 'ReturnItemIncludeFromReturnItem'


class FindManyReturnItemArgsFromBranchOrderItem(TypedDict, total=False):
    """Arguments for BranchOrderItem"""
    take: int
    skip: int
    order_by: Union['ReturnItemOrderByInput', List['ReturnItemOrderByInput']]
    where: 'ReturnItemWhereInput'
    cursor: 'ReturnItemWhereUniqueInput'
    distinct: List['ReturnItemScalarFieldKeys']
    include: 'ReturnItemIncludeFromReturnItem'


class PaymentIncludeFromBranchOrderItem(TypedDict, total=False):
    """Relational arguments for BranchOrderItem"""
    sale: Union[bool, 'SaleArgsFromBranchOrderItem']
    account: Union[bool, 'AccountArgsFromBranchOrderItem']
    returnSale: Union[bool, 'ReturnSaleArgsFromBranchOrderItem']
    user: Union[bool, 'UserArgsFromBranchOrderItem']


class PaymentArgsFromBranchOrderItem(TypedDict, total=False):
    """Arguments for BranchOrderItem"""
    include: 'PaymentIncludeFromPayment'


class FindManyPaymentArgsFromBranchOrderItem(TypedDict, total=False):
    """Arguments for BranchOrderItem"""
    take: int
    skip: int
    order_by: Union['PaymentOrderByInput', List['PaymentOrderByInput']]
    where: 'PaymentWhereInput'
    cursor: 'PaymentWhereUniqueInput'
    distinct: List['PaymentScalarFieldKeys']
    include: 'PaymentIncludeFromPayment'


class JournalEntryIncludeFromBranchOrderItem(TypedDict, total=False):
    """Relational arguments for BranchOrderItem"""
    lines: Union[bool, 'FindManyJournalEntryLineArgsFromBranchOrderItem']


class JournalEntryArgsFromBranchOrderItem(TypedDict, total=False):
    """Arguments for BranchOrderItem"""
    include: 'JournalEntryIncludeFromJournalEntry'


class FindManyJournalEntryArgsFromBranchOrderItem(TypedDict, total=False):
    """Arguments for BranchOrderItem"""
    take: int
    skip: int
    order_by: Union['JournalEntryOrderByInput', List['JournalEntryOrderByInput']]
    where: 'JournalEntryWhereInput'
    cursor: 'JournalEntryWhereUniqueInput'
    distinct: List['JournalEntryScalarFieldKeys']
    include: 'JournalEntryIncludeFromJournalEntry'


class JournalEntryLineIncludeFromBranchOrderItem(TypedDict, total=False):
    """Relational arguments for BranchOrderItem"""
    entry: Union[bool, 'JournalEntryArgsFromBranchOrderItem']
    account: Union[bool, 'AccountArgsFromBranchOrderItem']


class JournalEntryLineArgsFromBranchOrderItem(TypedDict, total=False):
    """Arguments for BranchOrderItem"""
    include: 'JournalEntryLineIncludeFromJournalEntryLine'


class FindManyJournalEntryLineArgsFromBranchOrderItem(TypedDict, total=False):
    """Arguments for BranchOrderItem"""
    take: int
    skip: int
    order_by: Union['JournalEntryLineOrderByInput', List['JournalEntryLineOrderByInput']]
    where: 'JournalEntryLineWhereInput'
    cursor: 'JournalEntryLineWhereUniqueInput'
    distinct: List['JournalEntryLineScalarFieldKeys']
    include: 'JournalEntryLineIncludeFromJournalEntryLine'


class AccountIncludeFromBranchOrderItem(TypedDict, total=False):
    """Relational arguments for BranchOrderItem"""
    branch: Union[bool, 'BranchArgsFromBranchOrderItem']
    entries: Union[bool, 'FindManyJournalEntryLineArgsFromBranchOrderItem']
    payments: Union[bool, 'FindManyPaymentArgsFromBranchOrderItem']
    outgoingTransfers: Union[bool, 'FindManyAccountTransferArgsFromBranchOrderItem']
    incomingTransfers: Union[bool, 'FindManyAccountTransferArgsFromBranchOrderItem']


class AccountArgsFromBranchOrderItem(TypedDict, total=False):
    """Arguments for BranchOrderItem"""
    include: 'AccountIncludeFromAccount'


class FindManyAccountArgsFromBranchOrderItem(TypedDict, total=False):
    """Arguments for BranchOrderItem"""
    take: int
    skip: int
    order_by: Union['AccountOrderByInput', List['AccountOrderByInput']]
    where: 'AccountWhereInput'
    cursor: 'AccountWhereUniqueInput'
    distinct: List['AccountScalarFieldKeys']
    include: 'AccountIncludeFromAccount'


class AccountTransferIncludeFromBranchOrderItem(TypedDict, total=False):
    """Relational arguments for BranchOrderItem"""
    fromAccount: Union[bool, 'AccountArgsFromBranchOrderItem']
    toAccount: Union[bool, 'AccountArgsFromBranchOrderItem']


class AccountTransferArgsFromBranchOrderItem(TypedDict, total=False):
    """Arguments for BranchOrderItem"""
    include: 'AccountTransferIncludeFromAccountTransfer'


class FindManyAccountTransferArgsFromBranchOrderItem(TypedDict, total=False):
    """Arguments for BranchOrderItem"""
    take: int
    skip: int
    order_by: Union['AccountTransferOrderByInput', List['AccountTransferOrderByInput']]
    where: 'AccountTransferWhereInput'
    cursor: 'AccountTransferWhereUniqueInput'
    distinct: List['AccountTransferScalarFieldKeys']
    include: 'AccountTransferIncludeFromAccountTransfer'


class BranchOrderIncludeFromBranchOrderItem(TypedDict, total=False):
    """Relational arguments for BranchOrderItem"""
    branch: Union[bool, 'BranchArgsFromBranchOrderItem']
    requestedBy: Union[bool, 'UserArgsFromBranchOrderItem']
    approvedBy: Union[bool, 'UserArgsFromBranchOrderItem']
    sentBy: Union[bool, 'UserArgsFromBranchOrderItem']
    receivedBy: Union[bool, 'UserArgsFromBranchOrderItem']
    items: Union[bool, 'FindManyBranchOrderItemArgsFromBranchOrderItem']


class BranchOrderArgsFromBranchOrderItem(TypedDict, total=False):
    """Arguments for BranchOrderItem"""
    include: 'BranchOrderIncludeFromBranchOrder'


class FindManyBranchOrderArgsFromBranchOrderItem(TypedDict, total=False):
    """Arguments for BranchOrderItem"""
    take: int
    skip: int
    order_by: Union['BranchOrderOrderByInput', List['BranchOrderOrderByInput']]
    where: 'BranchOrderWhereInput'
    cursor: 'BranchOrderWhereUniqueInput'
    distinct: List['BranchOrderScalarFieldKeys']
    include: 'BranchOrderIncludeFromBranchOrder'


class BranchOrderItemIncludeFromBranchOrderItem(TypedDict, total=False):
    """Relational arguments for BranchOrderItem"""
    branchOrder: Union[bool, 'BranchOrderArgsFromBranchOrderItem']
    stock: Union[bool, 'StockArgsFromBranchOrderItem']


class BranchOrderItemArgsFromBranchOrderItem(TypedDict, total=False):
    """Arguments for BranchOrderItem"""
    include: 'BranchOrderItemIncludeFromBranchOrderItem'


class FindManyBranchOrderItemArgsFromBranchOrderItem(TypedDict, total=False):
    """Arguments for BranchOrderItem"""
    take: int
    skip: int
    order_by: Union['BranchOrderItemOrderByInput', List['BranchOrderItemOrderByInput']]
    where: 'BranchOrderItemWhereInput'
    cursor: 'BranchOrderItemWhereUniqueInput'
    distinct: List['BranchOrderItemScalarFieldKeys']
    include: 'BranchOrderItemIncludeFromBranchOrderItem'


class AuditLogIncludeFromBranchOrderItem(TypedDict, total=False):
    """Relational arguments for BranchOrderItem"""
    user: Union[bool, 'UserArgsFromBranchOrderItem']


class AuditLogArgsFromBranchOrderItem(TypedDict, total=False):
    """Arguments for BranchOrderItem"""
    include: 'AuditLogIncludeFromAuditLog'


class FindManyAuditLogArgsFromBranchOrderItem(TypedDict, total=False):
    """Arguments for BranchOrderItem"""
    take: int
    skip: int
    order_by: Union['AuditLogOrderByInput', List['AuditLogOrderByInput']]
    where: 'AuditLogWhereInput'
    cursor: 'AuditLogWhereUniqueInput'
    distinct: List['AuditLogScalarFieldKeys']
    include: 'AuditLogIncludeFromAuditLog'


class SystemInfoIncludeFromBranchOrderItem(TypedDict, total=False):
    """Relational arguments for BranchOrderItem"""


class SystemInfoArgsFromBranchOrderItem(TypedDict, total=False):
    """Arguments for BranchOrderItem"""
    include: 'SystemInfoIncludeFromSystemInfo'


class FindManySystemInfoArgsFromBranchOrderItem(TypedDict, total=False):
    """Arguments for BranchOrderItem"""
    take: int
    skip: int
    order_by: Union['SystemInfoOrderByInput', List['SystemInfoOrderByInput']]
    where: 'SystemInfoWhereInput'
    cursor: 'SystemInfoWhereUniqueInput'
    distinct: List['SystemInfoScalarFieldKeys']
    include: 'SystemInfoIncludeFromSystemInfo'


class BackupIncludeFromBranchOrderItem(TypedDict, total=False):
    """Relational arguments for BranchOrderItem"""
    createdBy: Union[bool, 'UserArgsFromBranchOrderItem']


class BackupArgsFromBranchOrderItem(TypedDict, total=False):
    """Arguments for BranchOrderItem"""
    include: 'BackupIncludeFromBackup'


class FindManyBackupArgsFromBranchOrderItem(TypedDict, total=False):
    """Arguments for BranchOrderItem"""
    take: int
    skip: int
    order_by: Union['BackupOrderByInput', List['BackupOrderByInput']]
    where: 'BackupWhereInput'
    cursor: 'BackupWhereUniqueInput'
    distinct: List['BackupScalarFieldKeys']
    include: 'BackupIncludeFromBackup'


class RevokedTokenIncludeFromBranchOrderItem(TypedDict, total=False):
    """Relational arguments for BranchOrderItem"""
    user: Union[bool, 'UserArgsFromBranchOrderItem']


class RevokedTokenArgsFromBranchOrderItem(TypedDict, total=False):
    """Arguments for BranchOrderItem"""
    include: 'RevokedTokenIncludeFromRevokedToken'


class FindManyRevokedTokenArgsFromBranchOrderItem(TypedDict, total=False):
    """Arguments for BranchOrderItem"""
    take: int
    skip: int
    order_by: Union['RevokedTokenOrderByInput', List['RevokedTokenOrderByInput']]
    where: 'RevokedTokenWhereInput'
    cursor: 'RevokedTokenWhereUniqueInput'
    distinct: List['RevokedTokenScalarFieldKeys']
    include: 'RevokedTokenIncludeFromRevokedToken'


class SystemSettingIncludeFromBranchOrderItem(TypedDict, total=False):
    """Relational arguments for BranchOrderItem"""


class SystemSettingArgsFromBranchOrderItem(TypedDict, total=False):
    """Arguments for BranchOrderItem"""
    include: 'SystemSettingIncludeFromSystemSetting'


class FindManySystemSettingArgsFromBranchOrderItem(TypedDict, total=False):
    """Arguments for BranchOrderItem"""
    take: int
    skip: int
    order_by: Union['SystemSettingOrderByInput', List['SystemSettingOrderByInput']]
    where: 'SystemSettingWhereInput'
    cursor: 'SystemSettingWhereUniqueInput'
    distinct: List['SystemSettingScalarFieldKeys']
    include: 'SystemSettingIncludeFromSystemSetting'


class NotificationIncludeFromBranchOrderItem(TypedDict, total=False):
    """Relational arguments for BranchOrderItem"""
    user: Union[bool, 'UserArgsFromBranchOrderItem']


class NotificationArgsFromBranchOrderItem(TypedDict, total=False):
    """Arguments for BranchOrderItem"""
    include: 'NotificationIncludeFromNotification'


class FindManyNotificationArgsFromBranchOrderItem(TypedDict, total=False):
    """Arguments for BranchOrderItem"""
    take: int
    skip: int
    order_by: Union['NotificationOrderByInput', List['NotificationOrderByInput']]
    where: 'NotificationWhereInput'
    cursor: 'NotificationWhereUniqueInput'
    distinct: List['NotificationScalarFieldKeys']
    include: 'NotificationIncludeFromNotification'


class StockAdjustmentIncludeFromBranchOrderItem(TypedDict, total=False):
    """Relational arguments for BranchOrderItem"""
    product: Union[bool, 'ProductArgsFromBranchOrderItem']
    createdBy: Union[bool, 'UserArgsFromBranchOrderItem']


class StockAdjustmentArgsFromBranchOrderItem(TypedDict, total=False):
    """Arguments for BranchOrderItem"""
    include: 'StockAdjustmentIncludeFromStockAdjustment'


class FindManyStockAdjustmentArgsFromBranchOrderItem(TypedDict, total=False):
    """Arguments for BranchOrderItem"""
    take: int
    skip: int
    order_by: Union['StockAdjustmentOrderByInput', List['StockAdjustmentOrderByInput']]
    where: 'StockAdjustmentWhereInput'
    cursor: 'StockAdjustmentWhereUniqueInput'
    distinct: List['StockAdjustmentScalarFieldKeys']
    include: 'StockAdjustmentIncludeFromStockAdjustment'




FindManyBranchOrderItemArgs = FindManyBranchOrderItemArgsFromBranchOrderItem
FindFirstBranchOrderItemArgs = FindManyBranchOrderItemArgsFromBranchOrderItem


class BranchOrderItemWhereInput(TypedDict, total=False):
    """BranchOrderItem arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    branchOrderId: Union[_int, 'types.IntFilter']
    branchOrder: 'BranchOrderRelationFilter'
    stockId: Union[_int, 'types.IntFilter']
    stock: 'StockRelationFilter'
    requestedQty: Union[_int, 'types.IntFilter']
    approvedQty: Union[None, _int, 'types.IntFilter']
    sentQty: Union[None, _int, 'types.IntFilter']
    receivedQty: Union[None, _int, 'types.IntFilter']

    # should be noted that AND and NOT should be Union['BranchOrderItemWhereInput', List['BranchOrderItemWhereInput']]
    # but this causes mypy to hang :/
    AND: List['BranchOrderItemWhereInput']
    OR: List['BranchOrderItemWhereInput']
    NOT: List['BranchOrderItemWhereInput']



# aggregate BranchOrderItem types


class BranchOrderItemScalarWhereWithAggregatesInput(TypedDict, total=False):
    """BranchOrderItem arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    branchOrderId: Union[_int, 'types.IntWithAggregatesFilter']
    stockId: Union[_int, 'types.IntWithAggregatesFilter']
    requestedQty: Union[_int, 'types.IntWithAggregatesFilter']
    approvedQty: Union[_int, 'types.IntWithAggregatesFilter']
    sentQty: Union[_int, 'types.IntWithAggregatesFilter']
    receivedQty: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['BranchOrderItemScalarWhereWithAggregatesInput']
    OR: List['BranchOrderItemScalarWhereWithAggregatesInput']
    NOT: List['BranchOrderItemScalarWhereWithAggregatesInput']



class BranchOrderItemGroupByOutput(TypedDict, total=False):
    id: _int
    branchOrderId: _int
    stockId: _int
    requestedQty: _int
    approvedQty: _int
    sentQty: _int
    receivedQty: _int
    _sum: 'BranchOrderItemSumAggregateOutput'
    _avg: 'BranchOrderItemAvgAggregateOutput'
    _min: 'BranchOrderItemMinAggregateOutput'
    _max: 'BranchOrderItemMaxAggregateOutput'
    _count: 'BranchOrderItemCountAggregateOutput'


class BranchOrderItemAvgAggregateOutput(TypedDict, total=False):
    """BranchOrderItem output for aggregating averages"""
    id: float
    branchOrderId: float
    stockId: float
    requestedQty: float
    approvedQty: float
    sentQty: float
    receivedQty: float


class BranchOrderItemSumAggregateOutput(TypedDict, total=False):
    """BranchOrderItem output for aggregating sums"""
    id: _int
    branchOrderId: _int
    stockId: _int
    requestedQty: _int
    approvedQty: _int
    sentQty: _int
    receivedQty: _int


class BranchOrderItemScalarAggregateOutput(TypedDict, total=False):
    """BranchOrderItem output including scalar fields"""
    id: _int
    branchOrderId: _int
    stockId: _int
    requestedQty: _int
    approvedQty: _int
    sentQty: _int
    receivedQty: _int


BranchOrderItemMinAggregateOutput = BranchOrderItemScalarAggregateOutput
BranchOrderItemMaxAggregateOutput = BranchOrderItemScalarAggregateOutput


class BranchOrderItemMaxAggregateInput(TypedDict, total=False):
    """BranchOrderItem input for aggregating by max"""
    id: bool
    branchOrderId: bool
    stockId: bool
    requestedQty: bool
    approvedQty: bool
    sentQty: bool
    receivedQty: bool


class BranchOrderItemMinAggregateInput(TypedDict, total=False):
    """BranchOrderItem input for aggregating by min"""
    id: bool
    branchOrderId: bool
    stockId: bool
    requestedQty: bool
    approvedQty: bool
    sentQty: bool
    receivedQty: bool


class BranchOrderItemNumberAggregateInput(TypedDict, total=False):
    """BranchOrderItem input for aggregating numbers"""
    id: bool
    branchOrderId: bool
    stockId: bool
    requestedQty: bool
    approvedQty: bool
    sentQty: bool
    receivedQty: bool


BranchOrderItemAvgAggregateInput = BranchOrderItemNumberAggregateInput
BranchOrderItemSumAggregateInput = BranchOrderItemNumberAggregateInput


BranchOrderItemCountAggregateInput = TypedDict(
    'BranchOrderItemCountAggregateInput',
    {
        'id': bool,
        'branchOrderId': bool,
        'stockId': bool,
        'requestedQty': bool,
        'approvedQty': bool,
        'sentQty': bool,
        'receivedQty': bool,
        '_all': bool,
    },
    total=False,
)

BranchOrderItemCountAggregateOutput = TypedDict(
    'BranchOrderItemCountAggregateOutput',
    {
        'id': int,
        'branchOrderId': int,
        'stockId': int,
        'requestedQty': int,
        'approvedQty': int,
        'sentQty': int,
        'receivedQty': int,
        '_all': int,
    },
    total=False,
)


BranchOrderItemKeys = Literal[
    'id',
    'branchOrderId',
    'branchOrder',
    'stockId',
    'stock',
    'requestedQty',
    'approvedQty',
    'sentQty',
    'receivedQty',
]
BranchOrderItemScalarFieldKeys = Literal[
    'id',
    'branchOrderId',
    'stockId',
    'requestedQty',
    'approvedQty',
    'sentQty',
    'receivedQty',
]
BranchOrderItemScalarFieldKeysT = TypeVar('BranchOrderItemScalarFieldKeysT', bound=BranchOrderItemScalarFieldKeys)

BranchOrderItemRelationalFieldKeys = Literal[
        'branchOrder',
        'stock',
    ]

# AuditLog types

class AuditLogOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the AuditLog create method"""
    id: _int
    user: 'UserCreateNestedWithoutRelationsInput'
    userId: Optional[_int]
    entityType: Optional[_str]
    entityId: Optional[_str]
    oldValues: Optional['fields.Json']
    newValues: Optional['fields.Json']
    severity: 'enums.AuditSeverity'
    ipAddress: Optional[_str]
    userAgent: Optional[_str]
    createdAt: datetime.datetime


class AuditLogCreateInput(AuditLogOptionalCreateInput):
    """Required arguments to the AuditLog create method"""
    action: 'enums.AuditAction'


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class AuditLogOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the AuditLog create method, without relations"""
    id: _int
    userId: Optional[_int]
    entityType: Optional[_str]
    entityId: Optional[_str]
    oldValues: Optional['fields.Json']
    newValues: Optional['fields.Json']
    severity: 'enums.AuditSeverity'
    ipAddress: Optional[_str]
    userAgent: Optional[_str]
    createdAt: datetime.datetime


class AuditLogCreateWithoutRelationsInput(AuditLogOptionalCreateWithoutRelationsInput):
    """Required arguments to the AuditLog create method, without relations"""
    action: 'enums.AuditAction'


class AuditLogCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'AuditLogCreateWithoutRelationsInput'
    connect: 'AuditLogWhereUniqueInput'


class AuditLogCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['AuditLogCreateWithoutRelationsInput', List['AuditLogCreateWithoutRelationsInput']]
    connect: Union['AuditLogWhereUniqueInput', List['AuditLogWhereUniqueInput']]


_AuditLogWhereUnique_id_Input = TypedDict(
    '_AuditLogWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

AuditLogWhereUniqueInput = _AuditLogWhereUnique_id_Input


class AuditLogUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    user: 'UserUpdateOneWithoutRelationsInput'
    action: 'enums.AuditAction'
    entityType: Optional[_str]
    entityId: Optional[_str]
    oldValues: Optional['fields.Json']
    newValues: Optional['fields.Json']
    severity: 'enums.AuditSeverity'
    ipAddress: Optional[_str]
    userAgent: Optional[_str]
    createdAt: datetime.datetime


class AuditLogUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    action: 'enums.AuditAction'
    entityType: Optional[_str]
    entityId: Optional[_str]
    oldValues: Optional['fields.Json']
    newValues: Optional['fields.Json']
    severity: 'enums.AuditSeverity'
    ipAddress: Optional[_str]
    userAgent: Optional[_str]
    createdAt: datetime.datetime


class AuditLogUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['AuditLogCreateWithoutRelationsInput']
    connect: List['AuditLogWhereUniqueInput']
    set: List['AuditLogWhereUniqueInput']
    disconnect: List['AuditLogWhereUniqueInput']
    delete: List['AuditLogWhereUniqueInput']

    # TODO
    # update: List['AuditLogUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['AuditLogUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['AuditLogScalarWhereInput']
    # upsert: List['AuditLogUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['AuditLogCreateOrConnectWithoutRelationsInput']


class AuditLogUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'AuditLogCreateWithoutRelationsInput'
    connect: 'AuditLogWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'AuditLogUpdateInput'
    # upsert: 'AuditLogUpsertWithoutRelationsInput'
    # connectOrCreate: 'AuditLogCreateOrConnectWithoutRelationsInput'


class AuditLogUpsertInput(TypedDict):
    create: 'AuditLogCreateInput'
    update: 'AuditLogUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_AuditLog_id_OrderByInput = TypedDict(
    '_AuditLog_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_AuditLog_userId_OrderByInput = TypedDict(
    '_AuditLog_userId_OrderByInput',
    {
        'userId': 'SortOrder',
    },
    total=True
)

_AuditLog_action_OrderByInput = TypedDict(
    '_AuditLog_action_OrderByInput',
    {
        'action': 'SortOrder',
    },
    total=True
)

_AuditLog_entityType_OrderByInput = TypedDict(
    '_AuditLog_entityType_OrderByInput',
    {
        'entityType': 'SortOrder',
    },
    total=True
)

_AuditLog_entityId_OrderByInput = TypedDict(
    '_AuditLog_entityId_OrderByInput',
    {
        'entityId': 'SortOrder',
    },
    total=True
)

_AuditLog_oldValues_OrderByInput = TypedDict(
    '_AuditLog_oldValues_OrderByInput',
    {
        'oldValues': 'SortOrder',
    },
    total=True
)

_AuditLog_newValues_OrderByInput = TypedDict(
    '_AuditLog_newValues_OrderByInput',
    {
        'newValues': 'SortOrder',
    },
    total=True
)

_AuditLog_severity_OrderByInput = TypedDict(
    '_AuditLog_severity_OrderByInput',
    {
        'severity': 'SortOrder',
    },
    total=True
)

_AuditLog_ipAddress_OrderByInput = TypedDict(
    '_AuditLog_ipAddress_OrderByInput',
    {
        'ipAddress': 'SortOrder',
    },
    total=True
)

_AuditLog_userAgent_OrderByInput = TypedDict(
    '_AuditLog_userAgent_OrderByInput',
    {
        'userAgent': 'SortOrder',
    },
    total=True
)

_AuditLog_createdAt_OrderByInput = TypedDict(
    '_AuditLog_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

AuditLogOrderByInput = Union[
    '_AuditLog_id_OrderByInput',
    '_AuditLog_userId_OrderByInput',
    '_AuditLog_action_OrderByInput',
    '_AuditLog_entityType_OrderByInput',
    '_AuditLog_entityId_OrderByInput',
    '_AuditLog_oldValues_OrderByInput',
    '_AuditLog_newValues_OrderByInput',
    '_AuditLog_severity_OrderByInput',
    '_AuditLog_ipAddress_OrderByInput',
    '_AuditLog_userAgent_OrderByInput',
    '_AuditLog_createdAt_OrderByInput',
]



# recursive AuditLog types
# TODO: cleanup these types



AuditLogRelationFilter = TypedDict(
    'AuditLogRelationFilter',
    {
        'is': 'AuditLogWhereInput',
        'is_not': 'AuditLogWhereInput',
    },
    total=False,
)


class AuditLogListRelationFilter(TypedDict, total=False):
    some: 'AuditLogWhereInput'
    none: 'AuditLogWhereInput'
    every: 'AuditLogWhereInput'


class AuditLogInclude(TypedDict, total=False):
    """AuditLog relational arguments"""
    user: Union[bool, 'UserArgsFromAuditLog']


class UserIncludeFromAuditLog(TypedDict, total=False):
    """Relational arguments for AuditLog"""
    branch: Union[bool, 'BranchArgsFromAuditLog']
    auditLogs: Union[bool, 'FindManyAuditLogArgsFromAuditLog']
    permissions: Union[bool, 'FindManyUserPermissionArgsFromAuditLog']
    notifications: Union[bool, 'FindManyNotificationArgsFromAuditLog']
    revokedTokens: Union[bool, 'FindManyRevokedTokenArgsFromAuditLog']
    stockAdjustments: Union[bool, 'FindManyStockAdjustmentArgsFromAuditLog']
    Sale: Union[bool, 'FindManySaleArgsFromAuditLog']
    deletedSales: Union[bool, 'FindManySaleArgsFromAuditLog']
    Payment: Union[bool, 'FindManyPaymentArgsFromAuditLog']
    Backup: Union[bool, 'FindManyBackupArgsFromAuditLog']
    requestedOrders: Union[bool, 'FindManyBranchOrderArgsFromAuditLog']
    approvedOrders: Union[bool, 'FindManyBranchOrderArgsFromAuditLog']
    sentOrders: Union[bool, 'FindManyBranchOrderArgsFromAuditLog']
    receivedOrders: Union[bool, 'FindManyBranchOrderArgsFromAuditLog']


class UserArgsFromAuditLog(TypedDict, total=False):
    """Arguments for AuditLog"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromAuditLog(TypedDict, total=False):
    """Arguments for AuditLog"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class UserPermissionIncludeFromAuditLog(TypedDict, total=False):
    """Relational arguments for AuditLog"""
    user: Union[bool, 'UserArgsFromAuditLog']


class UserPermissionArgsFromAuditLog(TypedDict, total=False):
    """Arguments for AuditLog"""
    include: 'UserPermissionIncludeFromUserPermission'


class FindManyUserPermissionArgsFromAuditLog(TypedDict, total=False):
    """Arguments for AuditLog"""
    take: int
    skip: int
    order_by: Union['UserPermissionOrderByInput', List['UserPermissionOrderByInput']]
    where: 'UserPermissionWhereInput'
    cursor: 'UserPermissionWhereUniqueInput'
    distinct: List['UserPermissionScalarFieldKeys']
    include: 'UserPermissionIncludeFromUserPermission'


class BranchIncludeFromAuditLog(TypedDict, total=False):
    """Relational arguments for AuditLog"""
    users: Union[bool, 'FindManyUserArgsFromAuditLog']
    Sale: Union[bool, 'FindManySaleArgsFromAuditLog']
    Account: Union[bool, 'FindManyAccountArgsFromAuditLog']
    BranchOrder: Union[bool, 'FindManyBranchOrderArgsFromAuditLog']


class BranchArgsFromAuditLog(TypedDict, total=False):
    """Arguments for AuditLog"""
    include: 'BranchIncludeFromBranch'


class FindManyBranchArgsFromAuditLog(TypedDict, total=False):
    """Arguments for AuditLog"""
    take: int
    skip: int
    order_by: Union['BranchOrderByInput', List['BranchOrderByInput']]
    where: 'BranchWhereInput'
    cursor: 'BranchWhereUniqueInput'
    distinct: List['BranchScalarFieldKeys']
    include: 'BranchIncludeFromBranch'


class ProductIncludeFromAuditLog(TypedDict, total=False):
    """Relational arguments for AuditLog"""
    category: Union[bool, 'CategoryArgsFromAuditLog']
    stocks: Union[bool, 'FindManyStockArgsFromAuditLog']
    stockAdjustments: Union[bool, 'FindManyStockAdjustmentArgsFromAuditLog']


class ProductArgsFromAuditLog(TypedDict, total=False):
    """Arguments for AuditLog"""
    include: 'ProductIncludeFromProduct'


class FindManyProductArgsFromAuditLog(TypedDict, total=False):
    """Arguments for AuditLog"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProduct'


class CategoryIncludeFromAuditLog(TypedDict, total=False):
    """Relational arguments for AuditLog"""
    products: Union[bool, 'FindManyProductArgsFromAuditLog']


class CategoryArgsFromAuditLog(TypedDict, total=False):
    """Arguments for AuditLog"""
    include: 'CategoryIncludeFromCategory'


class FindManyCategoryArgsFromAuditLog(TypedDict, total=False):
    """Arguments for AuditLog"""
    take: int
    skip: int
    order_by: Union['CategoryOrderByInput', List['CategoryOrderByInput']]
    where: 'CategoryWhereInput'
    cursor: 'CategoryWhereUniqueInput'
    distinct: List['CategoryScalarFieldKeys']
    include: 'CategoryIncludeFromCategory'


class StockIncludeFromAuditLog(TypedDict, total=False):
    """Relational arguments for AuditLog"""
    product: Union[bool, 'ProductArgsFromAuditLog']
    SaleItem: Union[bool, 'FindManySaleItemArgsFromAuditLog']
    BranchOrderItem: Union[bool, 'FindManyBranchOrderItemArgsFromAuditLog']


class StockArgsFromAuditLog(TypedDict, total=False):
    """Arguments for AuditLog"""
    include: 'StockIncludeFromStock'


class FindManyStockArgsFromAuditLog(TypedDict, total=False):
    """Arguments for AuditLog"""
    take: int
    skip: int
    order_by: Union['StockOrderByInput', List['StockOrderByInput']]
    where: 'StockWhereInput'
    cursor: 'StockWhereUniqueInput'
    distinct: List['StockScalarFieldKeys']
    include: 'StockIncludeFromStock'


class CustomerIncludeFromAuditLog(TypedDict, total=False):
    """Relational arguments for AuditLog"""
    Sale: Union[bool, 'FindManySaleArgsFromAuditLog']


class CustomerArgsFromAuditLog(TypedDict, total=False):
    """Arguments for AuditLog"""
    include: 'CustomerIncludeFromCustomer'


class FindManyCustomerArgsFromAuditLog(TypedDict, total=False):
    """Arguments for AuditLog"""
    take: int
    skip: int
    order_by: Union['CustomerOrderByInput', List['CustomerOrderByInput']]
    where: 'CustomerWhereInput'
    cursor: 'CustomerWhereUniqueInput'
    distinct: List['CustomerScalarFieldKeys']
    include: 'CustomerIncludeFromCustomer'


class SaleIncludeFromAuditLog(TypedDict, total=False):
    """Relational arguments for AuditLog"""
    branch: Union[bool, 'BranchArgsFromAuditLog']
    customer: Union[bool, 'CustomerArgsFromAuditLog']
    user: Union[bool, 'UserArgsFromAuditLog']
    items: Union[bool, 'FindManySaleItemArgsFromAuditLog']
    payments: Union[bool, 'FindManyPaymentArgsFromAuditLog']
    returns: Union[bool, 'FindManyReturnSaleArgsFromAuditLog']
    deletedBy: Union[bool, 'UserArgsFromAuditLog']


class SaleArgsFromAuditLog(TypedDict, total=False):
    """Arguments for AuditLog"""
    include: 'SaleIncludeFromSale'


class FindManySaleArgsFromAuditLog(TypedDict, total=False):
    """Arguments for AuditLog"""
    take: int
    skip: int
    order_by: Union['SaleOrderByInput', List['SaleOrderByInput']]
    where: 'SaleWhereInput'
    cursor: 'SaleWhereUniqueInput'
    distinct: List['SaleScalarFieldKeys']
    include: 'SaleIncludeFromSale'


class SaleItemIncludeFromAuditLog(TypedDict, total=False):
    """Relational arguments for AuditLog"""
    sale: Union[bool, 'SaleArgsFromAuditLog']
    stock: Union[bool, 'StockArgsFromAuditLog']
    ReturnItem: Union[bool, 'FindManyReturnItemArgsFromAuditLog']


class SaleItemArgsFromAuditLog(TypedDict, total=False):
    """Arguments for AuditLog"""
    include: 'SaleItemIncludeFromSaleItem'


class FindManySaleItemArgsFromAuditLog(TypedDict, total=False):
    """Arguments for AuditLog"""
    take: int
    skip: int
    order_by: Union['SaleItemOrderByInput', List['SaleItemOrderByInput']]
    where: 'SaleItemWhereInput'
    cursor: 'SaleItemWhereUniqueInput'
    distinct: List['SaleItemScalarFieldKeys']
    include: 'SaleItemIncludeFromSaleItem'


class ReturnSaleIncludeFromAuditLog(TypedDict, total=False):
    """Relational arguments for AuditLog"""
    original: Union[bool, 'SaleArgsFromAuditLog']
    items: Union[bool, 'FindManyReturnItemArgsFromAuditLog']
    refund: Union[bool, 'FindManyPaymentArgsFromAuditLog']


class ReturnSaleArgsFromAuditLog(TypedDict, total=False):
    """Arguments for AuditLog"""
    include: 'ReturnSaleIncludeFromReturnSale'


class FindManyReturnSaleArgsFromAuditLog(TypedDict, total=False):
    """Arguments for AuditLog"""
    take: int
    skip: int
    order_by: Union['ReturnSaleOrderByInput', List['ReturnSaleOrderByInput']]
    where: 'ReturnSaleWhereInput'
    cursor: 'ReturnSaleWhereUniqueInput'
    distinct: List['ReturnSaleScalarFieldKeys']
    include: 'ReturnSaleIncludeFromReturnSale'


class ReturnItemIncludeFromAuditLog(TypedDict, total=False):
    """Relational arguments for AuditLog"""
    returnSale: Union[bool, 'ReturnSaleArgsFromAuditLog']
    saleItem: Union[bool, 'SaleItemArgsFromAuditLog']


class ReturnItemArgsFromAuditLog(TypedDict, total=False):
    """Arguments for AuditLog"""
    include: 'ReturnItemIncludeFromReturnItem'


class FindManyReturnItemArgsFromAuditLog(TypedDict, total=False):
    """Arguments for AuditLog"""
    take: int
    skip: int
    order_by: Union['ReturnItemOrderByInput', List['ReturnItemOrderByInput']]
    where: 'ReturnItemWhereInput'
    cursor: 'ReturnItemWhereUniqueInput'
    distinct: List['ReturnItemScalarFieldKeys']
    include: 'ReturnItemIncludeFromReturnItem'


class PaymentIncludeFromAuditLog(TypedDict, total=False):
    """Relational arguments for AuditLog"""
    sale: Union[bool, 'SaleArgsFromAuditLog']
    account: Union[bool, 'AccountArgsFromAuditLog']
    returnSale: Union[bool, 'ReturnSaleArgsFromAuditLog']
    user: Union[bool, 'UserArgsFromAuditLog']


class PaymentArgsFromAuditLog(TypedDict, total=False):
    """Arguments for AuditLog"""
    include: 'PaymentIncludeFromPayment'


class FindManyPaymentArgsFromAuditLog(TypedDict, total=False):
    """Arguments for AuditLog"""
    take: int
    skip: int
    order_by: Union['PaymentOrderByInput', List['PaymentOrderByInput']]
    where: 'PaymentWhereInput'
    cursor: 'PaymentWhereUniqueInput'
    distinct: List['PaymentScalarFieldKeys']
    include: 'PaymentIncludeFromPayment'


class JournalEntryIncludeFromAuditLog(TypedDict, total=False):
    """Relational arguments for AuditLog"""
    lines: Union[bool, 'FindManyJournalEntryLineArgsFromAuditLog']


class JournalEntryArgsFromAuditLog(TypedDict, total=False):
    """Arguments for AuditLog"""
    include: 'JournalEntryIncludeFromJournalEntry'


class FindManyJournalEntryArgsFromAuditLog(TypedDict, total=False):
    """Arguments for AuditLog"""
    take: int
    skip: int
    order_by: Union['JournalEntryOrderByInput', List['JournalEntryOrderByInput']]
    where: 'JournalEntryWhereInput'
    cursor: 'JournalEntryWhereUniqueInput'
    distinct: List['JournalEntryScalarFieldKeys']
    include: 'JournalEntryIncludeFromJournalEntry'


class JournalEntryLineIncludeFromAuditLog(TypedDict, total=False):
    """Relational arguments for AuditLog"""
    entry: Union[bool, 'JournalEntryArgsFromAuditLog']
    account: Union[bool, 'AccountArgsFromAuditLog']


class JournalEntryLineArgsFromAuditLog(TypedDict, total=False):
    """Arguments for AuditLog"""
    include: 'JournalEntryLineIncludeFromJournalEntryLine'


class FindManyJournalEntryLineArgsFromAuditLog(TypedDict, total=False):
    """Arguments for AuditLog"""
    take: int
    skip: int
    order_by: Union['JournalEntryLineOrderByInput', List['JournalEntryLineOrderByInput']]
    where: 'JournalEntryLineWhereInput'
    cursor: 'JournalEntryLineWhereUniqueInput'
    distinct: List['JournalEntryLineScalarFieldKeys']
    include: 'JournalEntryLineIncludeFromJournalEntryLine'


class AccountIncludeFromAuditLog(TypedDict, total=False):
    """Relational arguments for AuditLog"""
    branch: Union[bool, 'BranchArgsFromAuditLog']
    entries: Union[bool, 'FindManyJournalEntryLineArgsFromAuditLog']
    payments: Union[bool, 'FindManyPaymentArgsFromAuditLog']
    outgoingTransfers: Union[bool, 'FindManyAccountTransferArgsFromAuditLog']
    incomingTransfers: Union[bool, 'FindManyAccountTransferArgsFromAuditLog']


class AccountArgsFromAuditLog(TypedDict, total=False):
    """Arguments for AuditLog"""
    include: 'AccountIncludeFromAccount'


class FindManyAccountArgsFromAuditLog(TypedDict, total=False):
    """Arguments for AuditLog"""
    take: int
    skip: int
    order_by: Union['AccountOrderByInput', List['AccountOrderByInput']]
    where: 'AccountWhereInput'
    cursor: 'AccountWhereUniqueInput'
    distinct: List['AccountScalarFieldKeys']
    include: 'AccountIncludeFromAccount'


class AccountTransferIncludeFromAuditLog(TypedDict, total=False):
    """Relational arguments for AuditLog"""
    fromAccount: Union[bool, 'AccountArgsFromAuditLog']
    toAccount: Union[bool, 'AccountArgsFromAuditLog']


class AccountTransferArgsFromAuditLog(TypedDict, total=False):
    """Arguments for AuditLog"""
    include: 'AccountTransferIncludeFromAccountTransfer'


class FindManyAccountTransferArgsFromAuditLog(TypedDict, total=False):
    """Arguments for AuditLog"""
    take: int
    skip: int
    order_by: Union['AccountTransferOrderByInput', List['AccountTransferOrderByInput']]
    where: 'AccountTransferWhereInput'
    cursor: 'AccountTransferWhereUniqueInput'
    distinct: List['AccountTransferScalarFieldKeys']
    include: 'AccountTransferIncludeFromAccountTransfer'


class BranchOrderIncludeFromAuditLog(TypedDict, total=False):
    """Relational arguments for AuditLog"""
    branch: Union[bool, 'BranchArgsFromAuditLog']
    requestedBy: Union[bool, 'UserArgsFromAuditLog']
    approvedBy: Union[bool, 'UserArgsFromAuditLog']
    sentBy: Union[bool, 'UserArgsFromAuditLog']
    receivedBy: Union[bool, 'UserArgsFromAuditLog']
    items: Union[bool, 'FindManyBranchOrderItemArgsFromAuditLog']


class BranchOrderArgsFromAuditLog(TypedDict, total=False):
    """Arguments for AuditLog"""
    include: 'BranchOrderIncludeFromBranchOrder'


class FindManyBranchOrderArgsFromAuditLog(TypedDict, total=False):
    """Arguments for AuditLog"""
    take: int
    skip: int
    order_by: Union['BranchOrderOrderByInput', List['BranchOrderOrderByInput']]
    where: 'BranchOrderWhereInput'
    cursor: 'BranchOrderWhereUniqueInput'
    distinct: List['BranchOrderScalarFieldKeys']
    include: 'BranchOrderIncludeFromBranchOrder'


class BranchOrderItemIncludeFromAuditLog(TypedDict, total=False):
    """Relational arguments for AuditLog"""
    branchOrder: Union[bool, 'BranchOrderArgsFromAuditLog']
    stock: Union[bool, 'StockArgsFromAuditLog']


class BranchOrderItemArgsFromAuditLog(TypedDict, total=False):
    """Arguments for AuditLog"""
    include: 'BranchOrderItemIncludeFromBranchOrderItem'


class FindManyBranchOrderItemArgsFromAuditLog(TypedDict, total=False):
    """Arguments for AuditLog"""
    take: int
    skip: int
    order_by: Union['BranchOrderItemOrderByInput', List['BranchOrderItemOrderByInput']]
    where: 'BranchOrderItemWhereInput'
    cursor: 'BranchOrderItemWhereUniqueInput'
    distinct: List['BranchOrderItemScalarFieldKeys']
    include: 'BranchOrderItemIncludeFromBranchOrderItem'


class AuditLogIncludeFromAuditLog(TypedDict, total=False):
    """Relational arguments for AuditLog"""
    user: Union[bool, 'UserArgsFromAuditLog']


class AuditLogArgsFromAuditLog(TypedDict, total=False):
    """Arguments for AuditLog"""
    include: 'AuditLogIncludeFromAuditLog'


class FindManyAuditLogArgsFromAuditLog(TypedDict, total=False):
    """Arguments for AuditLog"""
    take: int
    skip: int
    order_by: Union['AuditLogOrderByInput', List['AuditLogOrderByInput']]
    where: 'AuditLogWhereInput'
    cursor: 'AuditLogWhereUniqueInput'
    distinct: List['AuditLogScalarFieldKeys']
    include: 'AuditLogIncludeFromAuditLog'


class SystemInfoIncludeFromAuditLog(TypedDict, total=False):
    """Relational arguments for AuditLog"""


class SystemInfoArgsFromAuditLog(TypedDict, total=False):
    """Arguments for AuditLog"""
    include: 'SystemInfoIncludeFromSystemInfo'


class FindManySystemInfoArgsFromAuditLog(TypedDict, total=False):
    """Arguments for AuditLog"""
    take: int
    skip: int
    order_by: Union['SystemInfoOrderByInput', List['SystemInfoOrderByInput']]
    where: 'SystemInfoWhereInput'
    cursor: 'SystemInfoWhereUniqueInput'
    distinct: List['SystemInfoScalarFieldKeys']
    include: 'SystemInfoIncludeFromSystemInfo'


class BackupIncludeFromAuditLog(TypedDict, total=False):
    """Relational arguments for AuditLog"""
    createdBy: Union[bool, 'UserArgsFromAuditLog']


class BackupArgsFromAuditLog(TypedDict, total=False):
    """Arguments for AuditLog"""
    include: 'BackupIncludeFromBackup'


class FindManyBackupArgsFromAuditLog(TypedDict, total=False):
    """Arguments for AuditLog"""
    take: int
    skip: int
    order_by: Union['BackupOrderByInput', List['BackupOrderByInput']]
    where: 'BackupWhereInput'
    cursor: 'BackupWhereUniqueInput'
    distinct: List['BackupScalarFieldKeys']
    include: 'BackupIncludeFromBackup'


class RevokedTokenIncludeFromAuditLog(TypedDict, total=False):
    """Relational arguments for AuditLog"""
    user: Union[bool, 'UserArgsFromAuditLog']


class RevokedTokenArgsFromAuditLog(TypedDict, total=False):
    """Arguments for AuditLog"""
    include: 'RevokedTokenIncludeFromRevokedToken'


class FindManyRevokedTokenArgsFromAuditLog(TypedDict, total=False):
    """Arguments for AuditLog"""
    take: int
    skip: int
    order_by: Union['RevokedTokenOrderByInput', List['RevokedTokenOrderByInput']]
    where: 'RevokedTokenWhereInput'
    cursor: 'RevokedTokenWhereUniqueInput'
    distinct: List['RevokedTokenScalarFieldKeys']
    include: 'RevokedTokenIncludeFromRevokedToken'


class SystemSettingIncludeFromAuditLog(TypedDict, total=False):
    """Relational arguments for AuditLog"""


class SystemSettingArgsFromAuditLog(TypedDict, total=False):
    """Arguments for AuditLog"""
    include: 'SystemSettingIncludeFromSystemSetting'


class FindManySystemSettingArgsFromAuditLog(TypedDict, total=False):
    """Arguments for AuditLog"""
    take: int
    skip: int
    order_by: Union['SystemSettingOrderByInput', List['SystemSettingOrderByInput']]
    where: 'SystemSettingWhereInput'
    cursor: 'SystemSettingWhereUniqueInput'
    distinct: List['SystemSettingScalarFieldKeys']
    include: 'SystemSettingIncludeFromSystemSetting'


class NotificationIncludeFromAuditLog(TypedDict, total=False):
    """Relational arguments for AuditLog"""
    user: Union[bool, 'UserArgsFromAuditLog']


class NotificationArgsFromAuditLog(TypedDict, total=False):
    """Arguments for AuditLog"""
    include: 'NotificationIncludeFromNotification'


class FindManyNotificationArgsFromAuditLog(TypedDict, total=False):
    """Arguments for AuditLog"""
    take: int
    skip: int
    order_by: Union['NotificationOrderByInput', List['NotificationOrderByInput']]
    where: 'NotificationWhereInput'
    cursor: 'NotificationWhereUniqueInput'
    distinct: List['NotificationScalarFieldKeys']
    include: 'NotificationIncludeFromNotification'


class StockAdjustmentIncludeFromAuditLog(TypedDict, total=False):
    """Relational arguments for AuditLog"""
    product: Union[bool, 'ProductArgsFromAuditLog']
    createdBy: Union[bool, 'UserArgsFromAuditLog']


class StockAdjustmentArgsFromAuditLog(TypedDict, total=False):
    """Arguments for AuditLog"""
    include: 'StockAdjustmentIncludeFromStockAdjustment'


class FindManyStockAdjustmentArgsFromAuditLog(TypedDict, total=False):
    """Arguments for AuditLog"""
    take: int
    skip: int
    order_by: Union['StockAdjustmentOrderByInput', List['StockAdjustmentOrderByInput']]
    where: 'StockAdjustmentWhereInput'
    cursor: 'StockAdjustmentWhereUniqueInput'
    distinct: List['StockAdjustmentScalarFieldKeys']
    include: 'StockAdjustmentIncludeFromStockAdjustment'




FindManyAuditLogArgs = FindManyAuditLogArgsFromAuditLog
FindFirstAuditLogArgs = FindManyAuditLogArgsFromAuditLog


class AuditLogWhereInput(TypedDict, total=False):
    """AuditLog arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    user: 'UserRelationFilter'
    userId: Union[None, _int, 'types.IntFilter']
    action: 'enums.AuditAction'
    entityType: Union[None, _str, 'types.StringFilter']
    entityId: Union[None, _str, 'types.StringFilter']
    oldValues: Union[None, 'fields.Json', 'types.JsonFilter']
    newValues: Union[None, 'fields.Json', 'types.JsonFilter']
    severity: 'enums.AuditSeverity'
    ipAddress: Union[None, _str, 'types.StringFilter']
    userAgent: Union[None, _str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['AuditLogWhereInput', List['AuditLogWhereInput']]
    # but this causes mypy to hang :/
    AND: List['AuditLogWhereInput']
    OR: List['AuditLogWhereInput']
    NOT: List['AuditLogWhereInput']



# aggregate AuditLog types


class AuditLogScalarWhereWithAggregatesInput(TypedDict, total=False):
    """AuditLog arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    userId: Union[_int, 'types.IntWithAggregatesFilter']
    action: 'enums.AuditAction'
    entityType: Union[_str, 'types.StringWithAggregatesFilter']
    entityId: Union[_str, 'types.StringWithAggregatesFilter']
    oldValues: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    newValues: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    severity: 'enums.AuditSeverity'
    ipAddress: Union[_str, 'types.StringWithAggregatesFilter']
    userAgent: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['AuditLogScalarWhereWithAggregatesInput']
    OR: List['AuditLogScalarWhereWithAggregatesInput']
    NOT: List['AuditLogScalarWhereWithAggregatesInput']



class AuditLogGroupByOutput(TypedDict, total=False):
    id: _int
    userId: _int
    action: 'enums.AuditAction'
    entityType: _str
    entityId: _str
    oldValues: 'fields.Json'
    newValues: 'fields.Json'
    severity: 'enums.AuditSeverity'
    ipAddress: _str
    userAgent: _str
    createdAt: datetime.datetime
    _sum: 'AuditLogSumAggregateOutput'
    _avg: 'AuditLogAvgAggregateOutput'
    _min: 'AuditLogMinAggregateOutput'
    _max: 'AuditLogMaxAggregateOutput'
    _count: 'AuditLogCountAggregateOutput'


class AuditLogAvgAggregateOutput(TypedDict, total=False):
    """AuditLog output for aggregating averages"""
    id: float
    userId: float


class AuditLogSumAggregateOutput(TypedDict, total=False):
    """AuditLog output for aggregating sums"""
    id: _int
    userId: _int


class AuditLogScalarAggregateOutput(TypedDict, total=False):
    """AuditLog output including scalar fields"""
    id: _int
    userId: _int
    action: 'enums.AuditAction'
    entityType: _str
    entityId: _str
    oldValues: 'fields.Json'
    newValues: 'fields.Json'
    severity: 'enums.AuditSeverity'
    ipAddress: _str
    userAgent: _str
    createdAt: datetime.datetime


AuditLogMinAggregateOutput = AuditLogScalarAggregateOutput
AuditLogMaxAggregateOutput = AuditLogScalarAggregateOutput


class AuditLogMaxAggregateInput(TypedDict, total=False):
    """AuditLog input for aggregating by max"""
    id: bool
    userId: bool
    action: bool
    entityType: bool
    entityId: bool
    oldValues: bool
    newValues: bool
    severity: bool
    ipAddress: bool
    userAgent: bool
    createdAt: bool


class AuditLogMinAggregateInput(TypedDict, total=False):
    """AuditLog input for aggregating by min"""
    id: bool
    userId: bool
    action: bool
    entityType: bool
    entityId: bool
    oldValues: bool
    newValues: bool
    severity: bool
    ipAddress: bool
    userAgent: bool
    createdAt: bool


class AuditLogNumberAggregateInput(TypedDict, total=False):
    """AuditLog input for aggregating numbers"""
    id: bool
    userId: bool


AuditLogAvgAggregateInput = AuditLogNumberAggregateInput
AuditLogSumAggregateInput = AuditLogNumberAggregateInput


AuditLogCountAggregateInput = TypedDict(
    'AuditLogCountAggregateInput',
    {
        'id': bool,
        'userId': bool,
        'action': bool,
        'entityType': bool,
        'entityId': bool,
        'oldValues': bool,
        'newValues': bool,
        'severity': bool,
        'ipAddress': bool,
        'userAgent': bool,
        'createdAt': bool,
        '_all': bool,
    },
    total=False,
)

AuditLogCountAggregateOutput = TypedDict(
    'AuditLogCountAggregateOutput',
    {
        'id': int,
        'userId': int,
        'action': int,
        'entityType': int,
        'entityId': int,
        'oldValues': int,
        'newValues': int,
        'severity': int,
        'ipAddress': int,
        'userAgent': int,
        'createdAt': int,
        '_all': int,
    },
    total=False,
)


AuditLogKeys = Literal[
    'id',
    'user',
    'userId',
    'action',
    'entityType',
    'entityId',
    'oldValues',
    'newValues',
    'severity',
    'ipAddress',
    'userAgent',
    'createdAt',
]
AuditLogScalarFieldKeys = Literal[
    'id',
    'userId',
    'action',
    'entityType',
    'entityId',
    'oldValues',
    'newValues',
    'severity',
    'ipAddress',
    'userAgent',
    'createdAt',
]
AuditLogScalarFieldKeysT = TypeVar('AuditLogScalarFieldKeysT', bound=AuditLogScalarFieldKeys)

AuditLogRelationalFieldKeys = Literal[
        'user',
    ]

# SystemInfo types

class SystemInfoOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the SystemInfo create method"""
    id: _int
    version: Optional[_str]
    companyName: Optional[_str]
    companyEmail: Optional[_str]
    companyPhone: Optional[_str]
    companyAddress: Optional[_str]
    timezone: Optional[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class SystemInfoCreateInput(SystemInfoOptionalCreateInput):
    """Required arguments to the SystemInfo create method"""
    systemName: _str
    environment: 'enums.Environment'
    baseCurrency: 'enums.Currency'


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class SystemInfoOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the SystemInfo create method, without relations"""
    id: _int
    version: Optional[_str]
    companyName: Optional[_str]
    companyEmail: Optional[_str]
    companyPhone: Optional[_str]
    companyAddress: Optional[_str]
    timezone: Optional[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class SystemInfoCreateWithoutRelationsInput(SystemInfoOptionalCreateWithoutRelationsInput):
    """Required arguments to the SystemInfo create method, without relations"""
    systemName: _str
    environment: 'enums.Environment'
    baseCurrency: 'enums.Currency'


class SystemInfoCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'SystemInfoCreateWithoutRelationsInput'
    connect: 'SystemInfoWhereUniqueInput'


class SystemInfoCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['SystemInfoCreateWithoutRelationsInput', List['SystemInfoCreateWithoutRelationsInput']]
    connect: Union['SystemInfoWhereUniqueInput', List['SystemInfoWhereUniqueInput']]


_SystemInfoWhereUnique_id_Input = TypedDict(
    '_SystemInfoWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

SystemInfoWhereUniqueInput = _SystemInfoWhereUnique_id_Input


class SystemInfoUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    systemName: _str
    version: Optional[_str]
    environment: 'enums.Environment'
    companyName: Optional[_str]
    companyEmail: Optional[_str]
    companyPhone: Optional[_str]
    companyAddress: Optional[_str]
    baseCurrency: 'enums.Currency'
    timezone: Optional[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class SystemInfoUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    systemName: _str
    version: Optional[_str]
    environment: 'enums.Environment'
    companyName: Optional[_str]
    companyEmail: Optional[_str]
    companyPhone: Optional[_str]
    companyAddress: Optional[_str]
    baseCurrency: 'enums.Currency'
    timezone: Optional[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class SystemInfoUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['SystemInfoCreateWithoutRelationsInput']
    connect: List['SystemInfoWhereUniqueInput']
    set: List['SystemInfoWhereUniqueInput']
    disconnect: List['SystemInfoWhereUniqueInput']
    delete: List['SystemInfoWhereUniqueInput']

    # TODO
    # update: List['SystemInfoUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['SystemInfoUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['SystemInfoScalarWhereInput']
    # upsert: List['SystemInfoUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['SystemInfoCreateOrConnectWithoutRelationsInput']


class SystemInfoUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'SystemInfoCreateWithoutRelationsInput'
    connect: 'SystemInfoWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'SystemInfoUpdateInput'
    # upsert: 'SystemInfoUpsertWithoutRelationsInput'
    # connectOrCreate: 'SystemInfoCreateOrConnectWithoutRelationsInput'


class SystemInfoUpsertInput(TypedDict):
    create: 'SystemInfoCreateInput'
    update: 'SystemInfoUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_SystemInfo_id_OrderByInput = TypedDict(
    '_SystemInfo_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_SystemInfo_systemName_OrderByInput = TypedDict(
    '_SystemInfo_systemName_OrderByInput',
    {
        'systemName': 'SortOrder',
    },
    total=True
)

_SystemInfo_version_OrderByInput = TypedDict(
    '_SystemInfo_version_OrderByInput',
    {
        'version': 'SortOrder',
    },
    total=True
)

_SystemInfo_environment_OrderByInput = TypedDict(
    '_SystemInfo_environment_OrderByInput',
    {
        'environment': 'SortOrder',
    },
    total=True
)

_SystemInfo_companyName_OrderByInput = TypedDict(
    '_SystemInfo_companyName_OrderByInput',
    {
        'companyName': 'SortOrder',
    },
    total=True
)

_SystemInfo_companyEmail_OrderByInput = TypedDict(
    '_SystemInfo_companyEmail_OrderByInput',
    {
        'companyEmail': 'SortOrder',
    },
    total=True
)

_SystemInfo_companyPhone_OrderByInput = TypedDict(
    '_SystemInfo_companyPhone_OrderByInput',
    {
        'companyPhone': 'SortOrder',
    },
    total=True
)

_SystemInfo_companyAddress_OrderByInput = TypedDict(
    '_SystemInfo_companyAddress_OrderByInput',
    {
        'companyAddress': 'SortOrder',
    },
    total=True
)

_SystemInfo_baseCurrency_OrderByInput = TypedDict(
    '_SystemInfo_baseCurrency_OrderByInput',
    {
        'baseCurrency': 'SortOrder',
    },
    total=True
)

_SystemInfo_timezone_OrderByInput = TypedDict(
    '_SystemInfo_timezone_OrderByInput',
    {
        'timezone': 'SortOrder',
    },
    total=True
)

_SystemInfo_createdAt_OrderByInput = TypedDict(
    '_SystemInfo_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_SystemInfo_updatedAt_OrderByInput = TypedDict(
    '_SystemInfo_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

SystemInfoOrderByInput = Union[
    '_SystemInfo_id_OrderByInput',
    '_SystemInfo_systemName_OrderByInput',
    '_SystemInfo_version_OrderByInput',
    '_SystemInfo_environment_OrderByInput',
    '_SystemInfo_companyName_OrderByInput',
    '_SystemInfo_companyEmail_OrderByInput',
    '_SystemInfo_companyPhone_OrderByInput',
    '_SystemInfo_companyAddress_OrderByInput',
    '_SystemInfo_baseCurrency_OrderByInput',
    '_SystemInfo_timezone_OrderByInput',
    '_SystemInfo_createdAt_OrderByInput',
    '_SystemInfo_updatedAt_OrderByInput',
]



# recursive SystemInfo types
# TODO: cleanup these types



SystemInfoRelationFilter = TypedDict(
    'SystemInfoRelationFilter',
    {
        'is': 'SystemInfoWhereInput',
        'is_not': 'SystemInfoWhereInput',
    },
    total=False,
)


class SystemInfoListRelationFilter(TypedDict, total=False):
    some: 'SystemInfoWhereInput'
    none: 'SystemInfoWhereInput'
    every: 'SystemInfoWhereInput'


class SystemInfoInclude(TypedDict, total=False):
    """SystemInfo relational arguments"""


class UserIncludeFromSystemInfo(TypedDict, total=False):
    """Relational arguments for SystemInfo"""
    branch: Union[bool, 'BranchArgsFromSystemInfo']
    auditLogs: Union[bool, 'FindManyAuditLogArgsFromSystemInfo']
    permissions: Union[bool, 'FindManyUserPermissionArgsFromSystemInfo']
    notifications: Union[bool, 'FindManyNotificationArgsFromSystemInfo']
    revokedTokens: Union[bool, 'FindManyRevokedTokenArgsFromSystemInfo']
    stockAdjustments: Union[bool, 'FindManyStockAdjustmentArgsFromSystemInfo']
    Sale: Union[bool, 'FindManySaleArgsFromSystemInfo']
    deletedSales: Union[bool, 'FindManySaleArgsFromSystemInfo']
    Payment: Union[bool, 'FindManyPaymentArgsFromSystemInfo']
    Backup: Union[bool, 'FindManyBackupArgsFromSystemInfo']
    requestedOrders: Union[bool, 'FindManyBranchOrderArgsFromSystemInfo']
    approvedOrders: Union[bool, 'FindManyBranchOrderArgsFromSystemInfo']
    sentOrders: Union[bool, 'FindManyBranchOrderArgsFromSystemInfo']
    receivedOrders: Union[bool, 'FindManyBranchOrderArgsFromSystemInfo']


class UserArgsFromSystemInfo(TypedDict, total=False):
    """Arguments for SystemInfo"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromSystemInfo(TypedDict, total=False):
    """Arguments for SystemInfo"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class UserPermissionIncludeFromSystemInfo(TypedDict, total=False):
    """Relational arguments for SystemInfo"""
    user: Union[bool, 'UserArgsFromSystemInfo']


class UserPermissionArgsFromSystemInfo(TypedDict, total=False):
    """Arguments for SystemInfo"""
    include: 'UserPermissionIncludeFromUserPermission'


class FindManyUserPermissionArgsFromSystemInfo(TypedDict, total=False):
    """Arguments for SystemInfo"""
    take: int
    skip: int
    order_by: Union['UserPermissionOrderByInput', List['UserPermissionOrderByInput']]
    where: 'UserPermissionWhereInput'
    cursor: 'UserPermissionWhereUniqueInput'
    distinct: List['UserPermissionScalarFieldKeys']
    include: 'UserPermissionIncludeFromUserPermission'


class BranchIncludeFromSystemInfo(TypedDict, total=False):
    """Relational arguments for SystemInfo"""
    users: Union[bool, 'FindManyUserArgsFromSystemInfo']
    Sale: Union[bool, 'FindManySaleArgsFromSystemInfo']
    Account: Union[bool, 'FindManyAccountArgsFromSystemInfo']
    BranchOrder: Union[bool, 'FindManyBranchOrderArgsFromSystemInfo']


class BranchArgsFromSystemInfo(TypedDict, total=False):
    """Arguments for SystemInfo"""
    include: 'BranchIncludeFromBranch'


class FindManyBranchArgsFromSystemInfo(TypedDict, total=False):
    """Arguments for SystemInfo"""
    take: int
    skip: int
    order_by: Union['BranchOrderByInput', List['BranchOrderByInput']]
    where: 'BranchWhereInput'
    cursor: 'BranchWhereUniqueInput'
    distinct: List['BranchScalarFieldKeys']
    include: 'BranchIncludeFromBranch'


class ProductIncludeFromSystemInfo(TypedDict, total=False):
    """Relational arguments for SystemInfo"""
    category: Union[bool, 'CategoryArgsFromSystemInfo']
    stocks: Union[bool, 'FindManyStockArgsFromSystemInfo']
    stockAdjustments: Union[bool, 'FindManyStockAdjustmentArgsFromSystemInfo']


class ProductArgsFromSystemInfo(TypedDict, total=False):
    """Arguments for SystemInfo"""
    include: 'ProductIncludeFromProduct'


class FindManyProductArgsFromSystemInfo(TypedDict, total=False):
    """Arguments for SystemInfo"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProduct'


class CategoryIncludeFromSystemInfo(TypedDict, total=False):
    """Relational arguments for SystemInfo"""
    products: Union[bool, 'FindManyProductArgsFromSystemInfo']


class CategoryArgsFromSystemInfo(TypedDict, total=False):
    """Arguments for SystemInfo"""
    include: 'CategoryIncludeFromCategory'


class FindManyCategoryArgsFromSystemInfo(TypedDict, total=False):
    """Arguments for SystemInfo"""
    take: int
    skip: int
    order_by: Union['CategoryOrderByInput', List['CategoryOrderByInput']]
    where: 'CategoryWhereInput'
    cursor: 'CategoryWhereUniqueInput'
    distinct: List['CategoryScalarFieldKeys']
    include: 'CategoryIncludeFromCategory'


class StockIncludeFromSystemInfo(TypedDict, total=False):
    """Relational arguments for SystemInfo"""
    product: Union[bool, 'ProductArgsFromSystemInfo']
    SaleItem: Union[bool, 'FindManySaleItemArgsFromSystemInfo']
    BranchOrderItem: Union[bool, 'FindManyBranchOrderItemArgsFromSystemInfo']


class StockArgsFromSystemInfo(TypedDict, total=False):
    """Arguments for SystemInfo"""
    include: 'StockIncludeFromStock'


class FindManyStockArgsFromSystemInfo(TypedDict, total=False):
    """Arguments for SystemInfo"""
    take: int
    skip: int
    order_by: Union['StockOrderByInput', List['StockOrderByInput']]
    where: 'StockWhereInput'
    cursor: 'StockWhereUniqueInput'
    distinct: List['StockScalarFieldKeys']
    include: 'StockIncludeFromStock'


class CustomerIncludeFromSystemInfo(TypedDict, total=False):
    """Relational arguments for SystemInfo"""
    Sale: Union[bool, 'FindManySaleArgsFromSystemInfo']


class CustomerArgsFromSystemInfo(TypedDict, total=False):
    """Arguments for SystemInfo"""
    include: 'CustomerIncludeFromCustomer'


class FindManyCustomerArgsFromSystemInfo(TypedDict, total=False):
    """Arguments for SystemInfo"""
    take: int
    skip: int
    order_by: Union['CustomerOrderByInput', List['CustomerOrderByInput']]
    where: 'CustomerWhereInput'
    cursor: 'CustomerWhereUniqueInput'
    distinct: List['CustomerScalarFieldKeys']
    include: 'CustomerIncludeFromCustomer'


class SaleIncludeFromSystemInfo(TypedDict, total=False):
    """Relational arguments for SystemInfo"""
    branch: Union[bool, 'BranchArgsFromSystemInfo']
    customer: Union[bool, 'CustomerArgsFromSystemInfo']
    user: Union[bool, 'UserArgsFromSystemInfo']
    items: Union[bool, 'FindManySaleItemArgsFromSystemInfo']
    payments: Union[bool, 'FindManyPaymentArgsFromSystemInfo']
    returns: Union[bool, 'FindManyReturnSaleArgsFromSystemInfo']
    deletedBy: Union[bool, 'UserArgsFromSystemInfo']


class SaleArgsFromSystemInfo(TypedDict, total=False):
    """Arguments for SystemInfo"""
    include: 'SaleIncludeFromSale'


class FindManySaleArgsFromSystemInfo(TypedDict, total=False):
    """Arguments for SystemInfo"""
    take: int
    skip: int
    order_by: Union['SaleOrderByInput', List['SaleOrderByInput']]
    where: 'SaleWhereInput'
    cursor: 'SaleWhereUniqueInput'
    distinct: List['SaleScalarFieldKeys']
    include: 'SaleIncludeFromSale'


class SaleItemIncludeFromSystemInfo(TypedDict, total=False):
    """Relational arguments for SystemInfo"""
    sale: Union[bool, 'SaleArgsFromSystemInfo']
    stock: Union[bool, 'StockArgsFromSystemInfo']
    ReturnItem: Union[bool, 'FindManyReturnItemArgsFromSystemInfo']


class SaleItemArgsFromSystemInfo(TypedDict, total=False):
    """Arguments for SystemInfo"""
    include: 'SaleItemIncludeFromSaleItem'


class FindManySaleItemArgsFromSystemInfo(TypedDict, total=False):
    """Arguments for SystemInfo"""
    take: int
    skip: int
    order_by: Union['SaleItemOrderByInput', List['SaleItemOrderByInput']]
    where: 'SaleItemWhereInput'
    cursor: 'SaleItemWhereUniqueInput'
    distinct: List['SaleItemScalarFieldKeys']
    include: 'SaleItemIncludeFromSaleItem'


class ReturnSaleIncludeFromSystemInfo(TypedDict, total=False):
    """Relational arguments for SystemInfo"""
    original: Union[bool, 'SaleArgsFromSystemInfo']
    items: Union[bool, 'FindManyReturnItemArgsFromSystemInfo']
    refund: Union[bool, 'FindManyPaymentArgsFromSystemInfo']


class ReturnSaleArgsFromSystemInfo(TypedDict, total=False):
    """Arguments for SystemInfo"""
    include: 'ReturnSaleIncludeFromReturnSale'


class FindManyReturnSaleArgsFromSystemInfo(TypedDict, total=False):
    """Arguments for SystemInfo"""
    take: int
    skip: int
    order_by: Union['ReturnSaleOrderByInput', List['ReturnSaleOrderByInput']]
    where: 'ReturnSaleWhereInput'
    cursor: 'ReturnSaleWhereUniqueInput'
    distinct: List['ReturnSaleScalarFieldKeys']
    include: 'ReturnSaleIncludeFromReturnSale'


class ReturnItemIncludeFromSystemInfo(TypedDict, total=False):
    """Relational arguments for SystemInfo"""
    returnSale: Union[bool, 'ReturnSaleArgsFromSystemInfo']
    saleItem: Union[bool, 'SaleItemArgsFromSystemInfo']


class ReturnItemArgsFromSystemInfo(TypedDict, total=False):
    """Arguments for SystemInfo"""
    include: 'ReturnItemIncludeFromReturnItem'


class FindManyReturnItemArgsFromSystemInfo(TypedDict, total=False):
    """Arguments for SystemInfo"""
    take: int
    skip: int
    order_by: Union['ReturnItemOrderByInput', List['ReturnItemOrderByInput']]
    where: 'ReturnItemWhereInput'
    cursor: 'ReturnItemWhereUniqueInput'
    distinct: List['ReturnItemScalarFieldKeys']
    include: 'ReturnItemIncludeFromReturnItem'


class PaymentIncludeFromSystemInfo(TypedDict, total=False):
    """Relational arguments for SystemInfo"""
    sale: Union[bool, 'SaleArgsFromSystemInfo']
    account: Union[bool, 'AccountArgsFromSystemInfo']
    returnSale: Union[bool, 'ReturnSaleArgsFromSystemInfo']
    user: Union[bool, 'UserArgsFromSystemInfo']


class PaymentArgsFromSystemInfo(TypedDict, total=False):
    """Arguments for SystemInfo"""
    include: 'PaymentIncludeFromPayment'


class FindManyPaymentArgsFromSystemInfo(TypedDict, total=False):
    """Arguments for SystemInfo"""
    take: int
    skip: int
    order_by: Union['PaymentOrderByInput', List['PaymentOrderByInput']]
    where: 'PaymentWhereInput'
    cursor: 'PaymentWhereUniqueInput'
    distinct: List['PaymentScalarFieldKeys']
    include: 'PaymentIncludeFromPayment'


class JournalEntryIncludeFromSystemInfo(TypedDict, total=False):
    """Relational arguments for SystemInfo"""
    lines: Union[bool, 'FindManyJournalEntryLineArgsFromSystemInfo']


class JournalEntryArgsFromSystemInfo(TypedDict, total=False):
    """Arguments for SystemInfo"""
    include: 'JournalEntryIncludeFromJournalEntry'


class FindManyJournalEntryArgsFromSystemInfo(TypedDict, total=False):
    """Arguments for SystemInfo"""
    take: int
    skip: int
    order_by: Union['JournalEntryOrderByInput', List['JournalEntryOrderByInput']]
    where: 'JournalEntryWhereInput'
    cursor: 'JournalEntryWhereUniqueInput'
    distinct: List['JournalEntryScalarFieldKeys']
    include: 'JournalEntryIncludeFromJournalEntry'


class JournalEntryLineIncludeFromSystemInfo(TypedDict, total=False):
    """Relational arguments for SystemInfo"""
    entry: Union[bool, 'JournalEntryArgsFromSystemInfo']
    account: Union[bool, 'AccountArgsFromSystemInfo']


class JournalEntryLineArgsFromSystemInfo(TypedDict, total=False):
    """Arguments for SystemInfo"""
    include: 'JournalEntryLineIncludeFromJournalEntryLine'


class FindManyJournalEntryLineArgsFromSystemInfo(TypedDict, total=False):
    """Arguments for SystemInfo"""
    take: int
    skip: int
    order_by: Union['JournalEntryLineOrderByInput', List['JournalEntryLineOrderByInput']]
    where: 'JournalEntryLineWhereInput'
    cursor: 'JournalEntryLineWhereUniqueInput'
    distinct: List['JournalEntryLineScalarFieldKeys']
    include: 'JournalEntryLineIncludeFromJournalEntryLine'


class AccountIncludeFromSystemInfo(TypedDict, total=False):
    """Relational arguments for SystemInfo"""
    branch: Union[bool, 'BranchArgsFromSystemInfo']
    entries: Union[bool, 'FindManyJournalEntryLineArgsFromSystemInfo']
    payments: Union[bool, 'FindManyPaymentArgsFromSystemInfo']
    outgoingTransfers: Union[bool, 'FindManyAccountTransferArgsFromSystemInfo']
    incomingTransfers: Union[bool, 'FindManyAccountTransferArgsFromSystemInfo']


class AccountArgsFromSystemInfo(TypedDict, total=False):
    """Arguments for SystemInfo"""
    include: 'AccountIncludeFromAccount'


class FindManyAccountArgsFromSystemInfo(TypedDict, total=False):
    """Arguments for SystemInfo"""
    take: int
    skip: int
    order_by: Union['AccountOrderByInput', List['AccountOrderByInput']]
    where: 'AccountWhereInput'
    cursor: 'AccountWhereUniqueInput'
    distinct: List['AccountScalarFieldKeys']
    include: 'AccountIncludeFromAccount'


class AccountTransferIncludeFromSystemInfo(TypedDict, total=False):
    """Relational arguments for SystemInfo"""
    fromAccount: Union[bool, 'AccountArgsFromSystemInfo']
    toAccount: Union[bool, 'AccountArgsFromSystemInfo']


class AccountTransferArgsFromSystemInfo(TypedDict, total=False):
    """Arguments for SystemInfo"""
    include: 'AccountTransferIncludeFromAccountTransfer'


class FindManyAccountTransferArgsFromSystemInfo(TypedDict, total=False):
    """Arguments for SystemInfo"""
    take: int
    skip: int
    order_by: Union['AccountTransferOrderByInput', List['AccountTransferOrderByInput']]
    where: 'AccountTransferWhereInput'
    cursor: 'AccountTransferWhereUniqueInput'
    distinct: List['AccountTransferScalarFieldKeys']
    include: 'AccountTransferIncludeFromAccountTransfer'


class BranchOrderIncludeFromSystemInfo(TypedDict, total=False):
    """Relational arguments for SystemInfo"""
    branch: Union[bool, 'BranchArgsFromSystemInfo']
    requestedBy: Union[bool, 'UserArgsFromSystemInfo']
    approvedBy: Union[bool, 'UserArgsFromSystemInfo']
    sentBy: Union[bool, 'UserArgsFromSystemInfo']
    receivedBy: Union[bool, 'UserArgsFromSystemInfo']
    items: Union[bool, 'FindManyBranchOrderItemArgsFromSystemInfo']


class BranchOrderArgsFromSystemInfo(TypedDict, total=False):
    """Arguments for SystemInfo"""
    include: 'BranchOrderIncludeFromBranchOrder'


class FindManyBranchOrderArgsFromSystemInfo(TypedDict, total=False):
    """Arguments for SystemInfo"""
    take: int
    skip: int
    order_by: Union['BranchOrderOrderByInput', List['BranchOrderOrderByInput']]
    where: 'BranchOrderWhereInput'
    cursor: 'BranchOrderWhereUniqueInput'
    distinct: List['BranchOrderScalarFieldKeys']
    include: 'BranchOrderIncludeFromBranchOrder'


class BranchOrderItemIncludeFromSystemInfo(TypedDict, total=False):
    """Relational arguments for SystemInfo"""
    branchOrder: Union[bool, 'BranchOrderArgsFromSystemInfo']
    stock: Union[bool, 'StockArgsFromSystemInfo']


class BranchOrderItemArgsFromSystemInfo(TypedDict, total=False):
    """Arguments for SystemInfo"""
    include: 'BranchOrderItemIncludeFromBranchOrderItem'


class FindManyBranchOrderItemArgsFromSystemInfo(TypedDict, total=False):
    """Arguments for SystemInfo"""
    take: int
    skip: int
    order_by: Union['BranchOrderItemOrderByInput', List['BranchOrderItemOrderByInput']]
    where: 'BranchOrderItemWhereInput'
    cursor: 'BranchOrderItemWhereUniqueInput'
    distinct: List['BranchOrderItemScalarFieldKeys']
    include: 'BranchOrderItemIncludeFromBranchOrderItem'


class AuditLogIncludeFromSystemInfo(TypedDict, total=False):
    """Relational arguments for SystemInfo"""
    user: Union[bool, 'UserArgsFromSystemInfo']


class AuditLogArgsFromSystemInfo(TypedDict, total=False):
    """Arguments for SystemInfo"""
    include: 'AuditLogIncludeFromAuditLog'


class FindManyAuditLogArgsFromSystemInfo(TypedDict, total=False):
    """Arguments for SystemInfo"""
    take: int
    skip: int
    order_by: Union['AuditLogOrderByInput', List['AuditLogOrderByInput']]
    where: 'AuditLogWhereInput'
    cursor: 'AuditLogWhereUniqueInput'
    distinct: List['AuditLogScalarFieldKeys']
    include: 'AuditLogIncludeFromAuditLog'


class SystemInfoIncludeFromSystemInfo(TypedDict, total=False):
    """Relational arguments for SystemInfo"""


class SystemInfoArgsFromSystemInfo(TypedDict, total=False):
    """Arguments for SystemInfo"""
    include: 'SystemInfoIncludeFromSystemInfo'


class FindManySystemInfoArgsFromSystemInfo(TypedDict, total=False):
    """Arguments for SystemInfo"""
    take: int
    skip: int
    order_by: Union['SystemInfoOrderByInput', List['SystemInfoOrderByInput']]
    where: 'SystemInfoWhereInput'
    cursor: 'SystemInfoWhereUniqueInput'
    distinct: List['SystemInfoScalarFieldKeys']
    include: 'SystemInfoIncludeFromSystemInfo'


class BackupIncludeFromSystemInfo(TypedDict, total=False):
    """Relational arguments for SystemInfo"""
    createdBy: Union[bool, 'UserArgsFromSystemInfo']


class BackupArgsFromSystemInfo(TypedDict, total=False):
    """Arguments for SystemInfo"""
    include: 'BackupIncludeFromBackup'


class FindManyBackupArgsFromSystemInfo(TypedDict, total=False):
    """Arguments for SystemInfo"""
    take: int
    skip: int
    order_by: Union['BackupOrderByInput', List['BackupOrderByInput']]
    where: 'BackupWhereInput'
    cursor: 'BackupWhereUniqueInput'
    distinct: List['BackupScalarFieldKeys']
    include: 'BackupIncludeFromBackup'


class RevokedTokenIncludeFromSystemInfo(TypedDict, total=False):
    """Relational arguments for SystemInfo"""
    user: Union[bool, 'UserArgsFromSystemInfo']


class RevokedTokenArgsFromSystemInfo(TypedDict, total=False):
    """Arguments for SystemInfo"""
    include: 'RevokedTokenIncludeFromRevokedToken'


class FindManyRevokedTokenArgsFromSystemInfo(TypedDict, total=False):
    """Arguments for SystemInfo"""
    take: int
    skip: int
    order_by: Union['RevokedTokenOrderByInput', List['RevokedTokenOrderByInput']]
    where: 'RevokedTokenWhereInput'
    cursor: 'RevokedTokenWhereUniqueInput'
    distinct: List['RevokedTokenScalarFieldKeys']
    include: 'RevokedTokenIncludeFromRevokedToken'


class SystemSettingIncludeFromSystemInfo(TypedDict, total=False):
    """Relational arguments for SystemInfo"""


class SystemSettingArgsFromSystemInfo(TypedDict, total=False):
    """Arguments for SystemInfo"""
    include: 'SystemSettingIncludeFromSystemSetting'


class FindManySystemSettingArgsFromSystemInfo(TypedDict, total=False):
    """Arguments for SystemInfo"""
    take: int
    skip: int
    order_by: Union['SystemSettingOrderByInput', List['SystemSettingOrderByInput']]
    where: 'SystemSettingWhereInput'
    cursor: 'SystemSettingWhereUniqueInput'
    distinct: List['SystemSettingScalarFieldKeys']
    include: 'SystemSettingIncludeFromSystemSetting'


class NotificationIncludeFromSystemInfo(TypedDict, total=False):
    """Relational arguments for SystemInfo"""
    user: Union[bool, 'UserArgsFromSystemInfo']


class NotificationArgsFromSystemInfo(TypedDict, total=False):
    """Arguments for SystemInfo"""
    include: 'NotificationIncludeFromNotification'


class FindManyNotificationArgsFromSystemInfo(TypedDict, total=False):
    """Arguments for SystemInfo"""
    take: int
    skip: int
    order_by: Union['NotificationOrderByInput', List['NotificationOrderByInput']]
    where: 'NotificationWhereInput'
    cursor: 'NotificationWhereUniqueInput'
    distinct: List['NotificationScalarFieldKeys']
    include: 'NotificationIncludeFromNotification'


class StockAdjustmentIncludeFromSystemInfo(TypedDict, total=False):
    """Relational arguments for SystemInfo"""
    product: Union[bool, 'ProductArgsFromSystemInfo']
    createdBy: Union[bool, 'UserArgsFromSystemInfo']


class StockAdjustmentArgsFromSystemInfo(TypedDict, total=False):
    """Arguments for SystemInfo"""
    include: 'StockAdjustmentIncludeFromStockAdjustment'


class FindManyStockAdjustmentArgsFromSystemInfo(TypedDict, total=False):
    """Arguments for SystemInfo"""
    take: int
    skip: int
    order_by: Union['StockAdjustmentOrderByInput', List['StockAdjustmentOrderByInput']]
    where: 'StockAdjustmentWhereInput'
    cursor: 'StockAdjustmentWhereUniqueInput'
    distinct: List['StockAdjustmentScalarFieldKeys']
    include: 'StockAdjustmentIncludeFromStockAdjustment'




FindManySystemInfoArgs = FindManySystemInfoArgsFromSystemInfo
FindFirstSystemInfoArgs = FindManySystemInfoArgsFromSystemInfo


class SystemInfoWhereInput(TypedDict, total=False):
    """SystemInfo arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    systemName: Union[_str, 'types.StringFilter']
    version: Union[None, _str, 'types.StringFilter']
    environment: 'enums.Environment'
    companyName: Union[None, _str, 'types.StringFilter']
    companyEmail: Union[None, _str, 'types.StringFilter']
    companyPhone: Union[None, _str, 'types.StringFilter']
    companyAddress: Union[None, _str, 'types.StringFilter']
    baseCurrency: 'enums.Currency'
    timezone: Union[None, _str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['SystemInfoWhereInput', List['SystemInfoWhereInput']]
    # but this causes mypy to hang :/
    AND: List['SystemInfoWhereInput']
    OR: List['SystemInfoWhereInput']
    NOT: List['SystemInfoWhereInput']



# aggregate SystemInfo types


class SystemInfoScalarWhereWithAggregatesInput(TypedDict, total=False):
    """SystemInfo arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    systemName: Union[_str, 'types.StringWithAggregatesFilter']
    version: Union[_str, 'types.StringWithAggregatesFilter']
    environment: 'enums.Environment'
    companyName: Union[_str, 'types.StringWithAggregatesFilter']
    companyEmail: Union[_str, 'types.StringWithAggregatesFilter']
    companyPhone: Union[_str, 'types.StringWithAggregatesFilter']
    companyAddress: Union[_str, 'types.StringWithAggregatesFilter']
    baseCurrency: 'enums.Currency'
    timezone: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['SystemInfoScalarWhereWithAggregatesInput']
    OR: List['SystemInfoScalarWhereWithAggregatesInput']
    NOT: List['SystemInfoScalarWhereWithAggregatesInput']



class SystemInfoGroupByOutput(TypedDict, total=False):
    id: _int
    systemName: _str
    version: _str
    environment: 'enums.Environment'
    companyName: _str
    companyEmail: _str
    companyPhone: _str
    companyAddress: _str
    baseCurrency: 'enums.Currency'
    timezone: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'SystemInfoSumAggregateOutput'
    _avg: 'SystemInfoAvgAggregateOutput'
    _min: 'SystemInfoMinAggregateOutput'
    _max: 'SystemInfoMaxAggregateOutput'
    _count: 'SystemInfoCountAggregateOutput'


class SystemInfoAvgAggregateOutput(TypedDict, total=False):
    """SystemInfo output for aggregating averages"""
    id: float


class SystemInfoSumAggregateOutput(TypedDict, total=False):
    """SystemInfo output for aggregating sums"""
    id: _int


class SystemInfoScalarAggregateOutput(TypedDict, total=False):
    """SystemInfo output including scalar fields"""
    id: _int
    systemName: _str
    version: _str
    environment: 'enums.Environment'
    companyName: _str
    companyEmail: _str
    companyPhone: _str
    companyAddress: _str
    baseCurrency: 'enums.Currency'
    timezone: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


SystemInfoMinAggregateOutput = SystemInfoScalarAggregateOutput
SystemInfoMaxAggregateOutput = SystemInfoScalarAggregateOutput


class SystemInfoMaxAggregateInput(TypedDict, total=False):
    """SystemInfo input for aggregating by max"""
    id: bool
    systemName: bool
    version: bool
    environment: bool
    companyName: bool
    companyEmail: bool
    companyPhone: bool
    companyAddress: bool
    baseCurrency: bool
    timezone: bool
    createdAt: bool
    updatedAt: bool


class SystemInfoMinAggregateInput(TypedDict, total=False):
    """SystemInfo input for aggregating by min"""
    id: bool
    systemName: bool
    version: bool
    environment: bool
    companyName: bool
    companyEmail: bool
    companyPhone: bool
    companyAddress: bool
    baseCurrency: bool
    timezone: bool
    createdAt: bool
    updatedAt: bool


class SystemInfoNumberAggregateInput(TypedDict, total=False):
    """SystemInfo input for aggregating numbers"""
    id: bool


SystemInfoAvgAggregateInput = SystemInfoNumberAggregateInput
SystemInfoSumAggregateInput = SystemInfoNumberAggregateInput


SystemInfoCountAggregateInput = TypedDict(
    'SystemInfoCountAggregateInput',
    {
        'id': bool,
        'systemName': bool,
        'version': bool,
        'environment': bool,
        'companyName': bool,
        'companyEmail': bool,
        'companyPhone': bool,
        'companyAddress': bool,
        'baseCurrency': bool,
        'timezone': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

SystemInfoCountAggregateOutput = TypedDict(
    'SystemInfoCountAggregateOutput',
    {
        'id': int,
        'systemName': int,
        'version': int,
        'environment': int,
        'companyName': int,
        'companyEmail': int,
        'companyPhone': int,
        'companyAddress': int,
        'baseCurrency': int,
        'timezone': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


SystemInfoKeys = Literal[
    'id',
    'systemName',
    'version',
    'environment',
    'companyName',
    'companyEmail',
    'companyPhone',
    'companyAddress',
    'baseCurrency',
    'timezone',
    'createdAt',
    'updatedAt',
]
SystemInfoScalarFieldKeys = Literal[
    'id',
    'systemName',
    'version',
    'environment',
    'companyName',
    'companyEmail',
    'companyPhone',
    'companyAddress',
    'baseCurrency',
    'timezone',
    'createdAt',
    'updatedAt',
]
SystemInfoScalarFieldKeysT = TypeVar('SystemInfoScalarFieldKeysT', bound=SystemInfoScalarFieldKeys)

SystemInfoRelationalFieldKeys = _NoneType

# Backup types

class BackupOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Backup create method"""
    id: _int
    fileName: Optional[_str]
    sizeMB: Optional[_float]
    errorLog: Optional[_str]
    createdBy: 'UserCreateNestedWithoutRelationsInput'
    createdById: Optional[_int]
    createdAt: datetime.datetime
    completedAt: Optional[datetime.datetime]


class BackupCreateInput(BackupOptionalCreateInput):
    """Required arguments to the Backup create method"""
    type: 'enums.BackupType'
    location: _str
    status: 'enums.BackupStatus'


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class BackupOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Backup create method, without relations"""
    id: _int
    fileName: Optional[_str]
    sizeMB: Optional[_float]
    errorLog: Optional[_str]
    createdById: Optional[_int]
    createdAt: datetime.datetime
    completedAt: Optional[datetime.datetime]


class BackupCreateWithoutRelationsInput(BackupOptionalCreateWithoutRelationsInput):
    """Required arguments to the Backup create method, without relations"""
    type: 'enums.BackupType'
    location: _str
    status: 'enums.BackupStatus'


class BackupCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'BackupCreateWithoutRelationsInput'
    connect: 'BackupWhereUniqueInput'


class BackupCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['BackupCreateWithoutRelationsInput', List['BackupCreateWithoutRelationsInput']]
    connect: Union['BackupWhereUniqueInput', List['BackupWhereUniqueInput']]


_BackupWhereUnique_id_Input = TypedDict(
    '_BackupWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

BackupWhereUniqueInput = _BackupWhereUnique_id_Input


class BackupUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    type: 'enums.BackupType'
    location: _str
    fileName: Optional[_str]
    sizeMB: Optional[Union[AtomicFloatInput, _float]]
    status: 'enums.BackupStatus'
    errorLog: Optional[_str]
    createdBy: 'UserUpdateOneWithoutRelationsInput'
    createdAt: datetime.datetime
    completedAt: Optional[datetime.datetime]


class BackupUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    type: 'enums.BackupType'
    location: _str
    fileName: Optional[_str]
    sizeMB: Optional[Union[AtomicFloatInput, _float]]
    status: 'enums.BackupStatus'
    errorLog: Optional[_str]
    createdAt: datetime.datetime
    completedAt: Optional[datetime.datetime]


class BackupUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['BackupCreateWithoutRelationsInput']
    connect: List['BackupWhereUniqueInput']
    set: List['BackupWhereUniqueInput']
    disconnect: List['BackupWhereUniqueInput']
    delete: List['BackupWhereUniqueInput']

    # TODO
    # update: List['BackupUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['BackupUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['BackupScalarWhereInput']
    # upsert: List['BackupUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['BackupCreateOrConnectWithoutRelationsInput']


class BackupUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'BackupCreateWithoutRelationsInput'
    connect: 'BackupWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'BackupUpdateInput'
    # upsert: 'BackupUpsertWithoutRelationsInput'
    # connectOrCreate: 'BackupCreateOrConnectWithoutRelationsInput'


class BackupUpsertInput(TypedDict):
    create: 'BackupCreateInput'
    update: 'BackupUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Backup_id_OrderByInput = TypedDict(
    '_Backup_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Backup_type_OrderByInput = TypedDict(
    '_Backup_type_OrderByInput',
    {
        'type': 'SortOrder',
    },
    total=True
)

_Backup_location_OrderByInput = TypedDict(
    '_Backup_location_OrderByInput',
    {
        'location': 'SortOrder',
    },
    total=True
)

_Backup_fileName_OrderByInput = TypedDict(
    '_Backup_fileName_OrderByInput',
    {
        'fileName': 'SortOrder',
    },
    total=True
)

_Backup_sizeMB_OrderByInput = TypedDict(
    '_Backup_sizeMB_OrderByInput',
    {
        'sizeMB': 'SortOrder',
    },
    total=True
)

_Backup_status_OrderByInput = TypedDict(
    '_Backup_status_OrderByInput',
    {
        'status': 'SortOrder',
    },
    total=True
)

_Backup_errorLog_OrderByInput = TypedDict(
    '_Backup_errorLog_OrderByInput',
    {
        'errorLog': 'SortOrder',
    },
    total=True
)

_Backup_createdById_OrderByInput = TypedDict(
    '_Backup_createdById_OrderByInput',
    {
        'createdById': 'SortOrder',
    },
    total=True
)

_Backup_createdAt_OrderByInput = TypedDict(
    '_Backup_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Backup_completedAt_OrderByInput = TypedDict(
    '_Backup_completedAt_OrderByInput',
    {
        'completedAt': 'SortOrder',
    },
    total=True
)

BackupOrderByInput = Union[
    '_Backup_id_OrderByInput',
    '_Backup_type_OrderByInput',
    '_Backup_location_OrderByInput',
    '_Backup_fileName_OrderByInput',
    '_Backup_sizeMB_OrderByInput',
    '_Backup_status_OrderByInput',
    '_Backup_errorLog_OrderByInput',
    '_Backup_createdById_OrderByInput',
    '_Backup_createdAt_OrderByInput',
    '_Backup_completedAt_OrderByInput',
]



# recursive Backup types
# TODO: cleanup these types



BackupRelationFilter = TypedDict(
    'BackupRelationFilter',
    {
        'is': 'BackupWhereInput',
        'is_not': 'BackupWhereInput',
    },
    total=False,
)


class BackupListRelationFilter(TypedDict, total=False):
    some: 'BackupWhereInput'
    none: 'BackupWhereInput'
    every: 'BackupWhereInput'


class BackupInclude(TypedDict, total=False):
    """Backup relational arguments"""
    createdBy: Union[bool, 'UserArgsFromBackup']


class UserIncludeFromBackup(TypedDict, total=False):
    """Relational arguments for Backup"""
    branch: Union[bool, 'BranchArgsFromBackup']
    auditLogs: Union[bool, 'FindManyAuditLogArgsFromBackup']
    permissions: Union[bool, 'FindManyUserPermissionArgsFromBackup']
    notifications: Union[bool, 'FindManyNotificationArgsFromBackup']
    revokedTokens: Union[bool, 'FindManyRevokedTokenArgsFromBackup']
    stockAdjustments: Union[bool, 'FindManyStockAdjustmentArgsFromBackup']
    Sale: Union[bool, 'FindManySaleArgsFromBackup']
    deletedSales: Union[bool, 'FindManySaleArgsFromBackup']
    Payment: Union[bool, 'FindManyPaymentArgsFromBackup']
    Backup: Union[bool, 'FindManyBackupArgsFromBackup']
    requestedOrders: Union[bool, 'FindManyBranchOrderArgsFromBackup']
    approvedOrders: Union[bool, 'FindManyBranchOrderArgsFromBackup']
    sentOrders: Union[bool, 'FindManyBranchOrderArgsFromBackup']
    receivedOrders: Union[bool, 'FindManyBranchOrderArgsFromBackup']


class UserArgsFromBackup(TypedDict, total=False):
    """Arguments for Backup"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromBackup(TypedDict, total=False):
    """Arguments for Backup"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class UserPermissionIncludeFromBackup(TypedDict, total=False):
    """Relational arguments for Backup"""
    user: Union[bool, 'UserArgsFromBackup']


class UserPermissionArgsFromBackup(TypedDict, total=False):
    """Arguments for Backup"""
    include: 'UserPermissionIncludeFromUserPermission'


class FindManyUserPermissionArgsFromBackup(TypedDict, total=False):
    """Arguments for Backup"""
    take: int
    skip: int
    order_by: Union['UserPermissionOrderByInput', List['UserPermissionOrderByInput']]
    where: 'UserPermissionWhereInput'
    cursor: 'UserPermissionWhereUniqueInput'
    distinct: List['UserPermissionScalarFieldKeys']
    include: 'UserPermissionIncludeFromUserPermission'


class BranchIncludeFromBackup(TypedDict, total=False):
    """Relational arguments for Backup"""
    users: Union[bool, 'FindManyUserArgsFromBackup']
    Sale: Union[bool, 'FindManySaleArgsFromBackup']
    Account: Union[bool, 'FindManyAccountArgsFromBackup']
    BranchOrder: Union[bool, 'FindManyBranchOrderArgsFromBackup']


class BranchArgsFromBackup(TypedDict, total=False):
    """Arguments for Backup"""
    include: 'BranchIncludeFromBranch'


class FindManyBranchArgsFromBackup(TypedDict, total=False):
    """Arguments for Backup"""
    take: int
    skip: int
    order_by: Union['BranchOrderByInput', List['BranchOrderByInput']]
    where: 'BranchWhereInput'
    cursor: 'BranchWhereUniqueInput'
    distinct: List['BranchScalarFieldKeys']
    include: 'BranchIncludeFromBranch'


class ProductIncludeFromBackup(TypedDict, total=False):
    """Relational arguments for Backup"""
    category: Union[bool, 'CategoryArgsFromBackup']
    stocks: Union[bool, 'FindManyStockArgsFromBackup']
    stockAdjustments: Union[bool, 'FindManyStockAdjustmentArgsFromBackup']


class ProductArgsFromBackup(TypedDict, total=False):
    """Arguments for Backup"""
    include: 'ProductIncludeFromProduct'


class FindManyProductArgsFromBackup(TypedDict, total=False):
    """Arguments for Backup"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProduct'


class CategoryIncludeFromBackup(TypedDict, total=False):
    """Relational arguments for Backup"""
    products: Union[bool, 'FindManyProductArgsFromBackup']


class CategoryArgsFromBackup(TypedDict, total=False):
    """Arguments for Backup"""
    include: 'CategoryIncludeFromCategory'


class FindManyCategoryArgsFromBackup(TypedDict, total=False):
    """Arguments for Backup"""
    take: int
    skip: int
    order_by: Union['CategoryOrderByInput', List['CategoryOrderByInput']]
    where: 'CategoryWhereInput'
    cursor: 'CategoryWhereUniqueInput'
    distinct: List['CategoryScalarFieldKeys']
    include: 'CategoryIncludeFromCategory'


class StockIncludeFromBackup(TypedDict, total=False):
    """Relational arguments for Backup"""
    product: Union[bool, 'ProductArgsFromBackup']
    SaleItem: Union[bool, 'FindManySaleItemArgsFromBackup']
    BranchOrderItem: Union[bool, 'FindManyBranchOrderItemArgsFromBackup']


class StockArgsFromBackup(TypedDict, total=False):
    """Arguments for Backup"""
    include: 'StockIncludeFromStock'


class FindManyStockArgsFromBackup(TypedDict, total=False):
    """Arguments for Backup"""
    take: int
    skip: int
    order_by: Union['StockOrderByInput', List['StockOrderByInput']]
    where: 'StockWhereInput'
    cursor: 'StockWhereUniqueInput'
    distinct: List['StockScalarFieldKeys']
    include: 'StockIncludeFromStock'


class CustomerIncludeFromBackup(TypedDict, total=False):
    """Relational arguments for Backup"""
    Sale: Union[bool, 'FindManySaleArgsFromBackup']


class CustomerArgsFromBackup(TypedDict, total=False):
    """Arguments for Backup"""
    include: 'CustomerIncludeFromCustomer'


class FindManyCustomerArgsFromBackup(TypedDict, total=False):
    """Arguments for Backup"""
    take: int
    skip: int
    order_by: Union['CustomerOrderByInput', List['CustomerOrderByInput']]
    where: 'CustomerWhereInput'
    cursor: 'CustomerWhereUniqueInput'
    distinct: List['CustomerScalarFieldKeys']
    include: 'CustomerIncludeFromCustomer'


class SaleIncludeFromBackup(TypedDict, total=False):
    """Relational arguments for Backup"""
    branch: Union[bool, 'BranchArgsFromBackup']
    customer: Union[bool, 'CustomerArgsFromBackup']
    user: Union[bool, 'UserArgsFromBackup']
    items: Union[bool, 'FindManySaleItemArgsFromBackup']
    payments: Union[bool, 'FindManyPaymentArgsFromBackup']
    returns: Union[bool, 'FindManyReturnSaleArgsFromBackup']
    deletedBy: Union[bool, 'UserArgsFromBackup']


class SaleArgsFromBackup(TypedDict, total=False):
    """Arguments for Backup"""
    include: 'SaleIncludeFromSale'


class FindManySaleArgsFromBackup(TypedDict, total=False):
    """Arguments for Backup"""
    take: int
    skip: int
    order_by: Union['SaleOrderByInput', List['SaleOrderByInput']]
    where: 'SaleWhereInput'
    cursor: 'SaleWhereUniqueInput'
    distinct: List['SaleScalarFieldKeys']
    include: 'SaleIncludeFromSale'


class SaleItemIncludeFromBackup(TypedDict, total=False):
    """Relational arguments for Backup"""
    sale: Union[bool, 'SaleArgsFromBackup']
    stock: Union[bool, 'StockArgsFromBackup']
    ReturnItem: Union[bool, 'FindManyReturnItemArgsFromBackup']


class SaleItemArgsFromBackup(TypedDict, total=False):
    """Arguments for Backup"""
    include: 'SaleItemIncludeFromSaleItem'


class FindManySaleItemArgsFromBackup(TypedDict, total=False):
    """Arguments for Backup"""
    take: int
    skip: int
    order_by: Union['SaleItemOrderByInput', List['SaleItemOrderByInput']]
    where: 'SaleItemWhereInput'
    cursor: 'SaleItemWhereUniqueInput'
    distinct: List['SaleItemScalarFieldKeys']
    include: 'SaleItemIncludeFromSaleItem'


class ReturnSaleIncludeFromBackup(TypedDict, total=False):
    """Relational arguments for Backup"""
    original: Union[bool, 'SaleArgsFromBackup']
    items: Union[bool, 'FindManyReturnItemArgsFromBackup']
    refund: Union[bool, 'FindManyPaymentArgsFromBackup']


class ReturnSaleArgsFromBackup(TypedDict, total=False):
    """Arguments for Backup"""
    include: 'ReturnSaleIncludeFromReturnSale'


class FindManyReturnSaleArgsFromBackup(TypedDict, total=False):
    """Arguments for Backup"""
    take: int
    skip: int
    order_by: Union['ReturnSaleOrderByInput', List['ReturnSaleOrderByInput']]
    where: 'ReturnSaleWhereInput'
    cursor: 'ReturnSaleWhereUniqueInput'
    distinct: List['ReturnSaleScalarFieldKeys']
    include: 'ReturnSaleIncludeFromReturnSale'


class ReturnItemIncludeFromBackup(TypedDict, total=False):
    """Relational arguments for Backup"""
    returnSale: Union[bool, 'ReturnSaleArgsFromBackup']
    saleItem: Union[bool, 'SaleItemArgsFromBackup']


class ReturnItemArgsFromBackup(TypedDict, total=False):
    """Arguments for Backup"""
    include: 'ReturnItemIncludeFromReturnItem'


class FindManyReturnItemArgsFromBackup(TypedDict, total=False):
    """Arguments for Backup"""
    take: int
    skip: int
    order_by: Union['ReturnItemOrderByInput', List['ReturnItemOrderByInput']]
    where: 'ReturnItemWhereInput'
    cursor: 'ReturnItemWhereUniqueInput'
    distinct: List['ReturnItemScalarFieldKeys']
    include: 'ReturnItemIncludeFromReturnItem'


class PaymentIncludeFromBackup(TypedDict, total=False):
    """Relational arguments for Backup"""
    sale: Union[bool, 'SaleArgsFromBackup']
    account: Union[bool, 'AccountArgsFromBackup']
    returnSale: Union[bool, 'ReturnSaleArgsFromBackup']
    user: Union[bool, 'UserArgsFromBackup']


class PaymentArgsFromBackup(TypedDict, total=False):
    """Arguments for Backup"""
    include: 'PaymentIncludeFromPayment'


class FindManyPaymentArgsFromBackup(TypedDict, total=False):
    """Arguments for Backup"""
    take: int
    skip: int
    order_by: Union['PaymentOrderByInput', List['PaymentOrderByInput']]
    where: 'PaymentWhereInput'
    cursor: 'PaymentWhereUniqueInput'
    distinct: List['PaymentScalarFieldKeys']
    include: 'PaymentIncludeFromPayment'


class JournalEntryIncludeFromBackup(TypedDict, total=False):
    """Relational arguments for Backup"""
    lines: Union[bool, 'FindManyJournalEntryLineArgsFromBackup']


class JournalEntryArgsFromBackup(TypedDict, total=False):
    """Arguments for Backup"""
    include: 'JournalEntryIncludeFromJournalEntry'


class FindManyJournalEntryArgsFromBackup(TypedDict, total=False):
    """Arguments for Backup"""
    take: int
    skip: int
    order_by: Union['JournalEntryOrderByInput', List['JournalEntryOrderByInput']]
    where: 'JournalEntryWhereInput'
    cursor: 'JournalEntryWhereUniqueInput'
    distinct: List['JournalEntryScalarFieldKeys']
    include: 'JournalEntryIncludeFromJournalEntry'


class JournalEntryLineIncludeFromBackup(TypedDict, total=False):
    """Relational arguments for Backup"""
    entry: Union[bool, 'JournalEntryArgsFromBackup']
    account: Union[bool, 'AccountArgsFromBackup']


class JournalEntryLineArgsFromBackup(TypedDict, total=False):
    """Arguments for Backup"""
    include: 'JournalEntryLineIncludeFromJournalEntryLine'


class FindManyJournalEntryLineArgsFromBackup(TypedDict, total=False):
    """Arguments for Backup"""
    take: int
    skip: int
    order_by: Union['JournalEntryLineOrderByInput', List['JournalEntryLineOrderByInput']]
    where: 'JournalEntryLineWhereInput'
    cursor: 'JournalEntryLineWhereUniqueInput'
    distinct: List['JournalEntryLineScalarFieldKeys']
    include: 'JournalEntryLineIncludeFromJournalEntryLine'


class AccountIncludeFromBackup(TypedDict, total=False):
    """Relational arguments for Backup"""
    branch: Union[bool, 'BranchArgsFromBackup']
    entries: Union[bool, 'FindManyJournalEntryLineArgsFromBackup']
    payments: Union[bool, 'FindManyPaymentArgsFromBackup']
    outgoingTransfers: Union[bool, 'FindManyAccountTransferArgsFromBackup']
    incomingTransfers: Union[bool, 'FindManyAccountTransferArgsFromBackup']


class AccountArgsFromBackup(TypedDict, total=False):
    """Arguments for Backup"""
    include: 'AccountIncludeFromAccount'


class FindManyAccountArgsFromBackup(TypedDict, total=False):
    """Arguments for Backup"""
    take: int
    skip: int
    order_by: Union['AccountOrderByInput', List['AccountOrderByInput']]
    where: 'AccountWhereInput'
    cursor: 'AccountWhereUniqueInput'
    distinct: List['AccountScalarFieldKeys']
    include: 'AccountIncludeFromAccount'


class AccountTransferIncludeFromBackup(TypedDict, total=False):
    """Relational arguments for Backup"""
    fromAccount: Union[bool, 'AccountArgsFromBackup']
    toAccount: Union[bool, 'AccountArgsFromBackup']


class AccountTransferArgsFromBackup(TypedDict, total=False):
    """Arguments for Backup"""
    include: 'AccountTransferIncludeFromAccountTransfer'


class FindManyAccountTransferArgsFromBackup(TypedDict, total=False):
    """Arguments for Backup"""
    take: int
    skip: int
    order_by: Union['AccountTransferOrderByInput', List['AccountTransferOrderByInput']]
    where: 'AccountTransferWhereInput'
    cursor: 'AccountTransferWhereUniqueInput'
    distinct: List['AccountTransferScalarFieldKeys']
    include: 'AccountTransferIncludeFromAccountTransfer'


class BranchOrderIncludeFromBackup(TypedDict, total=False):
    """Relational arguments for Backup"""
    branch: Union[bool, 'BranchArgsFromBackup']
    requestedBy: Union[bool, 'UserArgsFromBackup']
    approvedBy: Union[bool, 'UserArgsFromBackup']
    sentBy: Union[bool, 'UserArgsFromBackup']
    receivedBy: Union[bool, 'UserArgsFromBackup']
    items: Union[bool, 'FindManyBranchOrderItemArgsFromBackup']


class BranchOrderArgsFromBackup(TypedDict, total=False):
    """Arguments for Backup"""
    include: 'BranchOrderIncludeFromBranchOrder'


class FindManyBranchOrderArgsFromBackup(TypedDict, total=False):
    """Arguments for Backup"""
    take: int
    skip: int
    order_by: Union['BranchOrderOrderByInput', List['BranchOrderOrderByInput']]
    where: 'BranchOrderWhereInput'
    cursor: 'BranchOrderWhereUniqueInput'
    distinct: List['BranchOrderScalarFieldKeys']
    include: 'BranchOrderIncludeFromBranchOrder'


class BranchOrderItemIncludeFromBackup(TypedDict, total=False):
    """Relational arguments for Backup"""
    branchOrder: Union[bool, 'BranchOrderArgsFromBackup']
    stock: Union[bool, 'StockArgsFromBackup']


class BranchOrderItemArgsFromBackup(TypedDict, total=False):
    """Arguments for Backup"""
    include: 'BranchOrderItemIncludeFromBranchOrderItem'


class FindManyBranchOrderItemArgsFromBackup(TypedDict, total=False):
    """Arguments for Backup"""
    take: int
    skip: int
    order_by: Union['BranchOrderItemOrderByInput', List['BranchOrderItemOrderByInput']]
    where: 'BranchOrderItemWhereInput'
    cursor: 'BranchOrderItemWhereUniqueInput'
    distinct: List['BranchOrderItemScalarFieldKeys']
    include: 'BranchOrderItemIncludeFromBranchOrderItem'


class AuditLogIncludeFromBackup(TypedDict, total=False):
    """Relational arguments for Backup"""
    user: Union[bool, 'UserArgsFromBackup']


class AuditLogArgsFromBackup(TypedDict, total=False):
    """Arguments for Backup"""
    include: 'AuditLogIncludeFromAuditLog'


class FindManyAuditLogArgsFromBackup(TypedDict, total=False):
    """Arguments for Backup"""
    take: int
    skip: int
    order_by: Union['AuditLogOrderByInput', List['AuditLogOrderByInput']]
    where: 'AuditLogWhereInput'
    cursor: 'AuditLogWhereUniqueInput'
    distinct: List['AuditLogScalarFieldKeys']
    include: 'AuditLogIncludeFromAuditLog'


class SystemInfoIncludeFromBackup(TypedDict, total=False):
    """Relational arguments for Backup"""


class SystemInfoArgsFromBackup(TypedDict, total=False):
    """Arguments for Backup"""
    include: 'SystemInfoIncludeFromSystemInfo'


class FindManySystemInfoArgsFromBackup(TypedDict, total=False):
    """Arguments for Backup"""
    take: int
    skip: int
    order_by: Union['SystemInfoOrderByInput', List['SystemInfoOrderByInput']]
    where: 'SystemInfoWhereInput'
    cursor: 'SystemInfoWhereUniqueInput'
    distinct: List['SystemInfoScalarFieldKeys']
    include: 'SystemInfoIncludeFromSystemInfo'


class BackupIncludeFromBackup(TypedDict, total=False):
    """Relational arguments for Backup"""
    createdBy: Union[bool, 'UserArgsFromBackup']


class BackupArgsFromBackup(TypedDict, total=False):
    """Arguments for Backup"""
    include: 'BackupIncludeFromBackup'


class FindManyBackupArgsFromBackup(TypedDict, total=False):
    """Arguments for Backup"""
    take: int
    skip: int
    order_by: Union['BackupOrderByInput', List['BackupOrderByInput']]
    where: 'BackupWhereInput'
    cursor: 'BackupWhereUniqueInput'
    distinct: List['BackupScalarFieldKeys']
    include: 'BackupIncludeFromBackup'


class RevokedTokenIncludeFromBackup(TypedDict, total=False):
    """Relational arguments for Backup"""
    user: Union[bool, 'UserArgsFromBackup']


class RevokedTokenArgsFromBackup(TypedDict, total=False):
    """Arguments for Backup"""
    include: 'RevokedTokenIncludeFromRevokedToken'


class FindManyRevokedTokenArgsFromBackup(TypedDict, total=False):
    """Arguments for Backup"""
    take: int
    skip: int
    order_by: Union['RevokedTokenOrderByInput', List['RevokedTokenOrderByInput']]
    where: 'RevokedTokenWhereInput'
    cursor: 'RevokedTokenWhereUniqueInput'
    distinct: List['RevokedTokenScalarFieldKeys']
    include: 'RevokedTokenIncludeFromRevokedToken'


class SystemSettingIncludeFromBackup(TypedDict, total=False):
    """Relational arguments for Backup"""


class SystemSettingArgsFromBackup(TypedDict, total=False):
    """Arguments for Backup"""
    include: 'SystemSettingIncludeFromSystemSetting'


class FindManySystemSettingArgsFromBackup(TypedDict, total=False):
    """Arguments for Backup"""
    take: int
    skip: int
    order_by: Union['SystemSettingOrderByInput', List['SystemSettingOrderByInput']]
    where: 'SystemSettingWhereInput'
    cursor: 'SystemSettingWhereUniqueInput'
    distinct: List['SystemSettingScalarFieldKeys']
    include: 'SystemSettingIncludeFromSystemSetting'


class NotificationIncludeFromBackup(TypedDict, total=False):
    """Relational arguments for Backup"""
    user: Union[bool, 'UserArgsFromBackup']


class NotificationArgsFromBackup(TypedDict, total=False):
    """Arguments for Backup"""
    include: 'NotificationIncludeFromNotification'


class FindManyNotificationArgsFromBackup(TypedDict, total=False):
    """Arguments for Backup"""
    take: int
    skip: int
    order_by: Union['NotificationOrderByInput', List['NotificationOrderByInput']]
    where: 'NotificationWhereInput'
    cursor: 'NotificationWhereUniqueInput'
    distinct: List['NotificationScalarFieldKeys']
    include: 'NotificationIncludeFromNotification'


class StockAdjustmentIncludeFromBackup(TypedDict, total=False):
    """Relational arguments for Backup"""
    product: Union[bool, 'ProductArgsFromBackup']
    createdBy: Union[bool, 'UserArgsFromBackup']


class StockAdjustmentArgsFromBackup(TypedDict, total=False):
    """Arguments for Backup"""
    include: 'StockAdjustmentIncludeFromStockAdjustment'


class FindManyStockAdjustmentArgsFromBackup(TypedDict, total=False):
    """Arguments for Backup"""
    take: int
    skip: int
    order_by: Union['StockAdjustmentOrderByInput', List['StockAdjustmentOrderByInput']]
    where: 'StockAdjustmentWhereInput'
    cursor: 'StockAdjustmentWhereUniqueInput'
    distinct: List['StockAdjustmentScalarFieldKeys']
    include: 'StockAdjustmentIncludeFromStockAdjustment'




FindManyBackupArgs = FindManyBackupArgsFromBackup
FindFirstBackupArgs = FindManyBackupArgsFromBackup


class BackupWhereInput(TypedDict, total=False):
    """Backup arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    type: 'enums.BackupType'
    location: Union[_str, 'types.StringFilter']
    fileName: Union[None, _str, 'types.StringFilter']
    sizeMB: Union[None, _float, 'types.FloatFilter']
    status: 'enums.BackupStatus'
    errorLog: Union[None, _str, 'types.StringFilter']
    createdBy: 'UserRelationFilter'
    createdById: Union[None, _int, 'types.IntFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    completedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['BackupWhereInput', List['BackupWhereInput']]
    # but this causes mypy to hang :/
    AND: List['BackupWhereInput']
    OR: List['BackupWhereInput']
    NOT: List['BackupWhereInput']



# aggregate Backup types


class BackupScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Backup arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    type: 'enums.BackupType'
    location: Union[_str, 'types.StringWithAggregatesFilter']
    fileName: Union[_str, 'types.StringWithAggregatesFilter']
    sizeMB: Union[_float, 'types.FloatWithAggregatesFilter']
    status: 'enums.BackupStatus'
    errorLog: Union[_str, 'types.StringWithAggregatesFilter']
    createdById: Union[_int, 'types.IntWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    completedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['BackupScalarWhereWithAggregatesInput']
    OR: List['BackupScalarWhereWithAggregatesInput']
    NOT: List['BackupScalarWhereWithAggregatesInput']



class BackupGroupByOutput(TypedDict, total=False):
    id: _int
    type: 'enums.BackupType'
    location: _str
    fileName: _str
    sizeMB: _float
    status: 'enums.BackupStatus'
    errorLog: _str
    createdById: _int
    createdAt: datetime.datetime
    completedAt: datetime.datetime
    _sum: 'BackupSumAggregateOutput'
    _avg: 'BackupAvgAggregateOutput'
    _min: 'BackupMinAggregateOutput'
    _max: 'BackupMaxAggregateOutput'
    _count: 'BackupCountAggregateOutput'


class BackupAvgAggregateOutput(TypedDict, total=False):
    """Backup output for aggregating averages"""
    id: float
    sizeMB: float
    createdById: float


class BackupSumAggregateOutput(TypedDict, total=False):
    """Backup output for aggregating sums"""
    id: _int
    sizeMB: _float
    createdById: _int


class BackupScalarAggregateOutput(TypedDict, total=False):
    """Backup output including scalar fields"""
    id: _int
    type: 'enums.BackupType'
    location: _str
    fileName: _str
    sizeMB: _float
    status: 'enums.BackupStatus'
    errorLog: _str
    createdById: _int
    createdAt: datetime.datetime
    completedAt: datetime.datetime


BackupMinAggregateOutput = BackupScalarAggregateOutput
BackupMaxAggregateOutput = BackupScalarAggregateOutput


class BackupMaxAggregateInput(TypedDict, total=False):
    """Backup input for aggregating by max"""
    id: bool
    type: bool
    location: bool
    fileName: bool
    sizeMB: bool
    status: bool
    errorLog: bool
    createdById: bool
    createdAt: bool
    completedAt: bool


class BackupMinAggregateInput(TypedDict, total=False):
    """Backup input for aggregating by min"""
    id: bool
    type: bool
    location: bool
    fileName: bool
    sizeMB: bool
    status: bool
    errorLog: bool
    createdById: bool
    createdAt: bool
    completedAt: bool


class BackupNumberAggregateInput(TypedDict, total=False):
    """Backup input for aggregating numbers"""
    id: bool
    sizeMB: bool
    createdById: bool


BackupAvgAggregateInput = BackupNumberAggregateInput
BackupSumAggregateInput = BackupNumberAggregateInput


BackupCountAggregateInput = TypedDict(
    'BackupCountAggregateInput',
    {
        'id': bool,
        'type': bool,
        'location': bool,
        'fileName': bool,
        'sizeMB': bool,
        'status': bool,
        'errorLog': bool,
        'createdById': bool,
        'createdAt': bool,
        'completedAt': bool,
        '_all': bool,
    },
    total=False,
)

BackupCountAggregateOutput = TypedDict(
    'BackupCountAggregateOutput',
    {
        'id': int,
        'type': int,
        'location': int,
        'fileName': int,
        'sizeMB': int,
        'status': int,
        'errorLog': int,
        'createdById': int,
        'createdAt': int,
        'completedAt': int,
        '_all': int,
    },
    total=False,
)


BackupKeys = Literal[
    'id',
    'type',
    'location',
    'fileName',
    'sizeMB',
    'status',
    'errorLog',
    'createdBy',
    'createdById',
    'createdAt',
    'completedAt',
]
BackupScalarFieldKeys = Literal[
    'id',
    'type',
    'location',
    'fileName',
    'sizeMB',
    'status',
    'errorLog',
    'createdById',
    'createdAt',
    'completedAt',
]
BackupScalarFieldKeysT = TypeVar('BackupScalarFieldKeysT', bound=BackupScalarFieldKeys)

BackupRelationalFieldKeys = Literal[
        'createdBy',
    ]

# RevokedToken types

class RevokedTokenOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the RevokedToken create method"""
    id: _int
    reason: Optional[_str]
    revokedBy: Optional[_int]
    createdAt: datetime.datetime
    user: 'UserCreateNestedWithoutRelationsInput'


class RevokedTokenCreateInput(RevokedTokenOptionalCreateInput):
    """Required arguments to the RevokedToken create method"""
    jti: _str
    token: _str
    expiresAt: datetime.datetime


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class RevokedTokenOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the RevokedToken create method, without relations"""
    id: _int
    reason: Optional[_str]
    revokedBy: Optional[_int]
    createdAt: datetime.datetime


class RevokedTokenCreateWithoutRelationsInput(RevokedTokenOptionalCreateWithoutRelationsInput):
    """Required arguments to the RevokedToken create method, without relations"""
    jti: _str
    token: _str
    expiresAt: datetime.datetime


class RevokedTokenCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'RevokedTokenCreateWithoutRelationsInput'
    connect: 'RevokedTokenWhereUniqueInput'


class RevokedTokenCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['RevokedTokenCreateWithoutRelationsInput', List['RevokedTokenCreateWithoutRelationsInput']]
    connect: Union['RevokedTokenWhereUniqueInput', List['RevokedTokenWhereUniqueInput']]


_RevokedTokenWhereUnique_id_Input = TypedDict(
    '_RevokedTokenWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

_RevokedTokenWhereUnique_jti_Input = TypedDict(
    '_RevokedTokenWhereUnique_jti_Input',
    {
        'jti': '_str',
    },
    total=True
)

RevokedTokenWhereUniqueInput = Union[
    '_RevokedTokenWhereUnique_id_Input',
    '_RevokedTokenWhereUnique_jti_Input',
]


class RevokedTokenUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    jti: _str
    token: _str
    reason: Optional[_str]
    expiresAt: datetime.datetime
    createdAt: datetime.datetime
    user: 'UserUpdateOneWithoutRelationsInput'


class RevokedTokenUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    jti: _str
    token: _str
    reason: Optional[_str]
    expiresAt: datetime.datetime
    createdAt: datetime.datetime


class RevokedTokenUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['RevokedTokenCreateWithoutRelationsInput']
    connect: List['RevokedTokenWhereUniqueInput']
    set: List['RevokedTokenWhereUniqueInput']
    disconnect: List['RevokedTokenWhereUniqueInput']
    delete: List['RevokedTokenWhereUniqueInput']

    # TODO
    # update: List['RevokedTokenUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['RevokedTokenUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['RevokedTokenScalarWhereInput']
    # upsert: List['RevokedTokenUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['RevokedTokenCreateOrConnectWithoutRelationsInput']


class RevokedTokenUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'RevokedTokenCreateWithoutRelationsInput'
    connect: 'RevokedTokenWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'RevokedTokenUpdateInput'
    # upsert: 'RevokedTokenUpsertWithoutRelationsInput'
    # connectOrCreate: 'RevokedTokenCreateOrConnectWithoutRelationsInput'


class RevokedTokenUpsertInput(TypedDict):
    create: 'RevokedTokenCreateInput'
    update: 'RevokedTokenUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_RevokedToken_id_OrderByInput = TypedDict(
    '_RevokedToken_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_RevokedToken_jti_OrderByInput = TypedDict(
    '_RevokedToken_jti_OrderByInput',
    {
        'jti': 'SortOrder',
    },
    total=True
)

_RevokedToken_token_OrderByInput = TypedDict(
    '_RevokedToken_token_OrderByInput',
    {
        'token': 'SortOrder',
    },
    total=True
)

_RevokedToken_reason_OrderByInput = TypedDict(
    '_RevokedToken_reason_OrderByInput',
    {
        'reason': 'SortOrder',
    },
    total=True
)

_RevokedToken_expiresAt_OrderByInput = TypedDict(
    '_RevokedToken_expiresAt_OrderByInput',
    {
        'expiresAt': 'SortOrder',
    },
    total=True
)

_RevokedToken_revokedBy_OrderByInput = TypedDict(
    '_RevokedToken_revokedBy_OrderByInput',
    {
        'revokedBy': 'SortOrder',
    },
    total=True
)

_RevokedToken_createdAt_OrderByInput = TypedDict(
    '_RevokedToken_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

RevokedTokenOrderByInput = Union[
    '_RevokedToken_id_OrderByInput',
    '_RevokedToken_jti_OrderByInput',
    '_RevokedToken_token_OrderByInput',
    '_RevokedToken_reason_OrderByInput',
    '_RevokedToken_expiresAt_OrderByInput',
    '_RevokedToken_revokedBy_OrderByInput',
    '_RevokedToken_createdAt_OrderByInput',
]



# recursive RevokedToken types
# TODO: cleanup these types



RevokedTokenRelationFilter = TypedDict(
    'RevokedTokenRelationFilter',
    {
        'is': 'RevokedTokenWhereInput',
        'is_not': 'RevokedTokenWhereInput',
    },
    total=False,
)


class RevokedTokenListRelationFilter(TypedDict, total=False):
    some: 'RevokedTokenWhereInput'
    none: 'RevokedTokenWhereInput'
    every: 'RevokedTokenWhereInput'


class RevokedTokenInclude(TypedDict, total=False):
    """RevokedToken relational arguments"""
    user: Union[bool, 'UserArgsFromRevokedToken']


class UserIncludeFromRevokedToken(TypedDict, total=False):
    """Relational arguments for RevokedToken"""
    branch: Union[bool, 'BranchArgsFromRevokedToken']
    auditLogs: Union[bool, 'FindManyAuditLogArgsFromRevokedToken']
    permissions: Union[bool, 'FindManyUserPermissionArgsFromRevokedToken']
    notifications: Union[bool, 'FindManyNotificationArgsFromRevokedToken']
    revokedTokens: Union[bool, 'FindManyRevokedTokenArgsFromRevokedToken']
    stockAdjustments: Union[bool, 'FindManyStockAdjustmentArgsFromRevokedToken']
    Sale: Union[bool, 'FindManySaleArgsFromRevokedToken']
    deletedSales: Union[bool, 'FindManySaleArgsFromRevokedToken']
    Payment: Union[bool, 'FindManyPaymentArgsFromRevokedToken']
    Backup: Union[bool, 'FindManyBackupArgsFromRevokedToken']
    requestedOrders: Union[bool, 'FindManyBranchOrderArgsFromRevokedToken']
    approvedOrders: Union[bool, 'FindManyBranchOrderArgsFromRevokedToken']
    sentOrders: Union[bool, 'FindManyBranchOrderArgsFromRevokedToken']
    receivedOrders: Union[bool, 'FindManyBranchOrderArgsFromRevokedToken']


class UserArgsFromRevokedToken(TypedDict, total=False):
    """Arguments for RevokedToken"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromRevokedToken(TypedDict, total=False):
    """Arguments for RevokedToken"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class UserPermissionIncludeFromRevokedToken(TypedDict, total=False):
    """Relational arguments for RevokedToken"""
    user: Union[bool, 'UserArgsFromRevokedToken']


class UserPermissionArgsFromRevokedToken(TypedDict, total=False):
    """Arguments for RevokedToken"""
    include: 'UserPermissionIncludeFromUserPermission'


class FindManyUserPermissionArgsFromRevokedToken(TypedDict, total=False):
    """Arguments for RevokedToken"""
    take: int
    skip: int
    order_by: Union['UserPermissionOrderByInput', List['UserPermissionOrderByInput']]
    where: 'UserPermissionWhereInput'
    cursor: 'UserPermissionWhereUniqueInput'
    distinct: List['UserPermissionScalarFieldKeys']
    include: 'UserPermissionIncludeFromUserPermission'


class BranchIncludeFromRevokedToken(TypedDict, total=False):
    """Relational arguments for RevokedToken"""
    users: Union[bool, 'FindManyUserArgsFromRevokedToken']
    Sale: Union[bool, 'FindManySaleArgsFromRevokedToken']
    Account: Union[bool, 'FindManyAccountArgsFromRevokedToken']
    BranchOrder: Union[bool, 'FindManyBranchOrderArgsFromRevokedToken']


class BranchArgsFromRevokedToken(TypedDict, total=False):
    """Arguments for RevokedToken"""
    include: 'BranchIncludeFromBranch'


class FindManyBranchArgsFromRevokedToken(TypedDict, total=False):
    """Arguments for RevokedToken"""
    take: int
    skip: int
    order_by: Union['BranchOrderByInput', List['BranchOrderByInput']]
    where: 'BranchWhereInput'
    cursor: 'BranchWhereUniqueInput'
    distinct: List['BranchScalarFieldKeys']
    include: 'BranchIncludeFromBranch'


class ProductIncludeFromRevokedToken(TypedDict, total=False):
    """Relational arguments for RevokedToken"""
    category: Union[bool, 'CategoryArgsFromRevokedToken']
    stocks: Union[bool, 'FindManyStockArgsFromRevokedToken']
    stockAdjustments: Union[bool, 'FindManyStockAdjustmentArgsFromRevokedToken']


class ProductArgsFromRevokedToken(TypedDict, total=False):
    """Arguments for RevokedToken"""
    include: 'ProductIncludeFromProduct'


class FindManyProductArgsFromRevokedToken(TypedDict, total=False):
    """Arguments for RevokedToken"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProduct'


class CategoryIncludeFromRevokedToken(TypedDict, total=False):
    """Relational arguments for RevokedToken"""
    products: Union[bool, 'FindManyProductArgsFromRevokedToken']


class CategoryArgsFromRevokedToken(TypedDict, total=False):
    """Arguments for RevokedToken"""
    include: 'CategoryIncludeFromCategory'


class FindManyCategoryArgsFromRevokedToken(TypedDict, total=False):
    """Arguments for RevokedToken"""
    take: int
    skip: int
    order_by: Union['CategoryOrderByInput', List['CategoryOrderByInput']]
    where: 'CategoryWhereInput'
    cursor: 'CategoryWhereUniqueInput'
    distinct: List['CategoryScalarFieldKeys']
    include: 'CategoryIncludeFromCategory'


class StockIncludeFromRevokedToken(TypedDict, total=False):
    """Relational arguments for RevokedToken"""
    product: Union[bool, 'ProductArgsFromRevokedToken']
    SaleItem: Union[bool, 'FindManySaleItemArgsFromRevokedToken']
    BranchOrderItem: Union[bool, 'FindManyBranchOrderItemArgsFromRevokedToken']


class StockArgsFromRevokedToken(TypedDict, total=False):
    """Arguments for RevokedToken"""
    include: 'StockIncludeFromStock'


class FindManyStockArgsFromRevokedToken(TypedDict, total=False):
    """Arguments for RevokedToken"""
    take: int
    skip: int
    order_by: Union['StockOrderByInput', List['StockOrderByInput']]
    where: 'StockWhereInput'
    cursor: 'StockWhereUniqueInput'
    distinct: List['StockScalarFieldKeys']
    include: 'StockIncludeFromStock'


class CustomerIncludeFromRevokedToken(TypedDict, total=False):
    """Relational arguments for RevokedToken"""
    Sale: Union[bool, 'FindManySaleArgsFromRevokedToken']


class CustomerArgsFromRevokedToken(TypedDict, total=False):
    """Arguments for RevokedToken"""
    include: 'CustomerIncludeFromCustomer'


class FindManyCustomerArgsFromRevokedToken(TypedDict, total=False):
    """Arguments for RevokedToken"""
    take: int
    skip: int
    order_by: Union['CustomerOrderByInput', List['CustomerOrderByInput']]
    where: 'CustomerWhereInput'
    cursor: 'CustomerWhereUniqueInput'
    distinct: List['CustomerScalarFieldKeys']
    include: 'CustomerIncludeFromCustomer'


class SaleIncludeFromRevokedToken(TypedDict, total=False):
    """Relational arguments for RevokedToken"""
    branch: Union[bool, 'BranchArgsFromRevokedToken']
    customer: Union[bool, 'CustomerArgsFromRevokedToken']
    user: Union[bool, 'UserArgsFromRevokedToken']
    items: Union[bool, 'FindManySaleItemArgsFromRevokedToken']
    payments: Union[bool, 'FindManyPaymentArgsFromRevokedToken']
    returns: Union[bool, 'FindManyReturnSaleArgsFromRevokedToken']
    deletedBy: Union[bool, 'UserArgsFromRevokedToken']


class SaleArgsFromRevokedToken(TypedDict, total=False):
    """Arguments for RevokedToken"""
    include: 'SaleIncludeFromSale'


class FindManySaleArgsFromRevokedToken(TypedDict, total=False):
    """Arguments for RevokedToken"""
    take: int
    skip: int
    order_by: Union['SaleOrderByInput', List['SaleOrderByInput']]
    where: 'SaleWhereInput'
    cursor: 'SaleWhereUniqueInput'
    distinct: List['SaleScalarFieldKeys']
    include: 'SaleIncludeFromSale'


class SaleItemIncludeFromRevokedToken(TypedDict, total=False):
    """Relational arguments for RevokedToken"""
    sale: Union[bool, 'SaleArgsFromRevokedToken']
    stock: Union[bool, 'StockArgsFromRevokedToken']
    ReturnItem: Union[bool, 'FindManyReturnItemArgsFromRevokedToken']


class SaleItemArgsFromRevokedToken(TypedDict, total=False):
    """Arguments for RevokedToken"""
    include: 'SaleItemIncludeFromSaleItem'


class FindManySaleItemArgsFromRevokedToken(TypedDict, total=False):
    """Arguments for RevokedToken"""
    take: int
    skip: int
    order_by: Union['SaleItemOrderByInput', List['SaleItemOrderByInput']]
    where: 'SaleItemWhereInput'
    cursor: 'SaleItemWhereUniqueInput'
    distinct: List['SaleItemScalarFieldKeys']
    include: 'SaleItemIncludeFromSaleItem'


class ReturnSaleIncludeFromRevokedToken(TypedDict, total=False):
    """Relational arguments for RevokedToken"""
    original: Union[bool, 'SaleArgsFromRevokedToken']
    items: Union[bool, 'FindManyReturnItemArgsFromRevokedToken']
    refund: Union[bool, 'FindManyPaymentArgsFromRevokedToken']


class ReturnSaleArgsFromRevokedToken(TypedDict, total=False):
    """Arguments for RevokedToken"""
    include: 'ReturnSaleIncludeFromReturnSale'


class FindManyReturnSaleArgsFromRevokedToken(TypedDict, total=False):
    """Arguments for RevokedToken"""
    take: int
    skip: int
    order_by: Union['ReturnSaleOrderByInput', List['ReturnSaleOrderByInput']]
    where: 'ReturnSaleWhereInput'
    cursor: 'ReturnSaleWhereUniqueInput'
    distinct: List['ReturnSaleScalarFieldKeys']
    include: 'ReturnSaleIncludeFromReturnSale'


class ReturnItemIncludeFromRevokedToken(TypedDict, total=False):
    """Relational arguments for RevokedToken"""
    returnSale: Union[bool, 'ReturnSaleArgsFromRevokedToken']
    saleItem: Union[bool, 'SaleItemArgsFromRevokedToken']


class ReturnItemArgsFromRevokedToken(TypedDict, total=False):
    """Arguments for RevokedToken"""
    include: 'ReturnItemIncludeFromReturnItem'


class FindManyReturnItemArgsFromRevokedToken(TypedDict, total=False):
    """Arguments for RevokedToken"""
    take: int
    skip: int
    order_by: Union['ReturnItemOrderByInput', List['ReturnItemOrderByInput']]
    where: 'ReturnItemWhereInput'
    cursor: 'ReturnItemWhereUniqueInput'
    distinct: List['ReturnItemScalarFieldKeys']
    include: 'ReturnItemIncludeFromReturnItem'


class PaymentIncludeFromRevokedToken(TypedDict, total=False):
    """Relational arguments for RevokedToken"""
    sale: Union[bool, 'SaleArgsFromRevokedToken']
    account: Union[bool, 'AccountArgsFromRevokedToken']
    returnSale: Union[bool, 'ReturnSaleArgsFromRevokedToken']
    user: Union[bool, 'UserArgsFromRevokedToken']


class PaymentArgsFromRevokedToken(TypedDict, total=False):
    """Arguments for RevokedToken"""
    include: 'PaymentIncludeFromPayment'


class FindManyPaymentArgsFromRevokedToken(TypedDict, total=False):
    """Arguments for RevokedToken"""
    take: int
    skip: int
    order_by: Union['PaymentOrderByInput', List['PaymentOrderByInput']]
    where: 'PaymentWhereInput'
    cursor: 'PaymentWhereUniqueInput'
    distinct: List['PaymentScalarFieldKeys']
    include: 'PaymentIncludeFromPayment'


class JournalEntryIncludeFromRevokedToken(TypedDict, total=False):
    """Relational arguments for RevokedToken"""
    lines: Union[bool, 'FindManyJournalEntryLineArgsFromRevokedToken']


class JournalEntryArgsFromRevokedToken(TypedDict, total=False):
    """Arguments for RevokedToken"""
    include: 'JournalEntryIncludeFromJournalEntry'


class FindManyJournalEntryArgsFromRevokedToken(TypedDict, total=False):
    """Arguments for RevokedToken"""
    take: int
    skip: int
    order_by: Union['JournalEntryOrderByInput', List['JournalEntryOrderByInput']]
    where: 'JournalEntryWhereInput'
    cursor: 'JournalEntryWhereUniqueInput'
    distinct: List['JournalEntryScalarFieldKeys']
    include: 'JournalEntryIncludeFromJournalEntry'


class JournalEntryLineIncludeFromRevokedToken(TypedDict, total=False):
    """Relational arguments for RevokedToken"""
    entry: Union[bool, 'JournalEntryArgsFromRevokedToken']
    account: Union[bool, 'AccountArgsFromRevokedToken']


class JournalEntryLineArgsFromRevokedToken(TypedDict, total=False):
    """Arguments for RevokedToken"""
    include: 'JournalEntryLineIncludeFromJournalEntryLine'


class FindManyJournalEntryLineArgsFromRevokedToken(TypedDict, total=False):
    """Arguments for RevokedToken"""
    take: int
    skip: int
    order_by: Union['JournalEntryLineOrderByInput', List['JournalEntryLineOrderByInput']]
    where: 'JournalEntryLineWhereInput'
    cursor: 'JournalEntryLineWhereUniqueInput'
    distinct: List['JournalEntryLineScalarFieldKeys']
    include: 'JournalEntryLineIncludeFromJournalEntryLine'


class AccountIncludeFromRevokedToken(TypedDict, total=False):
    """Relational arguments for RevokedToken"""
    branch: Union[bool, 'BranchArgsFromRevokedToken']
    entries: Union[bool, 'FindManyJournalEntryLineArgsFromRevokedToken']
    payments: Union[bool, 'FindManyPaymentArgsFromRevokedToken']
    outgoingTransfers: Union[bool, 'FindManyAccountTransferArgsFromRevokedToken']
    incomingTransfers: Union[bool, 'FindManyAccountTransferArgsFromRevokedToken']


class AccountArgsFromRevokedToken(TypedDict, total=False):
    """Arguments for RevokedToken"""
    include: 'AccountIncludeFromAccount'


class FindManyAccountArgsFromRevokedToken(TypedDict, total=False):
    """Arguments for RevokedToken"""
    take: int
    skip: int
    order_by: Union['AccountOrderByInput', List['AccountOrderByInput']]
    where: 'AccountWhereInput'
    cursor: 'AccountWhereUniqueInput'
    distinct: List['AccountScalarFieldKeys']
    include: 'AccountIncludeFromAccount'


class AccountTransferIncludeFromRevokedToken(TypedDict, total=False):
    """Relational arguments for RevokedToken"""
    fromAccount: Union[bool, 'AccountArgsFromRevokedToken']
    toAccount: Union[bool, 'AccountArgsFromRevokedToken']


class AccountTransferArgsFromRevokedToken(TypedDict, total=False):
    """Arguments for RevokedToken"""
    include: 'AccountTransferIncludeFromAccountTransfer'


class FindManyAccountTransferArgsFromRevokedToken(TypedDict, total=False):
    """Arguments for RevokedToken"""
    take: int
    skip: int
    order_by: Union['AccountTransferOrderByInput', List['AccountTransferOrderByInput']]
    where: 'AccountTransferWhereInput'
    cursor: 'AccountTransferWhereUniqueInput'
    distinct: List['AccountTransferScalarFieldKeys']
    include: 'AccountTransferIncludeFromAccountTransfer'


class BranchOrderIncludeFromRevokedToken(TypedDict, total=False):
    """Relational arguments for RevokedToken"""
    branch: Union[bool, 'BranchArgsFromRevokedToken']
    requestedBy: Union[bool, 'UserArgsFromRevokedToken']
    approvedBy: Union[bool, 'UserArgsFromRevokedToken']
    sentBy: Union[bool, 'UserArgsFromRevokedToken']
    receivedBy: Union[bool, 'UserArgsFromRevokedToken']
    items: Union[bool, 'FindManyBranchOrderItemArgsFromRevokedToken']


class BranchOrderArgsFromRevokedToken(TypedDict, total=False):
    """Arguments for RevokedToken"""
    include: 'BranchOrderIncludeFromBranchOrder'


class FindManyBranchOrderArgsFromRevokedToken(TypedDict, total=False):
    """Arguments for RevokedToken"""
    take: int
    skip: int
    order_by: Union['BranchOrderOrderByInput', List['BranchOrderOrderByInput']]
    where: 'BranchOrderWhereInput'
    cursor: 'BranchOrderWhereUniqueInput'
    distinct: List['BranchOrderScalarFieldKeys']
    include: 'BranchOrderIncludeFromBranchOrder'


class BranchOrderItemIncludeFromRevokedToken(TypedDict, total=False):
    """Relational arguments for RevokedToken"""
    branchOrder: Union[bool, 'BranchOrderArgsFromRevokedToken']
    stock: Union[bool, 'StockArgsFromRevokedToken']


class BranchOrderItemArgsFromRevokedToken(TypedDict, total=False):
    """Arguments for RevokedToken"""
    include: 'BranchOrderItemIncludeFromBranchOrderItem'


class FindManyBranchOrderItemArgsFromRevokedToken(TypedDict, total=False):
    """Arguments for RevokedToken"""
    take: int
    skip: int
    order_by: Union['BranchOrderItemOrderByInput', List['BranchOrderItemOrderByInput']]
    where: 'BranchOrderItemWhereInput'
    cursor: 'BranchOrderItemWhereUniqueInput'
    distinct: List['BranchOrderItemScalarFieldKeys']
    include: 'BranchOrderItemIncludeFromBranchOrderItem'


class AuditLogIncludeFromRevokedToken(TypedDict, total=False):
    """Relational arguments for RevokedToken"""
    user: Union[bool, 'UserArgsFromRevokedToken']


class AuditLogArgsFromRevokedToken(TypedDict, total=False):
    """Arguments for RevokedToken"""
    include: 'AuditLogIncludeFromAuditLog'


class FindManyAuditLogArgsFromRevokedToken(TypedDict, total=False):
    """Arguments for RevokedToken"""
    take: int
    skip: int
    order_by: Union['AuditLogOrderByInput', List['AuditLogOrderByInput']]
    where: 'AuditLogWhereInput'
    cursor: 'AuditLogWhereUniqueInput'
    distinct: List['AuditLogScalarFieldKeys']
    include: 'AuditLogIncludeFromAuditLog'


class SystemInfoIncludeFromRevokedToken(TypedDict, total=False):
    """Relational arguments for RevokedToken"""


class SystemInfoArgsFromRevokedToken(TypedDict, total=False):
    """Arguments for RevokedToken"""
    include: 'SystemInfoIncludeFromSystemInfo'


class FindManySystemInfoArgsFromRevokedToken(TypedDict, total=False):
    """Arguments for RevokedToken"""
    take: int
    skip: int
    order_by: Union['SystemInfoOrderByInput', List['SystemInfoOrderByInput']]
    where: 'SystemInfoWhereInput'
    cursor: 'SystemInfoWhereUniqueInput'
    distinct: List['SystemInfoScalarFieldKeys']
    include: 'SystemInfoIncludeFromSystemInfo'


class BackupIncludeFromRevokedToken(TypedDict, total=False):
    """Relational arguments for RevokedToken"""
    createdBy: Union[bool, 'UserArgsFromRevokedToken']


class BackupArgsFromRevokedToken(TypedDict, total=False):
    """Arguments for RevokedToken"""
    include: 'BackupIncludeFromBackup'


class FindManyBackupArgsFromRevokedToken(TypedDict, total=False):
    """Arguments for RevokedToken"""
    take: int
    skip: int
    order_by: Union['BackupOrderByInput', List['BackupOrderByInput']]
    where: 'BackupWhereInput'
    cursor: 'BackupWhereUniqueInput'
    distinct: List['BackupScalarFieldKeys']
    include: 'BackupIncludeFromBackup'


class RevokedTokenIncludeFromRevokedToken(TypedDict, total=False):
    """Relational arguments for RevokedToken"""
    user: Union[bool, 'UserArgsFromRevokedToken']


class RevokedTokenArgsFromRevokedToken(TypedDict, total=False):
    """Arguments for RevokedToken"""
    include: 'RevokedTokenIncludeFromRevokedToken'


class FindManyRevokedTokenArgsFromRevokedToken(TypedDict, total=False):
    """Arguments for RevokedToken"""
    take: int
    skip: int
    order_by: Union['RevokedTokenOrderByInput', List['RevokedTokenOrderByInput']]
    where: 'RevokedTokenWhereInput'
    cursor: 'RevokedTokenWhereUniqueInput'
    distinct: List['RevokedTokenScalarFieldKeys']
    include: 'RevokedTokenIncludeFromRevokedToken'


class SystemSettingIncludeFromRevokedToken(TypedDict, total=False):
    """Relational arguments for RevokedToken"""


class SystemSettingArgsFromRevokedToken(TypedDict, total=False):
    """Arguments for RevokedToken"""
    include: 'SystemSettingIncludeFromSystemSetting'


class FindManySystemSettingArgsFromRevokedToken(TypedDict, total=False):
    """Arguments for RevokedToken"""
    take: int
    skip: int
    order_by: Union['SystemSettingOrderByInput', List['SystemSettingOrderByInput']]
    where: 'SystemSettingWhereInput'
    cursor: 'SystemSettingWhereUniqueInput'
    distinct: List['SystemSettingScalarFieldKeys']
    include: 'SystemSettingIncludeFromSystemSetting'


class NotificationIncludeFromRevokedToken(TypedDict, total=False):
    """Relational arguments for RevokedToken"""
    user: Union[bool, 'UserArgsFromRevokedToken']


class NotificationArgsFromRevokedToken(TypedDict, total=False):
    """Arguments for RevokedToken"""
    include: 'NotificationIncludeFromNotification'


class FindManyNotificationArgsFromRevokedToken(TypedDict, total=False):
    """Arguments for RevokedToken"""
    take: int
    skip: int
    order_by: Union['NotificationOrderByInput', List['NotificationOrderByInput']]
    where: 'NotificationWhereInput'
    cursor: 'NotificationWhereUniqueInput'
    distinct: List['NotificationScalarFieldKeys']
    include: 'NotificationIncludeFromNotification'


class StockAdjustmentIncludeFromRevokedToken(TypedDict, total=False):
    """Relational arguments for RevokedToken"""
    product: Union[bool, 'ProductArgsFromRevokedToken']
    createdBy: Union[bool, 'UserArgsFromRevokedToken']


class StockAdjustmentArgsFromRevokedToken(TypedDict, total=False):
    """Arguments for RevokedToken"""
    include: 'StockAdjustmentIncludeFromStockAdjustment'


class FindManyStockAdjustmentArgsFromRevokedToken(TypedDict, total=False):
    """Arguments for RevokedToken"""
    take: int
    skip: int
    order_by: Union['StockAdjustmentOrderByInput', List['StockAdjustmentOrderByInput']]
    where: 'StockAdjustmentWhereInput'
    cursor: 'StockAdjustmentWhereUniqueInput'
    distinct: List['StockAdjustmentScalarFieldKeys']
    include: 'StockAdjustmentIncludeFromStockAdjustment'




FindManyRevokedTokenArgs = FindManyRevokedTokenArgsFromRevokedToken
FindFirstRevokedTokenArgs = FindManyRevokedTokenArgsFromRevokedToken


class RevokedTokenWhereInput(TypedDict, total=False):
    """RevokedToken arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    jti: Union[_str, 'types.StringFilter']
    token: Union[_str, 'types.StringFilter']
    reason: Union[None, _str, 'types.StringFilter']
    expiresAt: Union[datetime.datetime, 'types.DateTimeFilter']
    revokedBy: Union[None, _int, 'types.IntFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    user: 'UserRelationFilter'

    # should be noted that AND and NOT should be Union['RevokedTokenWhereInput', List['RevokedTokenWhereInput']]
    # but this causes mypy to hang :/
    AND: List['RevokedTokenWhereInput']
    OR: List['RevokedTokenWhereInput']
    NOT: List['RevokedTokenWhereInput']



# aggregate RevokedToken types


class RevokedTokenScalarWhereWithAggregatesInput(TypedDict, total=False):
    """RevokedToken arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    jti: Union[_str, 'types.StringWithAggregatesFilter']
    token: Union[_str, 'types.StringWithAggregatesFilter']
    reason: Union[_str, 'types.StringWithAggregatesFilter']
    expiresAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    revokedBy: Union[_int, 'types.IntWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['RevokedTokenScalarWhereWithAggregatesInput']
    OR: List['RevokedTokenScalarWhereWithAggregatesInput']
    NOT: List['RevokedTokenScalarWhereWithAggregatesInput']



class RevokedTokenGroupByOutput(TypedDict, total=False):
    id: _int
    jti: _str
    token: _str
    reason: _str
    expiresAt: datetime.datetime
    revokedBy: _int
    createdAt: datetime.datetime
    _sum: 'RevokedTokenSumAggregateOutput'
    _avg: 'RevokedTokenAvgAggregateOutput'
    _min: 'RevokedTokenMinAggregateOutput'
    _max: 'RevokedTokenMaxAggregateOutput'
    _count: 'RevokedTokenCountAggregateOutput'


class RevokedTokenAvgAggregateOutput(TypedDict, total=False):
    """RevokedToken output for aggregating averages"""
    id: float
    revokedBy: float


class RevokedTokenSumAggregateOutput(TypedDict, total=False):
    """RevokedToken output for aggregating sums"""
    id: _int
    revokedBy: _int


class RevokedTokenScalarAggregateOutput(TypedDict, total=False):
    """RevokedToken output including scalar fields"""
    id: _int
    jti: _str
    token: _str
    reason: _str
    expiresAt: datetime.datetime
    revokedBy: _int
    createdAt: datetime.datetime


RevokedTokenMinAggregateOutput = RevokedTokenScalarAggregateOutput
RevokedTokenMaxAggregateOutput = RevokedTokenScalarAggregateOutput


class RevokedTokenMaxAggregateInput(TypedDict, total=False):
    """RevokedToken input for aggregating by max"""
    id: bool
    jti: bool
    token: bool
    reason: bool
    expiresAt: bool
    revokedBy: bool
    createdAt: bool


class RevokedTokenMinAggregateInput(TypedDict, total=False):
    """RevokedToken input for aggregating by min"""
    id: bool
    jti: bool
    token: bool
    reason: bool
    expiresAt: bool
    revokedBy: bool
    createdAt: bool


class RevokedTokenNumberAggregateInput(TypedDict, total=False):
    """RevokedToken input for aggregating numbers"""
    id: bool
    revokedBy: bool


RevokedTokenAvgAggregateInput = RevokedTokenNumberAggregateInput
RevokedTokenSumAggregateInput = RevokedTokenNumberAggregateInput


RevokedTokenCountAggregateInput = TypedDict(
    'RevokedTokenCountAggregateInput',
    {
        'id': bool,
        'jti': bool,
        'token': bool,
        'reason': bool,
        'expiresAt': bool,
        'revokedBy': bool,
        'createdAt': bool,
        '_all': bool,
    },
    total=False,
)

RevokedTokenCountAggregateOutput = TypedDict(
    'RevokedTokenCountAggregateOutput',
    {
        'id': int,
        'jti': int,
        'token': int,
        'reason': int,
        'expiresAt': int,
        'revokedBy': int,
        'createdAt': int,
        '_all': int,
    },
    total=False,
)


RevokedTokenKeys = Literal[
    'id',
    'jti',
    'token',
    'reason',
    'expiresAt',
    'revokedBy',
    'createdAt',
    'user',
]
RevokedTokenScalarFieldKeys = Literal[
    'id',
    'jti',
    'token',
    'reason',
    'expiresAt',
    'revokedBy',
    'createdAt',
]
RevokedTokenScalarFieldKeysT = TypeVar('RevokedTokenScalarFieldKeysT', bound=RevokedTokenScalarFieldKeys)

RevokedTokenRelationalFieldKeys = Literal[
        'user',
    ]

# SystemSetting types

class SystemSettingOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the SystemSetting create method"""
    id: _int
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class SystemSettingCreateInput(SystemSettingOptionalCreateInput):
    """Required arguments to the SystemSetting create method"""
    key: _str
    value: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class SystemSettingOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the SystemSetting create method, without relations"""
    id: _int
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class SystemSettingCreateWithoutRelationsInput(SystemSettingOptionalCreateWithoutRelationsInput):
    """Required arguments to the SystemSetting create method, without relations"""
    key: _str
    value: _str


class SystemSettingCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'SystemSettingCreateWithoutRelationsInput'
    connect: 'SystemSettingWhereUniqueInput'


class SystemSettingCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['SystemSettingCreateWithoutRelationsInput', List['SystemSettingCreateWithoutRelationsInput']]
    connect: Union['SystemSettingWhereUniqueInput', List['SystemSettingWhereUniqueInput']]


_SystemSettingWhereUnique_id_Input = TypedDict(
    '_SystemSettingWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

_SystemSettingWhereUnique_key_Input = TypedDict(
    '_SystemSettingWhereUnique_key_Input',
    {
        'key': '_str',
    },
    total=True
)

SystemSettingWhereUniqueInput = Union[
    '_SystemSettingWhereUnique_id_Input',
    '_SystemSettingWhereUnique_key_Input',
]


class SystemSettingUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    key: _str
    value: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class SystemSettingUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    key: _str
    value: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class SystemSettingUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['SystemSettingCreateWithoutRelationsInput']
    connect: List['SystemSettingWhereUniqueInput']
    set: List['SystemSettingWhereUniqueInput']
    disconnect: List['SystemSettingWhereUniqueInput']
    delete: List['SystemSettingWhereUniqueInput']

    # TODO
    # update: List['SystemSettingUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['SystemSettingUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['SystemSettingScalarWhereInput']
    # upsert: List['SystemSettingUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['SystemSettingCreateOrConnectWithoutRelationsInput']


class SystemSettingUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'SystemSettingCreateWithoutRelationsInput'
    connect: 'SystemSettingWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'SystemSettingUpdateInput'
    # upsert: 'SystemSettingUpsertWithoutRelationsInput'
    # connectOrCreate: 'SystemSettingCreateOrConnectWithoutRelationsInput'


class SystemSettingUpsertInput(TypedDict):
    create: 'SystemSettingCreateInput'
    update: 'SystemSettingUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_SystemSetting_id_OrderByInput = TypedDict(
    '_SystemSetting_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_SystemSetting_key_OrderByInput = TypedDict(
    '_SystemSetting_key_OrderByInput',
    {
        'key': 'SortOrder',
    },
    total=True
)

_SystemSetting_value_OrderByInput = TypedDict(
    '_SystemSetting_value_OrderByInput',
    {
        'value': 'SortOrder',
    },
    total=True
)

_SystemSetting_createdAt_OrderByInput = TypedDict(
    '_SystemSetting_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_SystemSetting_updatedAt_OrderByInput = TypedDict(
    '_SystemSetting_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

SystemSettingOrderByInput = Union[
    '_SystemSetting_id_OrderByInput',
    '_SystemSetting_key_OrderByInput',
    '_SystemSetting_value_OrderByInput',
    '_SystemSetting_createdAt_OrderByInput',
    '_SystemSetting_updatedAt_OrderByInput',
]



# recursive SystemSetting types
# TODO: cleanup these types



SystemSettingRelationFilter = TypedDict(
    'SystemSettingRelationFilter',
    {
        'is': 'SystemSettingWhereInput',
        'is_not': 'SystemSettingWhereInput',
    },
    total=False,
)


class SystemSettingListRelationFilter(TypedDict, total=False):
    some: 'SystemSettingWhereInput'
    none: 'SystemSettingWhereInput'
    every: 'SystemSettingWhereInput'


class SystemSettingInclude(TypedDict, total=False):
    """SystemSetting relational arguments"""


class UserIncludeFromSystemSetting(TypedDict, total=False):
    """Relational arguments for SystemSetting"""
    branch: Union[bool, 'BranchArgsFromSystemSetting']
    auditLogs: Union[bool, 'FindManyAuditLogArgsFromSystemSetting']
    permissions: Union[bool, 'FindManyUserPermissionArgsFromSystemSetting']
    notifications: Union[bool, 'FindManyNotificationArgsFromSystemSetting']
    revokedTokens: Union[bool, 'FindManyRevokedTokenArgsFromSystemSetting']
    stockAdjustments: Union[bool, 'FindManyStockAdjustmentArgsFromSystemSetting']
    Sale: Union[bool, 'FindManySaleArgsFromSystemSetting']
    deletedSales: Union[bool, 'FindManySaleArgsFromSystemSetting']
    Payment: Union[bool, 'FindManyPaymentArgsFromSystemSetting']
    Backup: Union[bool, 'FindManyBackupArgsFromSystemSetting']
    requestedOrders: Union[bool, 'FindManyBranchOrderArgsFromSystemSetting']
    approvedOrders: Union[bool, 'FindManyBranchOrderArgsFromSystemSetting']
    sentOrders: Union[bool, 'FindManyBranchOrderArgsFromSystemSetting']
    receivedOrders: Union[bool, 'FindManyBranchOrderArgsFromSystemSetting']


class UserArgsFromSystemSetting(TypedDict, total=False):
    """Arguments for SystemSetting"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromSystemSetting(TypedDict, total=False):
    """Arguments for SystemSetting"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class UserPermissionIncludeFromSystemSetting(TypedDict, total=False):
    """Relational arguments for SystemSetting"""
    user: Union[bool, 'UserArgsFromSystemSetting']


class UserPermissionArgsFromSystemSetting(TypedDict, total=False):
    """Arguments for SystemSetting"""
    include: 'UserPermissionIncludeFromUserPermission'


class FindManyUserPermissionArgsFromSystemSetting(TypedDict, total=False):
    """Arguments for SystemSetting"""
    take: int
    skip: int
    order_by: Union['UserPermissionOrderByInput', List['UserPermissionOrderByInput']]
    where: 'UserPermissionWhereInput'
    cursor: 'UserPermissionWhereUniqueInput'
    distinct: List['UserPermissionScalarFieldKeys']
    include: 'UserPermissionIncludeFromUserPermission'


class BranchIncludeFromSystemSetting(TypedDict, total=False):
    """Relational arguments for SystemSetting"""
    users: Union[bool, 'FindManyUserArgsFromSystemSetting']
    Sale: Union[bool, 'FindManySaleArgsFromSystemSetting']
    Account: Union[bool, 'FindManyAccountArgsFromSystemSetting']
    BranchOrder: Union[bool, 'FindManyBranchOrderArgsFromSystemSetting']


class BranchArgsFromSystemSetting(TypedDict, total=False):
    """Arguments for SystemSetting"""
    include: 'BranchIncludeFromBranch'


class FindManyBranchArgsFromSystemSetting(TypedDict, total=False):
    """Arguments for SystemSetting"""
    take: int
    skip: int
    order_by: Union['BranchOrderByInput', List['BranchOrderByInput']]
    where: 'BranchWhereInput'
    cursor: 'BranchWhereUniqueInput'
    distinct: List['BranchScalarFieldKeys']
    include: 'BranchIncludeFromBranch'


class ProductIncludeFromSystemSetting(TypedDict, total=False):
    """Relational arguments for SystemSetting"""
    category: Union[bool, 'CategoryArgsFromSystemSetting']
    stocks: Union[bool, 'FindManyStockArgsFromSystemSetting']
    stockAdjustments: Union[bool, 'FindManyStockAdjustmentArgsFromSystemSetting']


class ProductArgsFromSystemSetting(TypedDict, total=False):
    """Arguments for SystemSetting"""
    include: 'ProductIncludeFromProduct'


class FindManyProductArgsFromSystemSetting(TypedDict, total=False):
    """Arguments for SystemSetting"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProduct'


class CategoryIncludeFromSystemSetting(TypedDict, total=False):
    """Relational arguments for SystemSetting"""
    products: Union[bool, 'FindManyProductArgsFromSystemSetting']


class CategoryArgsFromSystemSetting(TypedDict, total=False):
    """Arguments for SystemSetting"""
    include: 'CategoryIncludeFromCategory'


class FindManyCategoryArgsFromSystemSetting(TypedDict, total=False):
    """Arguments for SystemSetting"""
    take: int
    skip: int
    order_by: Union['CategoryOrderByInput', List['CategoryOrderByInput']]
    where: 'CategoryWhereInput'
    cursor: 'CategoryWhereUniqueInput'
    distinct: List['CategoryScalarFieldKeys']
    include: 'CategoryIncludeFromCategory'


class StockIncludeFromSystemSetting(TypedDict, total=False):
    """Relational arguments for SystemSetting"""
    product: Union[bool, 'ProductArgsFromSystemSetting']
    SaleItem: Union[bool, 'FindManySaleItemArgsFromSystemSetting']
    BranchOrderItem: Union[bool, 'FindManyBranchOrderItemArgsFromSystemSetting']


class StockArgsFromSystemSetting(TypedDict, total=False):
    """Arguments for SystemSetting"""
    include: 'StockIncludeFromStock'


class FindManyStockArgsFromSystemSetting(TypedDict, total=False):
    """Arguments for SystemSetting"""
    take: int
    skip: int
    order_by: Union['StockOrderByInput', List['StockOrderByInput']]
    where: 'StockWhereInput'
    cursor: 'StockWhereUniqueInput'
    distinct: List['StockScalarFieldKeys']
    include: 'StockIncludeFromStock'


class CustomerIncludeFromSystemSetting(TypedDict, total=False):
    """Relational arguments for SystemSetting"""
    Sale: Union[bool, 'FindManySaleArgsFromSystemSetting']


class CustomerArgsFromSystemSetting(TypedDict, total=False):
    """Arguments for SystemSetting"""
    include: 'CustomerIncludeFromCustomer'


class FindManyCustomerArgsFromSystemSetting(TypedDict, total=False):
    """Arguments for SystemSetting"""
    take: int
    skip: int
    order_by: Union['CustomerOrderByInput', List['CustomerOrderByInput']]
    where: 'CustomerWhereInput'
    cursor: 'CustomerWhereUniqueInput'
    distinct: List['CustomerScalarFieldKeys']
    include: 'CustomerIncludeFromCustomer'


class SaleIncludeFromSystemSetting(TypedDict, total=False):
    """Relational arguments for SystemSetting"""
    branch: Union[bool, 'BranchArgsFromSystemSetting']
    customer: Union[bool, 'CustomerArgsFromSystemSetting']
    user: Union[bool, 'UserArgsFromSystemSetting']
    items: Union[bool, 'FindManySaleItemArgsFromSystemSetting']
    payments: Union[bool, 'FindManyPaymentArgsFromSystemSetting']
    returns: Union[bool, 'FindManyReturnSaleArgsFromSystemSetting']
    deletedBy: Union[bool, 'UserArgsFromSystemSetting']


class SaleArgsFromSystemSetting(TypedDict, total=False):
    """Arguments for SystemSetting"""
    include: 'SaleIncludeFromSale'


class FindManySaleArgsFromSystemSetting(TypedDict, total=False):
    """Arguments for SystemSetting"""
    take: int
    skip: int
    order_by: Union['SaleOrderByInput', List['SaleOrderByInput']]
    where: 'SaleWhereInput'
    cursor: 'SaleWhereUniqueInput'
    distinct: List['SaleScalarFieldKeys']
    include: 'SaleIncludeFromSale'


class SaleItemIncludeFromSystemSetting(TypedDict, total=False):
    """Relational arguments for SystemSetting"""
    sale: Union[bool, 'SaleArgsFromSystemSetting']
    stock: Union[bool, 'StockArgsFromSystemSetting']
    ReturnItem: Union[bool, 'FindManyReturnItemArgsFromSystemSetting']


class SaleItemArgsFromSystemSetting(TypedDict, total=False):
    """Arguments for SystemSetting"""
    include: 'SaleItemIncludeFromSaleItem'


class FindManySaleItemArgsFromSystemSetting(TypedDict, total=False):
    """Arguments for SystemSetting"""
    take: int
    skip: int
    order_by: Union['SaleItemOrderByInput', List['SaleItemOrderByInput']]
    where: 'SaleItemWhereInput'
    cursor: 'SaleItemWhereUniqueInput'
    distinct: List['SaleItemScalarFieldKeys']
    include: 'SaleItemIncludeFromSaleItem'


class ReturnSaleIncludeFromSystemSetting(TypedDict, total=False):
    """Relational arguments for SystemSetting"""
    original: Union[bool, 'SaleArgsFromSystemSetting']
    items: Union[bool, 'FindManyReturnItemArgsFromSystemSetting']
    refund: Union[bool, 'FindManyPaymentArgsFromSystemSetting']


class ReturnSaleArgsFromSystemSetting(TypedDict, total=False):
    """Arguments for SystemSetting"""
    include: 'ReturnSaleIncludeFromReturnSale'


class FindManyReturnSaleArgsFromSystemSetting(TypedDict, total=False):
    """Arguments for SystemSetting"""
    take: int
    skip: int
    order_by: Union['ReturnSaleOrderByInput', List['ReturnSaleOrderByInput']]
    where: 'ReturnSaleWhereInput'
    cursor: 'ReturnSaleWhereUniqueInput'
    distinct: List['ReturnSaleScalarFieldKeys']
    include: 'ReturnSaleIncludeFromReturnSale'


class ReturnItemIncludeFromSystemSetting(TypedDict, total=False):
    """Relational arguments for SystemSetting"""
    returnSale: Union[bool, 'ReturnSaleArgsFromSystemSetting']
    saleItem: Union[bool, 'SaleItemArgsFromSystemSetting']


class ReturnItemArgsFromSystemSetting(TypedDict, total=False):
    """Arguments for SystemSetting"""
    include: 'ReturnItemIncludeFromReturnItem'


class FindManyReturnItemArgsFromSystemSetting(TypedDict, total=False):
    """Arguments for SystemSetting"""
    take: int
    skip: int
    order_by: Union['ReturnItemOrderByInput', List['ReturnItemOrderByInput']]
    where: 'ReturnItemWhereInput'
    cursor: 'ReturnItemWhereUniqueInput'
    distinct: List['ReturnItemScalarFieldKeys']
    include: 'ReturnItemIncludeFromReturnItem'


class PaymentIncludeFromSystemSetting(TypedDict, total=False):
    """Relational arguments for SystemSetting"""
    sale: Union[bool, 'SaleArgsFromSystemSetting']
    account: Union[bool, 'AccountArgsFromSystemSetting']
    returnSale: Union[bool, 'ReturnSaleArgsFromSystemSetting']
    user: Union[bool, 'UserArgsFromSystemSetting']


class PaymentArgsFromSystemSetting(TypedDict, total=False):
    """Arguments for SystemSetting"""
    include: 'PaymentIncludeFromPayment'


class FindManyPaymentArgsFromSystemSetting(TypedDict, total=False):
    """Arguments for SystemSetting"""
    take: int
    skip: int
    order_by: Union['PaymentOrderByInput', List['PaymentOrderByInput']]
    where: 'PaymentWhereInput'
    cursor: 'PaymentWhereUniqueInput'
    distinct: List['PaymentScalarFieldKeys']
    include: 'PaymentIncludeFromPayment'


class JournalEntryIncludeFromSystemSetting(TypedDict, total=False):
    """Relational arguments for SystemSetting"""
    lines: Union[bool, 'FindManyJournalEntryLineArgsFromSystemSetting']


class JournalEntryArgsFromSystemSetting(TypedDict, total=False):
    """Arguments for SystemSetting"""
    include: 'JournalEntryIncludeFromJournalEntry'


class FindManyJournalEntryArgsFromSystemSetting(TypedDict, total=False):
    """Arguments for SystemSetting"""
    take: int
    skip: int
    order_by: Union['JournalEntryOrderByInput', List['JournalEntryOrderByInput']]
    where: 'JournalEntryWhereInput'
    cursor: 'JournalEntryWhereUniqueInput'
    distinct: List['JournalEntryScalarFieldKeys']
    include: 'JournalEntryIncludeFromJournalEntry'


class JournalEntryLineIncludeFromSystemSetting(TypedDict, total=False):
    """Relational arguments for SystemSetting"""
    entry: Union[bool, 'JournalEntryArgsFromSystemSetting']
    account: Union[bool, 'AccountArgsFromSystemSetting']


class JournalEntryLineArgsFromSystemSetting(TypedDict, total=False):
    """Arguments for SystemSetting"""
    include: 'JournalEntryLineIncludeFromJournalEntryLine'


class FindManyJournalEntryLineArgsFromSystemSetting(TypedDict, total=False):
    """Arguments for SystemSetting"""
    take: int
    skip: int
    order_by: Union['JournalEntryLineOrderByInput', List['JournalEntryLineOrderByInput']]
    where: 'JournalEntryLineWhereInput'
    cursor: 'JournalEntryLineWhereUniqueInput'
    distinct: List['JournalEntryLineScalarFieldKeys']
    include: 'JournalEntryLineIncludeFromJournalEntryLine'


class AccountIncludeFromSystemSetting(TypedDict, total=False):
    """Relational arguments for SystemSetting"""
    branch: Union[bool, 'BranchArgsFromSystemSetting']
    entries: Union[bool, 'FindManyJournalEntryLineArgsFromSystemSetting']
    payments: Union[bool, 'FindManyPaymentArgsFromSystemSetting']
    outgoingTransfers: Union[bool, 'FindManyAccountTransferArgsFromSystemSetting']
    incomingTransfers: Union[bool, 'FindManyAccountTransferArgsFromSystemSetting']


class AccountArgsFromSystemSetting(TypedDict, total=False):
    """Arguments for SystemSetting"""
    include: 'AccountIncludeFromAccount'


class FindManyAccountArgsFromSystemSetting(TypedDict, total=False):
    """Arguments for SystemSetting"""
    take: int
    skip: int
    order_by: Union['AccountOrderByInput', List['AccountOrderByInput']]
    where: 'AccountWhereInput'
    cursor: 'AccountWhereUniqueInput'
    distinct: List['AccountScalarFieldKeys']
    include: 'AccountIncludeFromAccount'


class AccountTransferIncludeFromSystemSetting(TypedDict, total=False):
    """Relational arguments for SystemSetting"""
    fromAccount: Union[bool, 'AccountArgsFromSystemSetting']
    toAccount: Union[bool, 'AccountArgsFromSystemSetting']


class AccountTransferArgsFromSystemSetting(TypedDict, total=False):
    """Arguments for SystemSetting"""
    include: 'AccountTransferIncludeFromAccountTransfer'


class FindManyAccountTransferArgsFromSystemSetting(TypedDict, total=False):
    """Arguments for SystemSetting"""
    take: int
    skip: int
    order_by: Union['AccountTransferOrderByInput', List['AccountTransferOrderByInput']]
    where: 'AccountTransferWhereInput'
    cursor: 'AccountTransferWhereUniqueInput'
    distinct: List['AccountTransferScalarFieldKeys']
    include: 'AccountTransferIncludeFromAccountTransfer'


class BranchOrderIncludeFromSystemSetting(TypedDict, total=False):
    """Relational arguments for SystemSetting"""
    branch: Union[bool, 'BranchArgsFromSystemSetting']
    requestedBy: Union[bool, 'UserArgsFromSystemSetting']
    approvedBy: Union[bool, 'UserArgsFromSystemSetting']
    sentBy: Union[bool, 'UserArgsFromSystemSetting']
    receivedBy: Union[bool, 'UserArgsFromSystemSetting']
    items: Union[bool, 'FindManyBranchOrderItemArgsFromSystemSetting']


class BranchOrderArgsFromSystemSetting(TypedDict, total=False):
    """Arguments for SystemSetting"""
    include: 'BranchOrderIncludeFromBranchOrder'


class FindManyBranchOrderArgsFromSystemSetting(TypedDict, total=False):
    """Arguments for SystemSetting"""
    take: int
    skip: int
    order_by: Union['BranchOrderOrderByInput', List['BranchOrderOrderByInput']]
    where: 'BranchOrderWhereInput'
    cursor: 'BranchOrderWhereUniqueInput'
    distinct: List['BranchOrderScalarFieldKeys']
    include: 'BranchOrderIncludeFromBranchOrder'


class BranchOrderItemIncludeFromSystemSetting(TypedDict, total=False):
    """Relational arguments for SystemSetting"""
    branchOrder: Union[bool, 'BranchOrderArgsFromSystemSetting']
    stock: Union[bool, 'StockArgsFromSystemSetting']


class BranchOrderItemArgsFromSystemSetting(TypedDict, total=False):
    """Arguments for SystemSetting"""
    include: 'BranchOrderItemIncludeFromBranchOrderItem'


class FindManyBranchOrderItemArgsFromSystemSetting(TypedDict, total=False):
    """Arguments for SystemSetting"""
    take: int
    skip: int
    order_by: Union['BranchOrderItemOrderByInput', List['BranchOrderItemOrderByInput']]
    where: 'BranchOrderItemWhereInput'
    cursor: 'BranchOrderItemWhereUniqueInput'
    distinct: List['BranchOrderItemScalarFieldKeys']
    include: 'BranchOrderItemIncludeFromBranchOrderItem'


class AuditLogIncludeFromSystemSetting(TypedDict, total=False):
    """Relational arguments for SystemSetting"""
    user: Union[bool, 'UserArgsFromSystemSetting']


class AuditLogArgsFromSystemSetting(TypedDict, total=False):
    """Arguments for SystemSetting"""
    include: 'AuditLogIncludeFromAuditLog'


class FindManyAuditLogArgsFromSystemSetting(TypedDict, total=False):
    """Arguments for SystemSetting"""
    take: int
    skip: int
    order_by: Union['AuditLogOrderByInput', List['AuditLogOrderByInput']]
    where: 'AuditLogWhereInput'
    cursor: 'AuditLogWhereUniqueInput'
    distinct: List['AuditLogScalarFieldKeys']
    include: 'AuditLogIncludeFromAuditLog'


class SystemInfoIncludeFromSystemSetting(TypedDict, total=False):
    """Relational arguments for SystemSetting"""


class SystemInfoArgsFromSystemSetting(TypedDict, total=False):
    """Arguments for SystemSetting"""
    include: 'SystemInfoIncludeFromSystemInfo'


class FindManySystemInfoArgsFromSystemSetting(TypedDict, total=False):
    """Arguments for SystemSetting"""
    take: int
    skip: int
    order_by: Union['SystemInfoOrderByInput', List['SystemInfoOrderByInput']]
    where: 'SystemInfoWhereInput'
    cursor: 'SystemInfoWhereUniqueInput'
    distinct: List['SystemInfoScalarFieldKeys']
    include: 'SystemInfoIncludeFromSystemInfo'


class BackupIncludeFromSystemSetting(TypedDict, total=False):
    """Relational arguments for SystemSetting"""
    createdBy: Union[bool, 'UserArgsFromSystemSetting']


class BackupArgsFromSystemSetting(TypedDict, total=False):
    """Arguments for SystemSetting"""
    include: 'BackupIncludeFromBackup'


class FindManyBackupArgsFromSystemSetting(TypedDict, total=False):
    """Arguments for SystemSetting"""
    take: int
    skip: int
    order_by: Union['BackupOrderByInput', List['BackupOrderByInput']]
    where: 'BackupWhereInput'
    cursor: 'BackupWhereUniqueInput'
    distinct: List['BackupScalarFieldKeys']
    include: 'BackupIncludeFromBackup'


class RevokedTokenIncludeFromSystemSetting(TypedDict, total=False):
    """Relational arguments for SystemSetting"""
    user: Union[bool, 'UserArgsFromSystemSetting']


class RevokedTokenArgsFromSystemSetting(TypedDict, total=False):
    """Arguments for SystemSetting"""
    include: 'RevokedTokenIncludeFromRevokedToken'


class FindManyRevokedTokenArgsFromSystemSetting(TypedDict, total=False):
    """Arguments for SystemSetting"""
    take: int
    skip: int
    order_by: Union['RevokedTokenOrderByInput', List['RevokedTokenOrderByInput']]
    where: 'RevokedTokenWhereInput'
    cursor: 'RevokedTokenWhereUniqueInput'
    distinct: List['RevokedTokenScalarFieldKeys']
    include: 'RevokedTokenIncludeFromRevokedToken'


class SystemSettingIncludeFromSystemSetting(TypedDict, total=False):
    """Relational arguments for SystemSetting"""


class SystemSettingArgsFromSystemSetting(TypedDict, total=False):
    """Arguments for SystemSetting"""
    include: 'SystemSettingIncludeFromSystemSetting'


class FindManySystemSettingArgsFromSystemSetting(TypedDict, total=False):
    """Arguments for SystemSetting"""
    take: int
    skip: int
    order_by: Union['SystemSettingOrderByInput', List['SystemSettingOrderByInput']]
    where: 'SystemSettingWhereInput'
    cursor: 'SystemSettingWhereUniqueInput'
    distinct: List['SystemSettingScalarFieldKeys']
    include: 'SystemSettingIncludeFromSystemSetting'


class NotificationIncludeFromSystemSetting(TypedDict, total=False):
    """Relational arguments for SystemSetting"""
    user: Union[bool, 'UserArgsFromSystemSetting']


class NotificationArgsFromSystemSetting(TypedDict, total=False):
    """Arguments for SystemSetting"""
    include: 'NotificationIncludeFromNotification'


class FindManyNotificationArgsFromSystemSetting(TypedDict, total=False):
    """Arguments for SystemSetting"""
    take: int
    skip: int
    order_by: Union['NotificationOrderByInput', List['NotificationOrderByInput']]
    where: 'NotificationWhereInput'
    cursor: 'NotificationWhereUniqueInput'
    distinct: List['NotificationScalarFieldKeys']
    include: 'NotificationIncludeFromNotification'


class StockAdjustmentIncludeFromSystemSetting(TypedDict, total=False):
    """Relational arguments for SystemSetting"""
    product: Union[bool, 'ProductArgsFromSystemSetting']
    createdBy: Union[bool, 'UserArgsFromSystemSetting']


class StockAdjustmentArgsFromSystemSetting(TypedDict, total=False):
    """Arguments for SystemSetting"""
    include: 'StockAdjustmentIncludeFromStockAdjustment'


class FindManyStockAdjustmentArgsFromSystemSetting(TypedDict, total=False):
    """Arguments for SystemSetting"""
    take: int
    skip: int
    order_by: Union['StockAdjustmentOrderByInput', List['StockAdjustmentOrderByInput']]
    where: 'StockAdjustmentWhereInput'
    cursor: 'StockAdjustmentWhereUniqueInput'
    distinct: List['StockAdjustmentScalarFieldKeys']
    include: 'StockAdjustmentIncludeFromStockAdjustment'




FindManySystemSettingArgs = FindManySystemSettingArgsFromSystemSetting
FindFirstSystemSettingArgs = FindManySystemSettingArgsFromSystemSetting


class SystemSettingWhereInput(TypedDict, total=False):
    """SystemSetting arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    key: Union[_str, 'types.StringFilter']
    value: Union[_str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['SystemSettingWhereInput', List['SystemSettingWhereInput']]
    # but this causes mypy to hang :/
    AND: List['SystemSettingWhereInput']
    OR: List['SystemSettingWhereInput']
    NOT: List['SystemSettingWhereInput']



# aggregate SystemSetting types


class SystemSettingScalarWhereWithAggregatesInput(TypedDict, total=False):
    """SystemSetting arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    key: Union[_str, 'types.StringWithAggregatesFilter']
    value: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['SystemSettingScalarWhereWithAggregatesInput']
    OR: List['SystemSettingScalarWhereWithAggregatesInput']
    NOT: List['SystemSettingScalarWhereWithAggregatesInput']



class SystemSettingGroupByOutput(TypedDict, total=False):
    id: _int
    key: _str
    value: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'SystemSettingSumAggregateOutput'
    _avg: 'SystemSettingAvgAggregateOutput'
    _min: 'SystemSettingMinAggregateOutput'
    _max: 'SystemSettingMaxAggregateOutput'
    _count: 'SystemSettingCountAggregateOutput'


class SystemSettingAvgAggregateOutput(TypedDict, total=False):
    """SystemSetting output for aggregating averages"""
    id: float


class SystemSettingSumAggregateOutput(TypedDict, total=False):
    """SystemSetting output for aggregating sums"""
    id: _int


class SystemSettingScalarAggregateOutput(TypedDict, total=False):
    """SystemSetting output including scalar fields"""
    id: _int
    key: _str
    value: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


SystemSettingMinAggregateOutput = SystemSettingScalarAggregateOutput
SystemSettingMaxAggregateOutput = SystemSettingScalarAggregateOutput


class SystemSettingMaxAggregateInput(TypedDict, total=False):
    """SystemSetting input for aggregating by max"""
    id: bool
    key: bool
    value: bool
    createdAt: bool
    updatedAt: bool


class SystemSettingMinAggregateInput(TypedDict, total=False):
    """SystemSetting input for aggregating by min"""
    id: bool
    key: bool
    value: bool
    createdAt: bool
    updatedAt: bool


class SystemSettingNumberAggregateInput(TypedDict, total=False):
    """SystemSetting input for aggregating numbers"""
    id: bool


SystemSettingAvgAggregateInput = SystemSettingNumberAggregateInput
SystemSettingSumAggregateInput = SystemSettingNumberAggregateInput


SystemSettingCountAggregateInput = TypedDict(
    'SystemSettingCountAggregateInput',
    {
        'id': bool,
        'key': bool,
        'value': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

SystemSettingCountAggregateOutput = TypedDict(
    'SystemSettingCountAggregateOutput',
    {
        'id': int,
        'key': int,
        'value': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


SystemSettingKeys = Literal[
    'id',
    'key',
    'value',
    'createdAt',
    'updatedAt',
]
SystemSettingScalarFieldKeys = Literal[
    'id',
    'key',
    'value',
    'createdAt',
    'updatedAt',
]
SystemSettingScalarFieldKeysT = TypeVar('SystemSettingScalarFieldKeysT', bound=SystemSettingScalarFieldKeys)

SystemSettingRelationalFieldKeys = _NoneType

# Notification types

class NotificationOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Notification create method"""
    id: _int
    user: 'UserCreateNestedWithoutRelationsInput'
    userId: _int
    type: _str
    data: Optional['fields.Json']
    read: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class NotificationCreateInput(NotificationOptionalCreateInput):
    """Required arguments to the Notification create method"""
    title: _str
    message: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class NotificationOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Notification create method, without relations"""
    id: _int
    userId: _int
    type: _str
    data: Optional['fields.Json']
    read: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class NotificationCreateWithoutRelationsInput(NotificationOptionalCreateWithoutRelationsInput):
    """Required arguments to the Notification create method, without relations"""
    title: _str
    message: _str


class NotificationCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'NotificationCreateWithoutRelationsInput'
    connect: 'NotificationWhereUniqueInput'


class NotificationCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['NotificationCreateWithoutRelationsInput', List['NotificationCreateWithoutRelationsInput']]
    connect: Union['NotificationWhereUniqueInput', List['NotificationWhereUniqueInput']]


_NotificationWhereUnique_id_Input = TypedDict(
    '_NotificationWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

NotificationWhereUniqueInput = _NotificationWhereUnique_id_Input


class NotificationUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    user: 'UserUpdateOneWithoutRelationsInput'
    type: _str
    title: _str
    message: _str
    data: Optional['fields.Json']
    read: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class NotificationUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    type: _str
    title: _str
    message: _str
    data: Optional['fields.Json']
    read: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class NotificationUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['NotificationCreateWithoutRelationsInput']
    connect: List['NotificationWhereUniqueInput']
    set: List['NotificationWhereUniqueInput']
    disconnect: List['NotificationWhereUniqueInput']
    delete: List['NotificationWhereUniqueInput']

    # TODO
    # update: List['NotificationUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['NotificationUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['NotificationScalarWhereInput']
    # upsert: List['NotificationUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['NotificationCreateOrConnectWithoutRelationsInput']


class NotificationUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'NotificationCreateWithoutRelationsInput'
    connect: 'NotificationWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'NotificationUpdateInput'
    # upsert: 'NotificationUpsertWithoutRelationsInput'
    # connectOrCreate: 'NotificationCreateOrConnectWithoutRelationsInput'


class NotificationUpsertInput(TypedDict):
    create: 'NotificationCreateInput'
    update: 'NotificationUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Notification_id_OrderByInput = TypedDict(
    '_Notification_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Notification_userId_OrderByInput = TypedDict(
    '_Notification_userId_OrderByInput',
    {
        'userId': 'SortOrder',
    },
    total=True
)

_Notification_type_OrderByInput = TypedDict(
    '_Notification_type_OrderByInput',
    {
        'type': 'SortOrder',
    },
    total=True
)

_Notification_title_OrderByInput = TypedDict(
    '_Notification_title_OrderByInput',
    {
        'title': 'SortOrder',
    },
    total=True
)

_Notification_message_OrderByInput = TypedDict(
    '_Notification_message_OrderByInput',
    {
        'message': 'SortOrder',
    },
    total=True
)

_Notification_data_OrderByInput = TypedDict(
    '_Notification_data_OrderByInput',
    {
        'data': 'SortOrder',
    },
    total=True
)

_Notification_read_OrderByInput = TypedDict(
    '_Notification_read_OrderByInput',
    {
        'read': 'SortOrder',
    },
    total=True
)

_Notification_createdAt_OrderByInput = TypedDict(
    '_Notification_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Notification_updatedAt_OrderByInput = TypedDict(
    '_Notification_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

NotificationOrderByInput = Union[
    '_Notification_id_OrderByInput',
    '_Notification_userId_OrderByInput',
    '_Notification_type_OrderByInput',
    '_Notification_title_OrderByInput',
    '_Notification_message_OrderByInput',
    '_Notification_data_OrderByInput',
    '_Notification_read_OrderByInput',
    '_Notification_createdAt_OrderByInput',
    '_Notification_updatedAt_OrderByInput',
]



# recursive Notification types
# TODO: cleanup these types



NotificationRelationFilter = TypedDict(
    'NotificationRelationFilter',
    {
        'is': 'NotificationWhereInput',
        'is_not': 'NotificationWhereInput',
    },
    total=False,
)


class NotificationListRelationFilter(TypedDict, total=False):
    some: 'NotificationWhereInput'
    none: 'NotificationWhereInput'
    every: 'NotificationWhereInput'


class NotificationInclude(TypedDict, total=False):
    """Notification relational arguments"""
    user: Union[bool, 'UserArgsFromNotification']


class UserIncludeFromNotification(TypedDict, total=False):
    """Relational arguments for Notification"""
    branch: Union[bool, 'BranchArgsFromNotification']
    auditLogs: Union[bool, 'FindManyAuditLogArgsFromNotification']
    permissions: Union[bool, 'FindManyUserPermissionArgsFromNotification']
    notifications: Union[bool, 'FindManyNotificationArgsFromNotification']
    revokedTokens: Union[bool, 'FindManyRevokedTokenArgsFromNotification']
    stockAdjustments: Union[bool, 'FindManyStockAdjustmentArgsFromNotification']
    Sale: Union[bool, 'FindManySaleArgsFromNotification']
    deletedSales: Union[bool, 'FindManySaleArgsFromNotification']
    Payment: Union[bool, 'FindManyPaymentArgsFromNotification']
    Backup: Union[bool, 'FindManyBackupArgsFromNotification']
    requestedOrders: Union[bool, 'FindManyBranchOrderArgsFromNotification']
    approvedOrders: Union[bool, 'FindManyBranchOrderArgsFromNotification']
    sentOrders: Union[bool, 'FindManyBranchOrderArgsFromNotification']
    receivedOrders: Union[bool, 'FindManyBranchOrderArgsFromNotification']


class UserArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class UserPermissionIncludeFromNotification(TypedDict, total=False):
    """Relational arguments for Notification"""
    user: Union[bool, 'UserArgsFromNotification']


class UserPermissionArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    include: 'UserPermissionIncludeFromUserPermission'


class FindManyUserPermissionArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    take: int
    skip: int
    order_by: Union['UserPermissionOrderByInput', List['UserPermissionOrderByInput']]
    where: 'UserPermissionWhereInput'
    cursor: 'UserPermissionWhereUniqueInput'
    distinct: List['UserPermissionScalarFieldKeys']
    include: 'UserPermissionIncludeFromUserPermission'


class BranchIncludeFromNotification(TypedDict, total=False):
    """Relational arguments for Notification"""
    users: Union[bool, 'FindManyUserArgsFromNotification']
    Sale: Union[bool, 'FindManySaleArgsFromNotification']
    Account: Union[bool, 'FindManyAccountArgsFromNotification']
    BranchOrder: Union[bool, 'FindManyBranchOrderArgsFromNotification']


class BranchArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    include: 'BranchIncludeFromBranch'


class FindManyBranchArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    take: int
    skip: int
    order_by: Union['BranchOrderByInput', List['BranchOrderByInput']]
    where: 'BranchWhereInput'
    cursor: 'BranchWhereUniqueInput'
    distinct: List['BranchScalarFieldKeys']
    include: 'BranchIncludeFromBranch'


class ProductIncludeFromNotification(TypedDict, total=False):
    """Relational arguments for Notification"""
    category: Union[bool, 'CategoryArgsFromNotification']
    stocks: Union[bool, 'FindManyStockArgsFromNotification']
    stockAdjustments: Union[bool, 'FindManyStockAdjustmentArgsFromNotification']


class ProductArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    include: 'ProductIncludeFromProduct'


class FindManyProductArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProduct'


class CategoryIncludeFromNotification(TypedDict, total=False):
    """Relational arguments for Notification"""
    products: Union[bool, 'FindManyProductArgsFromNotification']


class CategoryArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    include: 'CategoryIncludeFromCategory'


class FindManyCategoryArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    take: int
    skip: int
    order_by: Union['CategoryOrderByInput', List['CategoryOrderByInput']]
    where: 'CategoryWhereInput'
    cursor: 'CategoryWhereUniqueInput'
    distinct: List['CategoryScalarFieldKeys']
    include: 'CategoryIncludeFromCategory'


class StockIncludeFromNotification(TypedDict, total=False):
    """Relational arguments for Notification"""
    product: Union[bool, 'ProductArgsFromNotification']
    SaleItem: Union[bool, 'FindManySaleItemArgsFromNotification']
    BranchOrderItem: Union[bool, 'FindManyBranchOrderItemArgsFromNotification']


class StockArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    include: 'StockIncludeFromStock'


class FindManyStockArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    take: int
    skip: int
    order_by: Union['StockOrderByInput', List['StockOrderByInput']]
    where: 'StockWhereInput'
    cursor: 'StockWhereUniqueInput'
    distinct: List['StockScalarFieldKeys']
    include: 'StockIncludeFromStock'


class CustomerIncludeFromNotification(TypedDict, total=False):
    """Relational arguments for Notification"""
    Sale: Union[bool, 'FindManySaleArgsFromNotification']


class CustomerArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    include: 'CustomerIncludeFromCustomer'


class FindManyCustomerArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    take: int
    skip: int
    order_by: Union['CustomerOrderByInput', List['CustomerOrderByInput']]
    where: 'CustomerWhereInput'
    cursor: 'CustomerWhereUniqueInput'
    distinct: List['CustomerScalarFieldKeys']
    include: 'CustomerIncludeFromCustomer'


class SaleIncludeFromNotification(TypedDict, total=False):
    """Relational arguments for Notification"""
    branch: Union[bool, 'BranchArgsFromNotification']
    customer: Union[bool, 'CustomerArgsFromNotification']
    user: Union[bool, 'UserArgsFromNotification']
    items: Union[bool, 'FindManySaleItemArgsFromNotification']
    payments: Union[bool, 'FindManyPaymentArgsFromNotification']
    returns: Union[bool, 'FindManyReturnSaleArgsFromNotification']
    deletedBy: Union[bool, 'UserArgsFromNotification']


class SaleArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    include: 'SaleIncludeFromSale'


class FindManySaleArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    take: int
    skip: int
    order_by: Union['SaleOrderByInput', List['SaleOrderByInput']]
    where: 'SaleWhereInput'
    cursor: 'SaleWhereUniqueInput'
    distinct: List['SaleScalarFieldKeys']
    include: 'SaleIncludeFromSale'


class SaleItemIncludeFromNotification(TypedDict, total=False):
    """Relational arguments for Notification"""
    sale: Union[bool, 'SaleArgsFromNotification']
    stock: Union[bool, 'StockArgsFromNotification']
    ReturnItem: Union[bool, 'FindManyReturnItemArgsFromNotification']


class SaleItemArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    include: 'SaleItemIncludeFromSaleItem'


class FindManySaleItemArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    take: int
    skip: int
    order_by: Union['SaleItemOrderByInput', List['SaleItemOrderByInput']]
    where: 'SaleItemWhereInput'
    cursor: 'SaleItemWhereUniqueInput'
    distinct: List['SaleItemScalarFieldKeys']
    include: 'SaleItemIncludeFromSaleItem'


class ReturnSaleIncludeFromNotification(TypedDict, total=False):
    """Relational arguments for Notification"""
    original: Union[bool, 'SaleArgsFromNotification']
    items: Union[bool, 'FindManyReturnItemArgsFromNotification']
    refund: Union[bool, 'FindManyPaymentArgsFromNotification']


class ReturnSaleArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    include: 'ReturnSaleIncludeFromReturnSale'


class FindManyReturnSaleArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    take: int
    skip: int
    order_by: Union['ReturnSaleOrderByInput', List['ReturnSaleOrderByInput']]
    where: 'ReturnSaleWhereInput'
    cursor: 'ReturnSaleWhereUniqueInput'
    distinct: List['ReturnSaleScalarFieldKeys']
    include: 'ReturnSaleIncludeFromReturnSale'


class ReturnItemIncludeFromNotification(TypedDict, total=False):
    """Relational arguments for Notification"""
    returnSale: Union[bool, 'ReturnSaleArgsFromNotification']
    saleItem: Union[bool, 'SaleItemArgsFromNotification']


class ReturnItemArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    include: 'ReturnItemIncludeFromReturnItem'


class FindManyReturnItemArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    take: int
    skip: int
    order_by: Union['ReturnItemOrderByInput', List['ReturnItemOrderByInput']]
    where: 'ReturnItemWhereInput'
    cursor: 'ReturnItemWhereUniqueInput'
    distinct: List['ReturnItemScalarFieldKeys']
    include: 'ReturnItemIncludeFromReturnItem'


class PaymentIncludeFromNotification(TypedDict, total=False):
    """Relational arguments for Notification"""
    sale: Union[bool, 'SaleArgsFromNotification']
    account: Union[bool, 'AccountArgsFromNotification']
    returnSale: Union[bool, 'ReturnSaleArgsFromNotification']
    user: Union[bool, 'UserArgsFromNotification']


class PaymentArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    include: 'PaymentIncludeFromPayment'


class FindManyPaymentArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    take: int
    skip: int
    order_by: Union['PaymentOrderByInput', List['PaymentOrderByInput']]
    where: 'PaymentWhereInput'
    cursor: 'PaymentWhereUniqueInput'
    distinct: List['PaymentScalarFieldKeys']
    include: 'PaymentIncludeFromPayment'


class JournalEntryIncludeFromNotification(TypedDict, total=False):
    """Relational arguments for Notification"""
    lines: Union[bool, 'FindManyJournalEntryLineArgsFromNotification']


class JournalEntryArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    include: 'JournalEntryIncludeFromJournalEntry'


class FindManyJournalEntryArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    take: int
    skip: int
    order_by: Union['JournalEntryOrderByInput', List['JournalEntryOrderByInput']]
    where: 'JournalEntryWhereInput'
    cursor: 'JournalEntryWhereUniqueInput'
    distinct: List['JournalEntryScalarFieldKeys']
    include: 'JournalEntryIncludeFromJournalEntry'


class JournalEntryLineIncludeFromNotification(TypedDict, total=False):
    """Relational arguments for Notification"""
    entry: Union[bool, 'JournalEntryArgsFromNotification']
    account: Union[bool, 'AccountArgsFromNotification']


class JournalEntryLineArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    include: 'JournalEntryLineIncludeFromJournalEntryLine'


class FindManyJournalEntryLineArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    take: int
    skip: int
    order_by: Union['JournalEntryLineOrderByInput', List['JournalEntryLineOrderByInput']]
    where: 'JournalEntryLineWhereInput'
    cursor: 'JournalEntryLineWhereUniqueInput'
    distinct: List['JournalEntryLineScalarFieldKeys']
    include: 'JournalEntryLineIncludeFromJournalEntryLine'


class AccountIncludeFromNotification(TypedDict, total=False):
    """Relational arguments for Notification"""
    branch: Union[bool, 'BranchArgsFromNotification']
    entries: Union[bool, 'FindManyJournalEntryLineArgsFromNotification']
    payments: Union[bool, 'FindManyPaymentArgsFromNotification']
    outgoingTransfers: Union[bool, 'FindManyAccountTransferArgsFromNotification']
    incomingTransfers: Union[bool, 'FindManyAccountTransferArgsFromNotification']


class AccountArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    include: 'AccountIncludeFromAccount'


class FindManyAccountArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    take: int
    skip: int
    order_by: Union['AccountOrderByInput', List['AccountOrderByInput']]
    where: 'AccountWhereInput'
    cursor: 'AccountWhereUniqueInput'
    distinct: List['AccountScalarFieldKeys']
    include: 'AccountIncludeFromAccount'


class AccountTransferIncludeFromNotification(TypedDict, total=False):
    """Relational arguments for Notification"""
    fromAccount: Union[bool, 'AccountArgsFromNotification']
    toAccount: Union[bool, 'AccountArgsFromNotification']


class AccountTransferArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    include: 'AccountTransferIncludeFromAccountTransfer'


class FindManyAccountTransferArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    take: int
    skip: int
    order_by: Union['AccountTransferOrderByInput', List['AccountTransferOrderByInput']]
    where: 'AccountTransferWhereInput'
    cursor: 'AccountTransferWhereUniqueInput'
    distinct: List['AccountTransferScalarFieldKeys']
    include: 'AccountTransferIncludeFromAccountTransfer'


class BranchOrderIncludeFromNotification(TypedDict, total=False):
    """Relational arguments for Notification"""
    branch: Union[bool, 'BranchArgsFromNotification']
    requestedBy: Union[bool, 'UserArgsFromNotification']
    approvedBy: Union[bool, 'UserArgsFromNotification']
    sentBy: Union[bool, 'UserArgsFromNotification']
    receivedBy: Union[bool, 'UserArgsFromNotification']
    items: Union[bool, 'FindManyBranchOrderItemArgsFromNotification']


class BranchOrderArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    include: 'BranchOrderIncludeFromBranchOrder'


class FindManyBranchOrderArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    take: int
    skip: int
    order_by: Union['BranchOrderOrderByInput', List['BranchOrderOrderByInput']]
    where: 'BranchOrderWhereInput'
    cursor: 'BranchOrderWhereUniqueInput'
    distinct: List['BranchOrderScalarFieldKeys']
    include: 'BranchOrderIncludeFromBranchOrder'


class BranchOrderItemIncludeFromNotification(TypedDict, total=False):
    """Relational arguments for Notification"""
    branchOrder: Union[bool, 'BranchOrderArgsFromNotification']
    stock: Union[bool, 'StockArgsFromNotification']


class BranchOrderItemArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    include: 'BranchOrderItemIncludeFromBranchOrderItem'


class FindManyBranchOrderItemArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    take: int
    skip: int
    order_by: Union['BranchOrderItemOrderByInput', List['BranchOrderItemOrderByInput']]
    where: 'BranchOrderItemWhereInput'
    cursor: 'BranchOrderItemWhereUniqueInput'
    distinct: List['BranchOrderItemScalarFieldKeys']
    include: 'BranchOrderItemIncludeFromBranchOrderItem'


class AuditLogIncludeFromNotification(TypedDict, total=False):
    """Relational arguments for Notification"""
    user: Union[bool, 'UserArgsFromNotification']


class AuditLogArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    include: 'AuditLogIncludeFromAuditLog'


class FindManyAuditLogArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    take: int
    skip: int
    order_by: Union['AuditLogOrderByInput', List['AuditLogOrderByInput']]
    where: 'AuditLogWhereInput'
    cursor: 'AuditLogWhereUniqueInput'
    distinct: List['AuditLogScalarFieldKeys']
    include: 'AuditLogIncludeFromAuditLog'


class SystemInfoIncludeFromNotification(TypedDict, total=False):
    """Relational arguments for Notification"""


class SystemInfoArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    include: 'SystemInfoIncludeFromSystemInfo'


class FindManySystemInfoArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    take: int
    skip: int
    order_by: Union['SystemInfoOrderByInput', List['SystemInfoOrderByInput']]
    where: 'SystemInfoWhereInput'
    cursor: 'SystemInfoWhereUniqueInput'
    distinct: List['SystemInfoScalarFieldKeys']
    include: 'SystemInfoIncludeFromSystemInfo'


class BackupIncludeFromNotification(TypedDict, total=False):
    """Relational arguments for Notification"""
    createdBy: Union[bool, 'UserArgsFromNotification']


class BackupArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    include: 'BackupIncludeFromBackup'


class FindManyBackupArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    take: int
    skip: int
    order_by: Union['BackupOrderByInput', List['BackupOrderByInput']]
    where: 'BackupWhereInput'
    cursor: 'BackupWhereUniqueInput'
    distinct: List['BackupScalarFieldKeys']
    include: 'BackupIncludeFromBackup'


class RevokedTokenIncludeFromNotification(TypedDict, total=False):
    """Relational arguments for Notification"""
    user: Union[bool, 'UserArgsFromNotification']


class RevokedTokenArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    include: 'RevokedTokenIncludeFromRevokedToken'


class FindManyRevokedTokenArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    take: int
    skip: int
    order_by: Union['RevokedTokenOrderByInput', List['RevokedTokenOrderByInput']]
    where: 'RevokedTokenWhereInput'
    cursor: 'RevokedTokenWhereUniqueInput'
    distinct: List['RevokedTokenScalarFieldKeys']
    include: 'RevokedTokenIncludeFromRevokedToken'


class SystemSettingIncludeFromNotification(TypedDict, total=False):
    """Relational arguments for Notification"""


class SystemSettingArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    include: 'SystemSettingIncludeFromSystemSetting'


class FindManySystemSettingArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    take: int
    skip: int
    order_by: Union['SystemSettingOrderByInput', List['SystemSettingOrderByInput']]
    where: 'SystemSettingWhereInput'
    cursor: 'SystemSettingWhereUniqueInput'
    distinct: List['SystemSettingScalarFieldKeys']
    include: 'SystemSettingIncludeFromSystemSetting'


class NotificationIncludeFromNotification(TypedDict, total=False):
    """Relational arguments for Notification"""
    user: Union[bool, 'UserArgsFromNotification']


class NotificationArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    include: 'NotificationIncludeFromNotification'


class FindManyNotificationArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    take: int
    skip: int
    order_by: Union['NotificationOrderByInput', List['NotificationOrderByInput']]
    where: 'NotificationWhereInput'
    cursor: 'NotificationWhereUniqueInput'
    distinct: List['NotificationScalarFieldKeys']
    include: 'NotificationIncludeFromNotification'


class StockAdjustmentIncludeFromNotification(TypedDict, total=False):
    """Relational arguments for Notification"""
    product: Union[bool, 'ProductArgsFromNotification']
    createdBy: Union[bool, 'UserArgsFromNotification']


class StockAdjustmentArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    include: 'StockAdjustmentIncludeFromStockAdjustment'


class FindManyStockAdjustmentArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    take: int
    skip: int
    order_by: Union['StockAdjustmentOrderByInput', List['StockAdjustmentOrderByInput']]
    where: 'StockAdjustmentWhereInput'
    cursor: 'StockAdjustmentWhereUniqueInput'
    distinct: List['StockAdjustmentScalarFieldKeys']
    include: 'StockAdjustmentIncludeFromStockAdjustment'




FindManyNotificationArgs = FindManyNotificationArgsFromNotification
FindFirstNotificationArgs = FindManyNotificationArgsFromNotification


class NotificationWhereInput(TypedDict, total=False):
    """Notification arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    user: 'UserRelationFilter'
    userId: Union[_int, 'types.IntFilter']
    type: Union[_str, 'types.StringFilter']
    title: Union[_str, 'types.StringFilter']
    message: Union[_str, 'types.StringFilter']
    data: Union[None, 'fields.Json', 'types.JsonFilter']
    read: Union[_bool, 'types.BooleanFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['NotificationWhereInput', List['NotificationWhereInput']]
    # but this causes mypy to hang :/
    AND: List['NotificationWhereInput']
    OR: List['NotificationWhereInput']
    NOT: List['NotificationWhereInput']



# aggregate Notification types


class NotificationScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Notification arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    userId: Union[_int, 'types.IntWithAggregatesFilter']
    type: Union[_str, 'types.StringWithAggregatesFilter']
    title: Union[_str, 'types.StringWithAggregatesFilter']
    message: Union[_str, 'types.StringWithAggregatesFilter']
    data: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    read: Union[_bool, 'types.BooleanWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['NotificationScalarWhereWithAggregatesInput']
    OR: List['NotificationScalarWhereWithAggregatesInput']
    NOT: List['NotificationScalarWhereWithAggregatesInput']



class NotificationGroupByOutput(TypedDict, total=False):
    id: _int
    userId: _int
    type: _str
    title: _str
    message: _str
    data: 'fields.Json'
    read: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'NotificationSumAggregateOutput'
    _avg: 'NotificationAvgAggregateOutput'
    _min: 'NotificationMinAggregateOutput'
    _max: 'NotificationMaxAggregateOutput'
    _count: 'NotificationCountAggregateOutput'


class NotificationAvgAggregateOutput(TypedDict, total=False):
    """Notification output for aggregating averages"""
    id: float
    userId: float


class NotificationSumAggregateOutput(TypedDict, total=False):
    """Notification output for aggregating sums"""
    id: _int
    userId: _int


class NotificationScalarAggregateOutput(TypedDict, total=False):
    """Notification output including scalar fields"""
    id: _int
    userId: _int
    type: _str
    title: _str
    message: _str
    data: 'fields.Json'
    read: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


NotificationMinAggregateOutput = NotificationScalarAggregateOutput
NotificationMaxAggregateOutput = NotificationScalarAggregateOutput


class NotificationMaxAggregateInput(TypedDict, total=False):
    """Notification input for aggregating by max"""
    id: bool
    userId: bool
    type: bool
    title: bool
    message: bool
    data: bool
    read: bool
    createdAt: bool
    updatedAt: bool


class NotificationMinAggregateInput(TypedDict, total=False):
    """Notification input for aggregating by min"""
    id: bool
    userId: bool
    type: bool
    title: bool
    message: bool
    data: bool
    read: bool
    createdAt: bool
    updatedAt: bool


class NotificationNumberAggregateInput(TypedDict, total=False):
    """Notification input for aggregating numbers"""
    id: bool
    userId: bool


NotificationAvgAggregateInput = NotificationNumberAggregateInput
NotificationSumAggregateInput = NotificationNumberAggregateInput


NotificationCountAggregateInput = TypedDict(
    'NotificationCountAggregateInput',
    {
        'id': bool,
        'userId': bool,
        'type': bool,
        'title': bool,
        'message': bool,
        'data': bool,
        'read': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

NotificationCountAggregateOutput = TypedDict(
    'NotificationCountAggregateOutput',
    {
        'id': int,
        'userId': int,
        'type': int,
        'title': int,
        'message': int,
        'data': int,
        'read': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


NotificationKeys = Literal[
    'id',
    'user',
    'userId',
    'type',
    'title',
    'message',
    'data',
    'read',
    'createdAt',
    'updatedAt',
]
NotificationScalarFieldKeys = Literal[
    'id',
    'userId',
    'type',
    'title',
    'message',
    'data',
    'read',
    'createdAt',
    'updatedAt',
]
NotificationScalarFieldKeysT = TypeVar('NotificationScalarFieldKeysT', bound=NotificationScalarFieldKeys)

NotificationRelationalFieldKeys = Literal[
        'user',
    ]

# StockAdjustment types

class StockAdjustmentOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the StockAdjustment create method"""
    id: _int
    product: 'ProductCreateNestedWithoutRelationsInput'
    productId: _int
    notes: Optional[_str]
    referenceNumber: Optional[_str]
    createdBy: 'UserCreateNestedWithoutRelationsInput'
    createdById: Optional[_int]
    createdAt: datetime.datetime


class StockAdjustmentCreateInput(StockAdjustmentOptionalCreateInput):
    """Required arguments to the StockAdjustment create method"""
    adjustmentType: 'enums.AdjustmentType'
    reason: 'enums.AdjustmentReason'
    quantityBefore: _int
    quantityAfter: _int
    adjustmentQty: _int


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class StockAdjustmentOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the StockAdjustment create method, without relations"""
    id: _int
    productId: _int
    notes: Optional[_str]
    referenceNumber: Optional[_str]
    createdById: Optional[_int]
    createdAt: datetime.datetime


class StockAdjustmentCreateWithoutRelationsInput(StockAdjustmentOptionalCreateWithoutRelationsInput):
    """Required arguments to the StockAdjustment create method, without relations"""
    adjustmentType: 'enums.AdjustmentType'
    reason: 'enums.AdjustmentReason'
    quantityBefore: _int
    quantityAfter: _int
    adjustmentQty: _int


class StockAdjustmentCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'StockAdjustmentCreateWithoutRelationsInput'
    connect: 'StockAdjustmentWhereUniqueInput'


class StockAdjustmentCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['StockAdjustmentCreateWithoutRelationsInput', List['StockAdjustmentCreateWithoutRelationsInput']]
    connect: Union['StockAdjustmentWhereUniqueInput', List['StockAdjustmentWhereUniqueInput']]


_StockAdjustmentWhereUnique_id_Input = TypedDict(
    '_StockAdjustmentWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

StockAdjustmentWhereUniqueInput = _StockAdjustmentWhereUnique_id_Input


class StockAdjustmentUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    product: 'ProductUpdateOneWithoutRelationsInput'
    adjustmentType: 'enums.AdjustmentType'
    reason: 'enums.AdjustmentReason'
    quantityBefore: Union[AtomicIntInput, _int]
    quantityAfter: Union[AtomicIntInput, _int]
    adjustmentQty: Union[AtomicIntInput, _int]
    notes: Optional[_str]
    referenceNumber: Optional[_str]
    createdBy: 'UserUpdateOneWithoutRelationsInput'
    createdAt: datetime.datetime


class StockAdjustmentUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    adjustmentType: 'enums.AdjustmentType'
    reason: 'enums.AdjustmentReason'
    quantityBefore: Union[AtomicIntInput, _int]
    quantityAfter: Union[AtomicIntInput, _int]
    adjustmentQty: Union[AtomicIntInput, _int]
    notes: Optional[_str]
    referenceNumber: Optional[_str]
    createdAt: datetime.datetime


class StockAdjustmentUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['StockAdjustmentCreateWithoutRelationsInput']
    connect: List['StockAdjustmentWhereUniqueInput']
    set: List['StockAdjustmentWhereUniqueInput']
    disconnect: List['StockAdjustmentWhereUniqueInput']
    delete: List['StockAdjustmentWhereUniqueInput']

    # TODO
    # update: List['StockAdjustmentUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['StockAdjustmentUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['StockAdjustmentScalarWhereInput']
    # upsert: List['StockAdjustmentUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['StockAdjustmentCreateOrConnectWithoutRelationsInput']


class StockAdjustmentUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'StockAdjustmentCreateWithoutRelationsInput'
    connect: 'StockAdjustmentWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'StockAdjustmentUpdateInput'
    # upsert: 'StockAdjustmentUpsertWithoutRelationsInput'
    # connectOrCreate: 'StockAdjustmentCreateOrConnectWithoutRelationsInput'


class StockAdjustmentUpsertInput(TypedDict):
    create: 'StockAdjustmentCreateInput'
    update: 'StockAdjustmentUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_StockAdjustment_id_OrderByInput = TypedDict(
    '_StockAdjustment_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_StockAdjustment_productId_OrderByInput = TypedDict(
    '_StockAdjustment_productId_OrderByInput',
    {
        'productId': 'SortOrder',
    },
    total=True
)

_StockAdjustment_adjustmentType_OrderByInput = TypedDict(
    '_StockAdjustment_adjustmentType_OrderByInput',
    {
        'adjustmentType': 'SortOrder',
    },
    total=True
)

_StockAdjustment_reason_OrderByInput = TypedDict(
    '_StockAdjustment_reason_OrderByInput',
    {
        'reason': 'SortOrder',
    },
    total=True
)

_StockAdjustment_quantityBefore_OrderByInput = TypedDict(
    '_StockAdjustment_quantityBefore_OrderByInput',
    {
        'quantityBefore': 'SortOrder',
    },
    total=True
)

_StockAdjustment_quantityAfter_OrderByInput = TypedDict(
    '_StockAdjustment_quantityAfter_OrderByInput',
    {
        'quantityAfter': 'SortOrder',
    },
    total=True
)

_StockAdjustment_adjustmentQty_OrderByInput = TypedDict(
    '_StockAdjustment_adjustmentQty_OrderByInput',
    {
        'adjustmentQty': 'SortOrder',
    },
    total=True
)

_StockAdjustment_notes_OrderByInput = TypedDict(
    '_StockAdjustment_notes_OrderByInput',
    {
        'notes': 'SortOrder',
    },
    total=True
)

_StockAdjustment_referenceNumber_OrderByInput = TypedDict(
    '_StockAdjustment_referenceNumber_OrderByInput',
    {
        'referenceNumber': 'SortOrder',
    },
    total=True
)

_StockAdjustment_createdById_OrderByInput = TypedDict(
    '_StockAdjustment_createdById_OrderByInput',
    {
        'createdById': 'SortOrder',
    },
    total=True
)

_StockAdjustment_createdAt_OrderByInput = TypedDict(
    '_StockAdjustment_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

StockAdjustmentOrderByInput = Union[
    '_StockAdjustment_id_OrderByInput',
    '_StockAdjustment_productId_OrderByInput',
    '_StockAdjustment_adjustmentType_OrderByInput',
    '_StockAdjustment_reason_OrderByInput',
    '_StockAdjustment_quantityBefore_OrderByInput',
    '_StockAdjustment_quantityAfter_OrderByInput',
    '_StockAdjustment_adjustmentQty_OrderByInput',
    '_StockAdjustment_notes_OrderByInput',
    '_StockAdjustment_referenceNumber_OrderByInput',
    '_StockAdjustment_createdById_OrderByInput',
    '_StockAdjustment_createdAt_OrderByInput',
]



# recursive StockAdjustment types
# TODO: cleanup these types



StockAdjustmentRelationFilter = TypedDict(
    'StockAdjustmentRelationFilter',
    {
        'is': 'StockAdjustmentWhereInput',
        'is_not': 'StockAdjustmentWhereInput',
    },
    total=False,
)


class StockAdjustmentListRelationFilter(TypedDict, total=False):
    some: 'StockAdjustmentWhereInput'
    none: 'StockAdjustmentWhereInput'
    every: 'StockAdjustmentWhereInput'


class StockAdjustmentInclude(TypedDict, total=False):
    """StockAdjustment relational arguments"""
    product: Union[bool, 'ProductArgsFromStockAdjustment']
    createdBy: Union[bool, 'UserArgsFromStockAdjustment']


class UserIncludeFromStockAdjustment(TypedDict, total=False):
    """Relational arguments for StockAdjustment"""
    branch: Union[bool, 'BranchArgsFromStockAdjustment']
    auditLogs: Union[bool, 'FindManyAuditLogArgsFromStockAdjustment']
    permissions: Union[bool, 'FindManyUserPermissionArgsFromStockAdjustment']
    notifications: Union[bool, 'FindManyNotificationArgsFromStockAdjustment']
    revokedTokens: Union[bool, 'FindManyRevokedTokenArgsFromStockAdjustment']
    stockAdjustments: Union[bool, 'FindManyStockAdjustmentArgsFromStockAdjustment']
    Sale: Union[bool, 'FindManySaleArgsFromStockAdjustment']
    deletedSales: Union[bool, 'FindManySaleArgsFromStockAdjustment']
    Payment: Union[bool, 'FindManyPaymentArgsFromStockAdjustment']
    Backup: Union[bool, 'FindManyBackupArgsFromStockAdjustment']
    requestedOrders: Union[bool, 'FindManyBranchOrderArgsFromStockAdjustment']
    approvedOrders: Union[bool, 'FindManyBranchOrderArgsFromStockAdjustment']
    sentOrders: Union[bool, 'FindManyBranchOrderArgsFromStockAdjustment']
    receivedOrders: Union[bool, 'FindManyBranchOrderArgsFromStockAdjustment']


class UserArgsFromStockAdjustment(TypedDict, total=False):
    """Arguments for StockAdjustment"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromStockAdjustment(TypedDict, total=False):
    """Arguments for StockAdjustment"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class UserPermissionIncludeFromStockAdjustment(TypedDict, total=False):
    """Relational arguments for StockAdjustment"""
    user: Union[bool, 'UserArgsFromStockAdjustment']


class UserPermissionArgsFromStockAdjustment(TypedDict, total=False):
    """Arguments for StockAdjustment"""
    include: 'UserPermissionIncludeFromUserPermission'


class FindManyUserPermissionArgsFromStockAdjustment(TypedDict, total=False):
    """Arguments for StockAdjustment"""
    take: int
    skip: int
    order_by: Union['UserPermissionOrderByInput', List['UserPermissionOrderByInput']]
    where: 'UserPermissionWhereInput'
    cursor: 'UserPermissionWhereUniqueInput'
    distinct: List['UserPermissionScalarFieldKeys']
    include: 'UserPermissionIncludeFromUserPermission'


class BranchIncludeFromStockAdjustment(TypedDict, total=False):
    """Relational arguments for StockAdjustment"""
    users: Union[bool, 'FindManyUserArgsFromStockAdjustment']
    Sale: Union[bool, 'FindManySaleArgsFromStockAdjustment']
    Account: Union[bool, 'FindManyAccountArgsFromStockAdjustment']
    BranchOrder: Union[bool, 'FindManyBranchOrderArgsFromStockAdjustment']


class BranchArgsFromStockAdjustment(TypedDict, total=False):
    """Arguments for StockAdjustment"""
    include: 'BranchIncludeFromBranch'


class FindManyBranchArgsFromStockAdjustment(TypedDict, total=False):
    """Arguments for StockAdjustment"""
    take: int
    skip: int
    order_by: Union['BranchOrderByInput', List['BranchOrderByInput']]
    where: 'BranchWhereInput'
    cursor: 'BranchWhereUniqueInput'
    distinct: List['BranchScalarFieldKeys']
    include: 'BranchIncludeFromBranch'


class ProductIncludeFromStockAdjustment(TypedDict, total=False):
    """Relational arguments for StockAdjustment"""
    category: Union[bool, 'CategoryArgsFromStockAdjustment']
    stocks: Union[bool, 'FindManyStockArgsFromStockAdjustment']
    stockAdjustments: Union[bool, 'FindManyStockAdjustmentArgsFromStockAdjustment']


class ProductArgsFromStockAdjustment(TypedDict, total=False):
    """Arguments for StockAdjustment"""
    include: 'ProductIncludeFromProduct'


class FindManyProductArgsFromStockAdjustment(TypedDict, total=False):
    """Arguments for StockAdjustment"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProduct'


class CategoryIncludeFromStockAdjustment(TypedDict, total=False):
    """Relational arguments for StockAdjustment"""
    products: Union[bool, 'FindManyProductArgsFromStockAdjustment']


class CategoryArgsFromStockAdjustment(TypedDict, total=False):
    """Arguments for StockAdjustment"""
    include: 'CategoryIncludeFromCategory'


class FindManyCategoryArgsFromStockAdjustment(TypedDict, total=False):
    """Arguments for StockAdjustment"""
    take: int
    skip: int
    order_by: Union['CategoryOrderByInput', List['CategoryOrderByInput']]
    where: 'CategoryWhereInput'
    cursor: 'CategoryWhereUniqueInput'
    distinct: List['CategoryScalarFieldKeys']
    include: 'CategoryIncludeFromCategory'


class StockIncludeFromStockAdjustment(TypedDict, total=False):
    """Relational arguments for StockAdjustment"""
    product: Union[bool, 'ProductArgsFromStockAdjustment']
    SaleItem: Union[bool, 'FindManySaleItemArgsFromStockAdjustment']
    BranchOrderItem: Union[bool, 'FindManyBranchOrderItemArgsFromStockAdjustment']


class StockArgsFromStockAdjustment(TypedDict, total=False):
    """Arguments for StockAdjustment"""
    include: 'StockIncludeFromStock'


class FindManyStockArgsFromStockAdjustment(TypedDict, total=False):
    """Arguments for StockAdjustment"""
    take: int
    skip: int
    order_by: Union['StockOrderByInput', List['StockOrderByInput']]
    where: 'StockWhereInput'
    cursor: 'StockWhereUniqueInput'
    distinct: List['StockScalarFieldKeys']
    include: 'StockIncludeFromStock'


class CustomerIncludeFromStockAdjustment(TypedDict, total=False):
    """Relational arguments for StockAdjustment"""
    Sale: Union[bool, 'FindManySaleArgsFromStockAdjustment']


class CustomerArgsFromStockAdjustment(TypedDict, total=False):
    """Arguments for StockAdjustment"""
    include: 'CustomerIncludeFromCustomer'


class FindManyCustomerArgsFromStockAdjustment(TypedDict, total=False):
    """Arguments for StockAdjustment"""
    take: int
    skip: int
    order_by: Union['CustomerOrderByInput', List['CustomerOrderByInput']]
    where: 'CustomerWhereInput'
    cursor: 'CustomerWhereUniqueInput'
    distinct: List['CustomerScalarFieldKeys']
    include: 'CustomerIncludeFromCustomer'


class SaleIncludeFromStockAdjustment(TypedDict, total=False):
    """Relational arguments for StockAdjustment"""
    branch: Union[bool, 'BranchArgsFromStockAdjustment']
    customer: Union[bool, 'CustomerArgsFromStockAdjustment']
    user: Union[bool, 'UserArgsFromStockAdjustment']
    items: Union[bool, 'FindManySaleItemArgsFromStockAdjustment']
    payments: Union[bool, 'FindManyPaymentArgsFromStockAdjustment']
    returns: Union[bool, 'FindManyReturnSaleArgsFromStockAdjustment']
    deletedBy: Union[bool, 'UserArgsFromStockAdjustment']


class SaleArgsFromStockAdjustment(TypedDict, total=False):
    """Arguments for StockAdjustment"""
    include: 'SaleIncludeFromSale'


class FindManySaleArgsFromStockAdjustment(TypedDict, total=False):
    """Arguments for StockAdjustment"""
    take: int
    skip: int
    order_by: Union['SaleOrderByInput', List['SaleOrderByInput']]
    where: 'SaleWhereInput'
    cursor: 'SaleWhereUniqueInput'
    distinct: List['SaleScalarFieldKeys']
    include: 'SaleIncludeFromSale'


class SaleItemIncludeFromStockAdjustment(TypedDict, total=False):
    """Relational arguments for StockAdjustment"""
    sale: Union[bool, 'SaleArgsFromStockAdjustment']
    stock: Union[bool, 'StockArgsFromStockAdjustment']
    ReturnItem: Union[bool, 'FindManyReturnItemArgsFromStockAdjustment']


class SaleItemArgsFromStockAdjustment(TypedDict, total=False):
    """Arguments for StockAdjustment"""
    include: 'SaleItemIncludeFromSaleItem'


class FindManySaleItemArgsFromStockAdjustment(TypedDict, total=False):
    """Arguments for StockAdjustment"""
    take: int
    skip: int
    order_by: Union['SaleItemOrderByInput', List['SaleItemOrderByInput']]
    where: 'SaleItemWhereInput'
    cursor: 'SaleItemWhereUniqueInput'
    distinct: List['SaleItemScalarFieldKeys']
    include: 'SaleItemIncludeFromSaleItem'


class ReturnSaleIncludeFromStockAdjustment(TypedDict, total=False):
    """Relational arguments for StockAdjustment"""
    original: Union[bool, 'SaleArgsFromStockAdjustment']
    items: Union[bool, 'FindManyReturnItemArgsFromStockAdjustment']
    refund: Union[bool, 'FindManyPaymentArgsFromStockAdjustment']


class ReturnSaleArgsFromStockAdjustment(TypedDict, total=False):
    """Arguments for StockAdjustment"""
    include: 'ReturnSaleIncludeFromReturnSale'


class FindManyReturnSaleArgsFromStockAdjustment(TypedDict, total=False):
    """Arguments for StockAdjustment"""
    take: int
    skip: int
    order_by: Union['ReturnSaleOrderByInput', List['ReturnSaleOrderByInput']]
    where: 'ReturnSaleWhereInput'
    cursor: 'ReturnSaleWhereUniqueInput'
    distinct: List['ReturnSaleScalarFieldKeys']
    include: 'ReturnSaleIncludeFromReturnSale'


class ReturnItemIncludeFromStockAdjustment(TypedDict, total=False):
    """Relational arguments for StockAdjustment"""
    returnSale: Union[bool, 'ReturnSaleArgsFromStockAdjustment']
    saleItem: Union[bool, 'SaleItemArgsFromStockAdjustment']


class ReturnItemArgsFromStockAdjustment(TypedDict, total=False):
    """Arguments for StockAdjustment"""
    include: 'ReturnItemIncludeFromReturnItem'


class FindManyReturnItemArgsFromStockAdjustment(TypedDict, total=False):
    """Arguments for StockAdjustment"""
    take: int
    skip: int
    order_by: Union['ReturnItemOrderByInput', List['ReturnItemOrderByInput']]
    where: 'ReturnItemWhereInput'
    cursor: 'ReturnItemWhereUniqueInput'
    distinct: List['ReturnItemScalarFieldKeys']
    include: 'ReturnItemIncludeFromReturnItem'


class PaymentIncludeFromStockAdjustment(TypedDict, total=False):
    """Relational arguments for StockAdjustment"""
    sale: Union[bool, 'SaleArgsFromStockAdjustment']
    account: Union[bool, 'AccountArgsFromStockAdjustment']
    returnSale: Union[bool, 'ReturnSaleArgsFromStockAdjustment']
    user: Union[bool, 'UserArgsFromStockAdjustment']


class PaymentArgsFromStockAdjustment(TypedDict, total=False):
    """Arguments for StockAdjustment"""
    include: 'PaymentIncludeFromPayment'


class FindManyPaymentArgsFromStockAdjustment(TypedDict, total=False):
    """Arguments for StockAdjustment"""
    take: int
    skip: int
    order_by: Union['PaymentOrderByInput', List['PaymentOrderByInput']]
    where: 'PaymentWhereInput'
    cursor: 'PaymentWhereUniqueInput'
    distinct: List['PaymentScalarFieldKeys']
    include: 'PaymentIncludeFromPayment'


class JournalEntryIncludeFromStockAdjustment(TypedDict, total=False):
    """Relational arguments for StockAdjustment"""
    lines: Union[bool, 'FindManyJournalEntryLineArgsFromStockAdjustment']


class JournalEntryArgsFromStockAdjustment(TypedDict, total=False):
    """Arguments for StockAdjustment"""
    include: 'JournalEntryIncludeFromJournalEntry'


class FindManyJournalEntryArgsFromStockAdjustment(TypedDict, total=False):
    """Arguments for StockAdjustment"""
    take: int
    skip: int
    order_by: Union['JournalEntryOrderByInput', List['JournalEntryOrderByInput']]
    where: 'JournalEntryWhereInput'
    cursor: 'JournalEntryWhereUniqueInput'
    distinct: List['JournalEntryScalarFieldKeys']
    include: 'JournalEntryIncludeFromJournalEntry'


class JournalEntryLineIncludeFromStockAdjustment(TypedDict, total=False):
    """Relational arguments for StockAdjustment"""
    entry: Union[bool, 'JournalEntryArgsFromStockAdjustment']
    account: Union[bool, 'AccountArgsFromStockAdjustment']


class JournalEntryLineArgsFromStockAdjustment(TypedDict, total=False):
    """Arguments for StockAdjustment"""
    include: 'JournalEntryLineIncludeFromJournalEntryLine'


class FindManyJournalEntryLineArgsFromStockAdjustment(TypedDict, total=False):
    """Arguments for StockAdjustment"""
    take: int
    skip: int
    order_by: Union['JournalEntryLineOrderByInput', List['JournalEntryLineOrderByInput']]
    where: 'JournalEntryLineWhereInput'
    cursor: 'JournalEntryLineWhereUniqueInput'
    distinct: List['JournalEntryLineScalarFieldKeys']
    include: 'JournalEntryLineIncludeFromJournalEntryLine'


class AccountIncludeFromStockAdjustment(TypedDict, total=False):
    """Relational arguments for StockAdjustment"""
    branch: Union[bool, 'BranchArgsFromStockAdjustment']
    entries: Union[bool, 'FindManyJournalEntryLineArgsFromStockAdjustment']
    payments: Union[bool, 'FindManyPaymentArgsFromStockAdjustment']
    outgoingTransfers: Union[bool, 'FindManyAccountTransferArgsFromStockAdjustment']
    incomingTransfers: Union[bool, 'FindManyAccountTransferArgsFromStockAdjustment']


class AccountArgsFromStockAdjustment(TypedDict, total=False):
    """Arguments for StockAdjustment"""
    include: 'AccountIncludeFromAccount'


class FindManyAccountArgsFromStockAdjustment(TypedDict, total=False):
    """Arguments for StockAdjustment"""
    take: int
    skip: int
    order_by: Union['AccountOrderByInput', List['AccountOrderByInput']]
    where: 'AccountWhereInput'
    cursor: 'AccountWhereUniqueInput'
    distinct: List['AccountScalarFieldKeys']
    include: 'AccountIncludeFromAccount'


class AccountTransferIncludeFromStockAdjustment(TypedDict, total=False):
    """Relational arguments for StockAdjustment"""
    fromAccount: Union[bool, 'AccountArgsFromStockAdjustment']
    toAccount: Union[bool, 'AccountArgsFromStockAdjustment']


class AccountTransferArgsFromStockAdjustment(TypedDict, total=False):
    """Arguments for StockAdjustment"""
    include: 'AccountTransferIncludeFromAccountTransfer'


class FindManyAccountTransferArgsFromStockAdjustment(TypedDict, total=False):
    """Arguments for StockAdjustment"""
    take: int
    skip: int
    order_by: Union['AccountTransferOrderByInput', List['AccountTransferOrderByInput']]
    where: 'AccountTransferWhereInput'
    cursor: 'AccountTransferWhereUniqueInput'
    distinct: List['AccountTransferScalarFieldKeys']
    include: 'AccountTransferIncludeFromAccountTransfer'


class BranchOrderIncludeFromStockAdjustment(TypedDict, total=False):
    """Relational arguments for StockAdjustment"""
    branch: Union[bool, 'BranchArgsFromStockAdjustment']
    requestedBy: Union[bool, 'UserArgsFromStockAdjustment']
    approvedBy: Union[bool, 'UserArgsFromStockAdjustment']
    sentBy: Union[bool, 'UserArgsFromStockAdjustment']
    receivedBy: Union[bool, 'UserArgsFromStockAdjustment']
    items: Union[bool, 'FindManyBranchOrderItemArgsFromStockAdjustment']


class BranchOrderArgsFromStockAdjustment(TypedDict, total=False):
    """Arguments for StockAdjustment"""
    include: 'BranchOrderIncludeFromBranchOrder'


class FindManyBranchOrderArgsFromStockAdjustment(TypedDict, total=False):
    """Arguments for StockAdjustment"""
    take: int
    skip: int
    order_by: Union['BranchOrderOrderByInput', List['BranchOrderOrderByInput']]
    where: 'BranchOrderWhereInput'
    cursor: 'BranchOrderWhereUniqueInput'
    distinct: List['BranchOrderScalarFieldKeys']
    include: 'BranchOrderIncludeFromBranchOrder'


class BranchOrderItemIncludeFromStockAdjustment(TypedDict, total=False):
    """Relational arguments for StockAdjustment"""
    branchOrder: Union[bool, 'BranchOrderArgsFromStockAdjustment']
    stock: Union[bool, 'StockArgsFromStockAdjustment']


class BranchOrderItemArgsFromStockAdjustment(TypedDict, total=False):
    """Arguments for StockAdjustment"""
    include: 'BranchOrderItemIncludeFromBranchOrderItem'


class FindManyBranchOrderItemArgsFromStockAdjustment(TypedDict, total=False):
    """Arguments for StockAdjustment"""
    take: int
    skip: int
    order_by: Union['BranchOrderItemOrderByInput', List['BranchOrderItemOrderByInput']]
    where: 'BranchOrderItemWhereInput'
    cursor: 'BranchOrderItemWhereUniqueInput'
    distinct: List['BranchOrderItemScalarFieldKeys']
    include: 'BranchOrderItemIncludeFromBranchOrderItem'


class AuditLogIncludeFromStockAdjustment(TypedDict, total=False):
    """Relational arguments for StockAdjustment"""
    user: Union[bool, 'UserArgsFromStockAdjustment']


class AuditLogArgsFromStockAdjustment(TypedDict, total=False):
    """Arguments for StockAdjustment"""
    include: 'AuditLogIncludeFromAuditLog'


class FindManyAuditLogArgsFromStockAdjustment(TypedDict, total=False):
    """Arguments for StockAdjustment"""
    take: int
    skip: int
    order_by: Union['AuditLogOrderByInput', List['AuditLogOrderByInput']]
    where: 'AuditLogWhereInput'
    cursor: 'AuditLogWhereUniqueInput'
    distinct: List['AuditLogScalarFieldKeys']
    include: 'AuditLogIncludeFromAuditLog'


class SystemInfoIncludeFromStockAdjustment(TypedDict, total=False):
    """Relational arguments for StockAdjustment"""


class SystemInfoArgsFromStockAdjustment(TypedDict, total=False):
    """Arguments for StockAdjustment"""
    include: 'SystemInfoIncludeFromSystemInfo'


class FindManySystemInfoArgsFromStockAdjustment(TypedDict, total=False):
    """Arguments for StockAdjustment"""
    take: int
    skip: int
    order_by: Union['SystemInfoOrderByInput', List['SystemInfoOrderByInput']]
    where: 'SystemInfoWhereInput'
    cursor: 'SystemInfoWhereUniqueInput'
    distinct: List['SystemInfoScalarFieldKeys']
    include: 'SystemInfoIncludeFromSystemInfo'


class BackupIncludeFromStockAdjustment(TypedDict, total=False):
    """Relational arguments for StockAdjustment"""
    createdBy: Union[bool, 'UserArgsFromStockAdjustment']


class BackupArgsFromStockAdjustment(TypedDict, total=False):
    """Arguments for StockAdjustment"""
    include: 'BackupIncludeFromBackup'


class FindManyBackupArgsFromStockAdjustment(TypedDict, total=False):
    """Arguments for StockAdjustment"""
    take: int
    skip: int
    order_by: Union['BackupOrderByInput', List['BackupOrderByInput']]
    where: 'BackupWhereInput'
    cursor: 'BackupWhereUniqueInput'
    distinct: List['BackupScalarFieldKeys']
    include: 'BackupIncludeFromBackup'


class RevokedTokenIncludeFromStockAdjustment(TypedDict, total=False):
    """Relational arguments for StockAdjustment"""
    user: Union[bool, 'UserArgsFromStockAdjustment']


class RevokedTokenArgsFromStockAdjustment(TypedDict, total=False):
    """Arguments for StockAdjustment"""
    include: 'RevokedTokenIncludeFromRevokedToken'


class FindManyRevokedTokenArgsFromStockAdjustment(TypedDict, total=False):
    """Arguments for StockAdjustment"""
    take: int
    skip: int
    order_by: Union['RevokedTokenOrderByInput', List['RevokedTokenOrderByInput']]
    where: 'RevokedTokenWhereInput'
    cursor: 'RevokedTokenWhereUniqueInput'
    distinct: List['RevokedTokenScalarFieldKeys']
    include: 'RevokedTokenIncludeFromRevokedToken'


class SystemSettingIncludeFromStockAdjustment(TypedDict, total=False):
    """Relational arguments for StockAdjustment"""


class SystemSettingArgsFromStockAdjustment(TypedDict, total=False):
    """Arguments for StockAdjustment"""
    include: 'SystemSettingIncludeFromSystemSetting'


class FindManySystemSettingArgsFromStockAdjustment(TypedDict, total=False):
    """Arguments for StockAdjustment"""
    take: int
    skip: int
    order_by: Union['SystemSettingOrderByInput', List['SystemSettingOrderByInput']]
    where: 'SystemSettingWhereInput'
    cursor: 'SystemSettingWhereUniqueInput'
    distinct: List['SystemSettingScalarFieldKeys']
    include: 'SystemSettingIncludeFromSystemSetting'


class NotificationIncludeFromStockAdjustment(TypedDict, total=False):
    """Relational arguments for StockAdjustment"""
    user: Union[bool, 'UserArgsFromStockAdjustment']


class NotificationArgsFromStockAdjustment(TypedDict, total=False):
    """Arguments for StockAdjustment"""
    include: 'NotificationIncludeFromNotification'


class FindManyNotificationArgsFromStockAdjustment(TypedDict, total=False):
    """Arguments for StockAdjustment"""
    take: int
    skip: int
    order_by: Union['NotificationOrderByInput', List['NotificationOrderByInput']]
    where: 'NotificationWhereInput'
    cursor: 'NotificationWhereUniqueInput'
    distinct: List['NotificationScalarFieldKeys']
    include: 'NotificationIncludeFromNotification'


class StockAdjustmentIncludeFromStockAdjustment(TypedDict, total=False):
    """Relational arguments for StockAdjustment"""
    product: Union[bool, 'ProductArgsFromStockAdjustment']
    createdBy: Union[bool, 'UserArgsFromStockAdjustment']


class StockAdjustmentArgsFromStockAdjustment(TypedDict, total=False):
    """Arguments for StockAdjustment"""
    include: 'StockAdjustmentIncludeFromStockAdjustment'


class FindManyStockAdjustmentArgsFromStockAdjustment(TypedDict, total=False):
    """Arguments for StockAdjustment"""
    take: int
    skip: int
    order_by: Union['StockAdjustmentOrderByInput', List['StockAdjustmentOrderByInput']]
    where: 'StockAdjustmentWhereInput'
    cursor: 'StockAdjustmentWhereUniqueInput'
    distinct: List['StockAdjustmentScalarFieldKeys']
    include: 'StockAdjustmentIncludeFromStockAdjustment'




FindManyStockAdjustmentArgs = FindManyStockAdjustmentArgsFromStockAdjustment
FindFirstStockAdjustmentArgs = FindManyStockAdjustmentArgsFromStockAdjustment


class StockAdjustmentWhereInput(TypedDict, total=False):
    """StockAdjustment arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    product: 'ProductRelationFilter'
    productId: Union[_int, 'types.IntFilter']
    adjustmentType: 'enums.AdjustmentType'
    reason: 'enums.AdjustmentReason'
    quantityBefore: Union[_int, 'types.IntFilter']
    quantityAfter: Union[_int, 'types.IntFilter']
    adjustmentQty: Union[_int, 'types.IntFilter']
    notes: Union[None, _str, 'types.StringFilter']
    referenceNumber: Union[None, _str, 'types.StringFilter']
    createdBy: 'UserRelationFilter'
    createdById: Union[None, _int, 'types.IntFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['StockAdjustmentWhereInput', List['StockAdjustmentWhereInput']]
    # but this causes mypy to hang :/
    AND: List['StockAdjustmentWhereInput']
    OR: List['StockAdjustmentWhereInput']
    NOT: List['StockAdjustmentWhereInput']



# aggregate StockAdjustment types


class StockAdjustmentScalarWhereWithAggregatesInput(TypedDict, total=False):
    """StockAdjustment arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    productId: Union[_int, 'types.IntWithAggregatesFilter']
    adjustmentType: 'enums.AdjustmentType'
    reason: 'enums.AdjustmentReason'
    quantityBefore: Union[_int, 'types.IntWithAggregatesFilter']
    quantityAfter: Union[_int, 'types.IntWithAggregatesFilter']
    adjustmentQty: Union[_int, 'types.IntWithAggregatesFilter']
    notes: Union[_str, 'types.StringWithAggregatesFilter']
    referenceNumber: Union[_str, 'types.StringWithAggregatesFilter']
    createdById: Union[_int, 'types.IntWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['StockAdjustmentScalarWhereWithAggregatesInput']
    OR: List['StockAdjustmentScalarWhereWithAggregatesInput']
    NOT: List['StockAdjustmentScalarWhereWithAggregatesInput']



class StockAdjustmentGroupByOutput(TypedDict, total=False):
    id: _int
    productId: _int
    adjustmentType: 'enums.AdjustmentType'
    reason: 'enums.AdjustmentReason'
    quantityBefore: _int
    quantityAfter: _int
    adjustmentQty: _int
    notes: _str
    referenceNumber: _str
    createdById: _int
    createdAt: datetime.datetime
    _sum: 'StockAdjustmentSumAggregateOutput'
    _avg: 'StockAdjustmentAvgAggregateOutput'
    _min: 'StockAdjustmentMinAggregateOutput'
    _max: 'StockAdjustmentMaxAggregateOutput'
    _count: 'StockAdjustmentCountAggregateOutput'


class StockAdjustmentAvgAggregateOutput(TypedDict, total=False):
    """StockAdjustment output for aggregating averages"""
    id: float
    productId: float
    quantityBefore: float
    quantityAfter: float
    adjustmentQty: float
    createdById: float


class StockAdjustmentSumAggregateOutput(TypedDict, total=False):
    """StockAdjustment output for aggregating sums"""
    id: _int
    productId: _int
    quantityBefore: _int
    quantityAfter: _int
    adjustmentQty: _int
    createdById: _int


class StockAdjustmentScalarAggregateOutput(TypedDict, total=False):
    """StockAdjustment output including scalar fields"""
    id: _int
    productId: _int
    adjustmentType: 'enums.AdjustmentType'
    reason: 'enums.AdjustmentReason'
    quantityBefore: _int
    quantityAfter: _int
    adjustmentQty: _int
    notes: _str
    referenceNumber: _str
    createdById: _int
    createdAt: datetime.datetime


StockAdjustmentMinAggregateOutput = StockAdjustmentScalarAggregateOutput
StockAdjustmentMaxAggregateOutput = StockAdjustmentScalarAggregateOutput


class StockAdjustmentMaxAggregateInput(TypedDict, total=False):
    """StockAdjustment input for aggregating by max"""
    id: bool
    productId: bool
    adjustmentType: bool
    reason: bool
    quantityBefore: bool
    quantityAfter: bool
    adjustmentQty: bool
    notes: bool
    referenceNumber: bool
    createdById: bool
    createdAt: bool


class StockAdjustmentMinAggregateInput(TypedDict, total=False):
    """StockAdjustment input for aggregating by min"""
    id: bool
    productId: bool
    adjustmentType: bool
    reason: bool
    quantityBefore: bool
    quantityAfter: bool
    adjustmentQty: bool
    notes: bool
    referenceNumber: bool
    createdById: bool
    createdAt: bool


class StockAdjustmentNumberAggregateInput(TypedDict, total=False):
    """StockAdjustment input for aggregating numbers"""
    id: bool
    productId: bool
    quantityBefore: bool
    quantityAfter: bool
    adjustmentQty: bool
    createdById: bool


StockAdjustmentAvgAggregateInput = StockAdjustmentNumberAggregateInput
StockAdjustmentSumAggregateInput = StockAdjustmentNumberAggregateInput


StockAdjustmentCountAggregateInput = TypedDict(
    'StockAdjustmentCountAggregateInput',
    {
        'id': bool,
        'productId': bool,
        'adjustmentType': bool,
        'reason': bool,
        'quantityBefore': bool,
        'quantityAfter': bool,
        'adjustmentQty': bool,
        'notes': bool,
        'referenceNumber': bool,
        'createdById': bool,
        'createdAt': bool,
        '_all': bool,
    },
    total=False,
)

StockAdjustmentCountAggregateOutput = TypedDict(
    'StockAdjustmentCountAggregateOutput',
    {
        'id': int,
        'productId': int,
        'adjustmentType': int,
        'reason': int,
        'quantityBefore': int,
        'quantityAfter': int,
        'adjustmentQty': int,
        'notes': int,
        'referenceNumber': int,
        'createdById': int,
        'createdAt': int,
        '_all': int,
    },
    total=False,
)


StockAdjustmentKeys = Literal[
    'id',
    'product',
    'productId',
    'adjustmentType',
    'reason',
    'quantityBefore',
    'quantityAfter',
    'adjustmentQty',
    'notes',
    'referenceNumber',
    'createdBy',
    'createdById',
    'createdAt',
]
StockAdjustmentScalarFieldKeys = Literal[
    'id',
    'productId',
    'adjustmentType',
    'reason',
    'quantityBefore',
    'quantityAfter',
    'adjustmentQty',
    'notes',
    'referenceNumber',
    'createdById',
    'createdAt',
]
StockAdjustmentScalarFieldKeysT = TypeVar('StockAdjustmentScalarFieldKeysT', bound=StockAdjustmentScalarFieldKeys)

StockAdjustmentRelationalFieldKeys = Literal[
        'product',
        'createdBy',
    ]



# we have to import ourselves as types can be namespaced to types
from . import types, enums, models, fields