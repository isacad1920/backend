# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
import datetime
import decimal
import logging

# -- template models.py.jinja --
import os
from builtins import bool as _bool, float as _float, int as _int, str as _str
from collections import OrderedDict
from collections.abc import Iterable, Mapping
from typing import (
    Optional,
    cast,
)

from . import bases, enums, errors, fields, types
from ._compat import model_rebuild
from .generator import PartialModelField, partial_models_ctx

log: logging.Logger = logging.getLogger(__name__)
_created_partial_types: set[str] = set()

class User(bases.BaseUser):
    """Represents a User record"""

    id: _int
    username: _str
    email: _str | None = None
    firstName: _str
    lastName: _str
    hashedPassword: _str
    role: 'enums.Role'
    isActive: _bool
    branchId: _int | None = None
    branch: Optional['models.Branch'] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    auditLogs: list['models.AuditLog'] | None = None
    permissions: list['models.UserPermission'] | None = None
    notifications: list['models.Notification'] | None = None
    revokedTokens: list['models.RevokedToken'] | None = None
    stockAdjustments: list['models.StockAdjustment'] | None = None
    Sale: list['models.Sale'] | None = None
    deletedSales: list['models.Sale'] | None = None
    Payment: list['models.Payment'] | None = None
    Backup: list['models.Backup'] | None = None
    requestedOrders: list['models.BranchOrder'] | None = None
    approvedOrders: list['models.BranchOrder'] | None = None
    sentOrders: list['models.BranchOrder'] | None = None
    receivedOrders: list['models.BranchOrder'] | None = None



    @staticmethod
    def create_partial(
        name: str,
        include: Iterable['types.UserKeys'] | None = None,
        exclude: Iterable['types.UserKeys'] | None = None,
        required: Iterable['types.UserKeys'] | None = None,
        optional: Iterable['types.UserKeys'] | None = None,
        relations: Mapping['types.UserRelationalFieldKeys', str] | None = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: dict[types.UserKeys, PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _User_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _User_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _User_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _User_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _User_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _User_relational_fields:
                        raise errors.UnknownRelationalFieldError('User', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid User / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'User',
            }
        )
        _created_partial_types.add(name)


class UserPermission(bases.BaseUserPermission):
    """Represents a UserPermission record"""

    id: _int
    user: Optional['models.User'] = None
    userId: _int
    resource: _str
    actions: 'fields.Json'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime



    @staticmethod
    def create_partial(
        name: str,
        include: Iterable['types.UserPermissionKeys'] | None = None,
        exclude: Iterable['types.UserPermissionKeys'] | None = None,
        required: Iterable['types.UserPermissionKeys'] | None = None,
        optional: Iterable['types.UserPermissionKeys'] | None = None,
        relations: Mapping['types.UserPermissionRelationalFieldKeys', str] | None = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: dict[types.UserPermissionKeys, PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _UserPermission_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _UserPermission_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _UserPermission_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _UserPermission_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _UserPermission_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _UserPermission_relational_fields:
                        raise errors.UnknownRelationalFieldError('UserPermission', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid UserPermission / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'UserPermission',
            }
        )
        _created_partial_types.add(name)


class Branch(bases.BaseBranch):
    """Represents a Branch record"""

    id: _int
    name: _str
    address: _str | None = None
    phone: _str | None = None
    isActive: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    users: list['models.User'] | None = None
    Sale: list['models.Sale'] | None = None
    Account: list['models.Account'] | None = None
    BranchOrder: list['models.BranchOrder'] | None = None



    @staticmethod
    def create_partial(
        name: str,
        include: Iterable['types.BranchKeys'] | None = None,
        exclude: Iterable['types.BranchKeys'] | None = None,
        required: Iterable['types.BranchKeys'] | None = None,
        optional: Iterable['types.BranchKeys'] | None = None,
        relations: Mapping['types.BranchRelationalFieldKeys', str] | None = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: dict[types.BranchKeys, PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Branch_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Branch_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Branch_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Branch_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Branch_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Branch_relational_fields:
                        raise errors.UnknownRelationalFieldError('Branch', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Branch / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Branch',
            }
        )
        _created_partial_types.add(name)


class Product(bases.BaseProduct):
    """Represents a Product record"""

    id: _int
    sku: _str
    name: _str
    barcode: _str | None = None
    description: _str | None = None
    costPrice: decimal.Decimal
    sellingPrice: decimal.Decimal
    categoryId: _int | None = None
    category: Optional['models.Category'] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    stocks: list['models.Stock'] | None = None
    stockAdjustments: list['models.StockAdjustment'] | None = None



    @staticmethod
    def create_partial(
        name: str,
        include: Iterable['types.ProductKeys'] | None = None,
        exclude: Iterable['types.ProductKeys'] | None = None,
        required: Iterable['types.ProductKeys'] | None = None,
        optional: Iterable['types.ProductKeys'] | None = None,
        relations: Mapping['types.ProductRelationalFieldKeys', str] | None = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: dict[types.ProductKeys, PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Product_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Product_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Product_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Product_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Product_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Product_relational_fields:
                        raise errors.UnknownRelationalFieldError('Product', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Product / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Product',
            }
        )
        _created_partial_types.add(name)


class Category(bases.BaseCategory):
    """Represents a Category record"""

    id: _int
    name: _str
    description: _str | None = None
    status: 'enums.CategoryStatus'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    products: list['models.Product'] | None = None



    @staticmethod
    def create_partial(
        name: str,
        include: Iterable['types.CategoryKeys'] | None = None,
        exclude: Iterable['types.CategoryKeys'] | None = None,
        required: Iterable['types.CategoryKeys'] | None = None,
        optional: Iterable['types.CategoryKeys'] | None = None,
        relations: Mapping['types.CategoryRelationalFieldKeys', str] | None = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: dict[types.CategoryKeys, PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Category_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Category_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Category_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Category_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Category_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Category_relational_fields:
                        raise errors.UnknownRelationalFieldError('Category', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Category / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Category',
            }
        )
        _created_partial_types.add(name)


class Stock(bases.BaseStock):
    """Represents a Stock record"""

    id: _int
    productId: _int
    product: Optional['models.Product'] = None
    quantity: _int
    lastRestocked: datetime.datetime | None = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    SaleItem: list['models.SaleItem'] | None = None
    BranchOrderItem: list['models.BranchOrderItem'] | None = None



    @staticmethod
    def create_partial(
        name: str,
        include: Iterable['types.StockKeys'] | None = None,
        exclude: Iterable['types.StockKeys'] | None = None,
        required: Iterable['types.StockKeys'] | None = None,
        optional: Iterable['types.StockKeys'] | None = None,
        relations: Mapping['types.StockRelationalFieldKeys', str] | None = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: dict[types.StockKeys, PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Stock_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Stock_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Stock_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Stock_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Stock_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Stock_relational_fields:
                        raise errors.UnknownRelationalFieldError('Stock', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Stock / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Stock',
            }
        )
        _created_partial_types.add(name)


class Customer(bases.BaseCustomer):
    """Represents a Customer record"""

    id: _int
    name: _str
    email: _str | None = None
    phone: _str | None = None
    address: _str | None = None
    type: 'enums.CustomerType'
    creditLimit: decimal.Decimal
    balance: decimal.Decimal
    totalPurchases: decimal.Decimal
    status: 'enums.CustomerStatus'
    notes: _str | None = None
    Sale: list['models.Sale'] | None = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime



    @staticmethod
    def create_partial(
        name: str,
        include: Iterable['types.CustomerKeys'] | None = None,
        exclude: Iterable['types.CustomerKeys'] | None = None,
        required: Iterable['types.CustomerKeys'] | None = None,
        optional: Iterable['types.CustomerKeys'] | None = None,
        relations: Mapping['types.CustomerRelationalFieldKeys', str] | None = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: dict[types.CustomerKeys, PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Customer_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Customer_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Customer_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Customer_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Customer_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Customer_relational_fields:
                        raise errors.UnknownRelationalFieldError('Customer', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Customer / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Customer',
            }
        )
        _created_partial_types.add(name)


class Sale(bases.BaseSale):
    """Represents a Sale record"""

    id: _int
    branchId: _int
    branch: Optional['models.Branch'] = None
    totalAmount: decimal.Decimal
    discount: decimal.Decimal
    paymentType: 'enums.PaymentType'
    customerId: _int | None = None
    customer: Optional['models.Customer'] = None
    userId: _int
    user: Optional['models.User'] = None
    items: list['models.SaleItem'] | None = None
    payments: list['models.Payment'] | None = None
    returns: list['models.ReturnSale'] | None = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deletedAt: datetime.datetime | None = None
    deletedById: _int | None = None
    deletedBy: Optional['models.User'] = None



    @staticmethod
    def create_partial(
        name: str,
        include: Iterable['types.SaleKeys'] | None = None,
        exclude: Iterable['types.SaleKeys'] | None = None,
        required: Iterable['types.SaleKeys'] | None = None,
        optional: Iterable['types.SaleKeys'] | None = None,
        relations: Mapping['types.SaleRelationalFieldKeys', str] | None = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: dict[types.SaleKeys, PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Sale_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Sale_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Sale_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Sale_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Sale_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Sale_relational_fields:
                        raise errors.UnknownRelationalFieldError('Sale', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Sale / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Sale',
            }
        )
        _created_partial_types.add(name)


class SaleItem(bases.BaseSaleItem):
    """Represents a SaleItem record"""

    id: _int
    saleId: _int
    sale: Optional['models.Sale'] = None
    stockId: _int
    stock: Optional['models.Stock'] = None
    quantity: _int
    price: decimal.Decimal
    subtotal: decimal.Decimal
    ReturnItem: list['models.ReturnItem'] | None = None



    @staticmethod
    def create_partial(
        name: str,
        include: Iterable['types.SaleItemKeys'] | None = None,
        exclude: Iterable['types.SaleItemKeys'] | None = None,
        required: Iterable['types.SaleItemKeys'] | None = None,
        optional: Iterable['types.SaleItemKeys'] | None = None,
        relations: Mapping['types.SaleItemRelationalFieldKeys', str] | None = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: dict[types.SaleItemKeys, PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _SaleItem_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _SaleItem_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _SaleItem_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _SaleItem_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _SaleItem_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _SaleItem_relational_fields:
                        raise errors.UnknownRelationalFieldError('SaleItem', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid SaleItem / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'SaleItem',
            }
        )
        _created_partial_types.add(name)


class ReturnSale(bases.BaseReturnSale):
    """Represents a ReturnSale record"""

    id: _int
    originalId: _int
    original: Optional['models.Sale'] = None
    items: list['models.ReturnItem'] | None = None
    reason: _str | None = None
    refund: list['models.Payment'] | None = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime



    @staticmethod
    def create_partial(
        name: str,
        include: Iterable['types.ReturnSaleKeys'] | None = None,
        exclude: Iterable['types.ReturnSaleKeys'] | None = None,
        required: Iterable['types.ReturnSaleKeys'] | None = None,
        optional: Iterable['types.ReturnSaleKeys'] | None = None,
        relations: Mapping['types.ReturnSaleRelationalFieldKeys', str] | None = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: dict[types.ReturnSaleKeys, PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _ReturnSale_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _ReturnSale_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _ReturnSale_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _ReturnSale_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _ReturnSale_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _ReturnSale_relational_fields:
                        raise errors.UnknownRelationalFieldError('ReturnSale', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid ReturnSale / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'ReturnSale',
            }
        )
        _created_partial_types.add(name)


class ReturnItem(bases.BaseReturnItem):
    """Represents a ReturnItem record"""

    id: _int
    returnId: _int
    returnSale: Optional['models.ReturnSale'] = None
    saleItemId: _int
    saleItem: Optional['models.SaleItem'] = None
    quantity: _int
    refundAmount: decimal.Decimal



    @staticmethod
    def create_partial(
        name: str,
        include: Iterable['types.ReturnItemKeys'] | None = None,
        exclude: Iterable['types.ReturnItemKeys'] | None = None,
        required: Iterable['types.ReturnItemKeys'] | None = None,
        optional: Iterable['types.ReturnItemKeys'] | None = None,
        relations: Mapping['types.ReturnItemRelationalFieldKeys', str] | None = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: dict[types.ReturnItemKeys, PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _ReturnItem_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _ReturnItem_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _ReturnItem_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _ReturnItem_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _ReturnItem_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _ReturnItem_relational_fields:
                        raise errors.UnknownRelationalFieldError('ReturnItem', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid ReturnItem / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'ReturnItem',
            }
        )
        _created_partial_types.add(name)


class Payment(bases.BasePayment):
    """Represents a Payment record"""

    id: _int
    saleId: _int
    sale: Optional['models.Sale'] = None
    accountId: _int
    account: Optional['models.Account'] = None
    returnId: _int | None = None
    returnSale: Optional['models.ReturnSale'] = None
    userId: _int
    user: Optional['models.User'] = None
    amount: decimal.Decimal
    currency: 'enums.Currency'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime



    @staticmethod
    def create_partial(
        name: str,
        include: Iterable['types.PaymentKeys'] | None = None,
        exclude: Iterable['types.PaymentKeys'] | None = None,
        required: Iterable['types.PaymentKeys'] | None = None,
        optional: Iterable['types.PaymentKeys'] | None = None,
        relations: Mapping['types.PaymentRelationalFieldKeys', str] | None = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: dict[types.PaymentKeys, PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Payment_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Payment_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Payment_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Payment_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Payment_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Payment_relational_fields:
                        raise errors.UnknownRelationalFieldError('Payment', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Payment / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Payment',
            }
        )
        _created_partial_types.add(name)


class JournalEntry(bases.BaseJournalEntry):
    """Represents a JournalEntry record"""

    id: _int
    referenceType: _str | None = None
    referenceId: _int | None = None
    lines: list['models.JournalEntryLine'] | None = None
    date: datetime.datetime
    updatedAt: datetime.datetime



    @staticmethod
    def create_partial(
        name: str,
        include: Iterable['types.JournalEntryKeys'] | None = None,
        exclude: Iterable['types.JournalEntryKeys'] | None = None,
        required: Iterable['types.JournalEntryKeys'] | None = None,
        optional: Iterable['types.JournalEntryKeys'] | None = None,
        relations: Mapping['types.JournalEntryRelationalFieldKeys', str] | None = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: dict[types.JournalEntryKeys, PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _JournalEntry_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _JournalEntry_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _JournalEntry_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _JournalEntry_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _JournalEntry_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _JournalEntry_relational_fields:
                        raise errors.UnknownRelationalFieldError('JournalEntry', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid JournalEntry / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'JournalEntry',
            }
        )
        _created_partial_types.add(name)


class JournalEntryLine(bases.BaseJournalEntryLine):
    """Represents a JournalEntryLine record"""

    id: _int
    entryId: _int
    entry: Optional['models.JournalEntry'] = None
    account: Optional['models.Account'] = None
    accountId: _int
    debit: decimal.Decimal
    credit: decimal.Decimal
    description: _str | None = None



    @staticmethod
    def create_partial(
        name: str,
        include: Iterable['types.JournalEntryLineKeys'] | None = None,
        exclude: Iterable['types.JournalEntryLineKeys'] | None = None,
        required: Iterable['types.JournalEntryLineKeys'] | None = None,
        optional: Iterable['types.JournalEntryLineKeys'] | None = None,
        relations: Mapping['types.JournalEntryLineRelationalFieldKeys', str] | None = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: dict[types.JournalEntryLineKeys, PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _JournalEntryLine_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _JournalEntryLine_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _JournalEntryLine_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _JournalEntryLine_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _JournalEntryLine_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _JournalEntryLine_relational_fields:
                        raise errors.UnknownRelationalFieldError('JournalEntryLine', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid JournalEntryLine / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'JournalEntryLine',
            }
        )
        _created_partial_types.add(name)


class Account(bases.BaseAccount):
    """Represents a Account record"""

    id: _int
    name: _str
    type: 'enums.AccountType'
    currency: 'enums.Currency'
    balance: decimal.Decimal
    branchId: _int | None = None
    branch: Optional['models.Branch'] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    entries: list['models.JournalEntryLine'] | None = None
    payments: list['models.Payment'] | None = None
    outgoingTransfers: list['models.AccountTransfer'] | None = None
    incomingTransfers: list['models.AccountTransfer'] | None = None



    @staticmethod
    def create_partial(
        name: str,
        include: Iterable['types.AccountKeys'] | None = None,
        exclude: Iterable['types.AccountKeys'] | None = None,
        required: Iterable['types.AccountKeys'] | None = None,
        optional: Iterable['types.AccountKeys'] | None = None,
        relations: Mapping['types.AccountRelationalFieldKeys', str] | None = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: dict[types.AccountKeys, PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Account_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Account_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Account_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Account_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Account_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Account_relational_fields:
                        raise errors.UnknownRelationalFieldError('Account', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Account / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Account',
            }
        )
        _created_partial_types.add(name)


class AccountTransfer(bases.BaseAccountTransfer):
    """Represents a AccountTransfer record"""

    id: _int
    fromAccount: Optional['models.Account'] = None
    fromAccountId: _int
    toAccount: Optional['models.Account'] = None
    toAccountId: _int
    amount: decimal.Decimal
    currency: 'enums.Currency'
    rateApplied: decimal.Decimal | None = None
    note: _str | None = None
    status: 'enums.TransferStatus'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime



    @staticmethod
    def create_partial(
        name: str,
        include: Iterable['types.AccountTransferKeys'] | None = None,
        exclude: Iterable['types.AccountTransferKeys'] | None = None,
        required: Iterable['types.AccountTransferKeys'] | None = None,
        optional: Iterable['types.AccountTransferKeys'] | None = None,
        relations: Mapping['types.AccountTransferRelationalFieldKeys', str] | None = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: dict[types.AccountTransferKeys, PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _AccountTransfer_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _AccountTransfer_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _AccountTransfer_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _AccountTransfer_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _AccountTransfer_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _AccountTransfer_relational_fields:
                        raise errors.UnknownRelationalFieldError('AccountTransfer', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid AccountTransfer / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'AccountTransfer',
            }
        )
        _created_partial_types.add(name)


class BranchOrder(bases.BaseBranchOrder):
    """Represents a BranchOrder record"""

    id: _int
    branchId: _int
    branch: Optional['models.Branch'] = None
    requestedById: _int
    requestedBy: Optional['models.User'] = None
    approvedById: _int | None = None
    approvedBy: Optional['models.User'] = None
    sentById: _int | None = None
    sentBy: Optional['models.User'] = None
    receivedById: _int | None = None
    receivedBy: Optional['models.User'] = None
    items: list['models.BranchOrderItem'] | None = None
    status: 'enums.BranchOrderStatus'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime



    @staticmethod
    def create_partial(
        name: str,
        include: Iterable['types.BranchOrderKeys'] | None = None,
        exclude: Iterable['types.BranchOrderKeys'] | None = None,
        required: Iterable['types.BranchOrderKeys'] | None = None,
        optional: Iterable['types.BranchOrderKeys'] | None = None,
        relations: Mapping['types.BranchOrderRelationalFieldKeys', str] | None = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: dict[types.BranchOrderKeys, PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _BranchOrder_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _BranchOrder_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _BranchOrder_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _BranchOrder_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _BranchOrder_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _BranchOrder_relational_fields:
                        raise errors.UnknownRelationalFieldError('BranchOrder', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid BranchOrder / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'BranchOrder',
            }
        )
        _created_partial_types.add(name)


class BranchOrderItem(bases.BaseBranchOrderItem):
    """Represents a BranchOrderItem record"""

    id: _int
    branchOrderId: _int
    branchOrder: Optional['models.BranchOrder'] = None
    stockId: _int
    stock: Optional['models.Stock'] = None
    requestedQty: _int
    approvedQty: _int | None = None
    sentQty: _int | None = None
    receivedQty: _int | None = None



    @staticmethod
    def create_partial(
        name: str,
        include: Iterable['types.BranchOrderItemKeys'] | None = None,
        exclude: Iterable['types.BranchOrderItemKeys'] | None = None,
        required: Iterable['types.BranchOrderItemKeys'] | None = None,
        optional: Iterable['types.BranchOrderItemKeys'] | None = None,
        relations: Mapping['types.BranchOrderItemRelationalFieldKeys', str] | None = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: dict[types.BranchOrderItemKeys, PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _BranchOrderItem_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _BranchOrderItem_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _BranchOrderItem_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _BranchOrderItem_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _BranchOrderItem_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _BranchOrderItem_relational_fields:
                        raise errors.UnknownRelationalFieldError('BranchOrderItem', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid BranchOrderItem / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'BranchOrderItem',
            }
        )
        _created_partial_types.add(name)


class AuditLog(bases.BaseAuditLog):
    """Represents a AuditLog record"""

    id: _int
    user: Optional['models.User'] = None
    userId: _int | None = None
    action: 'enums.AuditAction'
    entityType: _str | None = None
    entityId: _str | None = None
    oldValues: Optional['fields.Json'] = None
    newValues: Optional['fields.Json'] = None
    severity: 'enums.AuditSeverity'
    ipAddress: _str | None = None
    userAgent: _str | None = None
    createdAt: datetime.datetime



    @staticmethod
    def create_partial(
        name: str,
        include: Iterable['types.AuditLogKeys'] | None = None,
        exclude: Iterable['types.AuditLogKeys'] | None = None,
        required: Iterable['types.AuditLogKeys'] | None = None,
        optional: Iterable['types.AuditLogKeys'] | None = None,
        relations: Mapping['types.AuditLogRelationalFieldKeys', str] | None = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: dict[types.AuditLogKeys, PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _AuditLog_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _AuditLog_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _AuditLog_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _AuditLog_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _AuditLog_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _AuditLog_relational_fields:
                        raise errors.UnknownRelationalFieldError('AuditLog', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid AuditLog / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'AuditLog',
            }
        )
        _created_partial_types.add(name)


class SystemInfo(bases.BaseSystemInfo):
    """Represents a SystemInfo record"""

    id: _int
    systemName: _str
    version: _str | None = None
    environment: 'enums.Environment'
    companyName: _str | None = None
    companyEmail: _str | None = None
    companyPhone: _str | None = None
    companyAddress: _str | None = None
    baseCurrency: 'enums.Currency'
    timezone: _str | None = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime



    @staticmethod
    def create_partial(
        name: str,
        include: Iterable['types.SystemInfoKeys'] | None = None,
        exclude: Iterable['types.SystemInfoKeys'] | None = None,
        required: Iterable['types.SystemInfoKeys'] | None = None,
        optional: Iterable['types.SystemInfoKeys'] | None = None,
        relations: Mapping['types.SystemInfoRelationalFieldKeys', str] | None = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: dict[types.SystemInfoKeys, PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _SystemInfo_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _SystemInfo_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _SystemInfo_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _SystemInfo_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "SystemInfo" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid SystemInfo / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'SystemInfo',
            }
        )
        _created_partial_types.add(name)


class Backup(bases.BaseBackup):
    """Represents a Backup record"""

    id: _int
    type: 'enums.BackupType'
    location: _str
    fileName: _str | None = None
    sizeMB: _float | None = None
    status: 'enums.BackupStatus'
    errorLog: _str | None = None
    createdBy: Optional['models.User'] = None
    createdById: _int | None = None
    createdAt: datetime.datetime
    completedAt: datetime.datetime | None = None



    @staticmethod
    def create_partial(
        name: str,
        include: Iterable['types.BackupKeys'] | None = None,
        exclude: Iterable['types.BackupKeys'] | None = None,
        required: Iterable['types.BackupKeys'] | None = None,
        optional: Iterable['types.BackupKeys'] | None = None,
        relations: Mapping['types.BackupRelationalFieldKeys', str] | None = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: dict[types.BackupKeys, PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Backup_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Backup_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Backup_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Backup_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Backup_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Backup_relational_fields:
                        raise errors.UnknownRelationalFieldError('Backup', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Backup / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Backup',
            }
        )
        _created_partial_types.add(name)


class RevokedToken(bases.BaseRevokedToken):
    """Persistent JWT revocation store (blacklisted tokens by JTI)
    """

    id: _int
    jti: _str
    token: _str
    reason: _str | None = None
    expiresAt: datetime.datetime
    revokedBy: _int | None = None
    createdAt: datetime.datetime
    user: Optional['models.User'] = None



    @staticmethod
    def create_partial(
        name: str,
        include: Iterable['types.RevokedTokenKeys'] | None = None,
        exclude: Iterable['types.RevokedTokenKeys'] | None = None,
        required: Iterable['types.RevokedTokenKeys'] | None = None,
        optional: Iterable['types.RevokedTokenKeys'] | None = None,
        relations: Mapping['types.RevokedTokenRelationalFieldKeys', str] | None = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: dict[types.RevokedTokenKeys, PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _RevokedToken_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _RevokedToken_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _RevokedToken_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _RevokedToken_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _RevokedToken_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _RevokedToken_relational_fields:
                        raise errors.UnknownRelationalFieldError('RevokedToken', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid RevokedToken / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'RevokedToken',
            }
        )
        _created_partial_types.add(name)


class SystemSetting(bases.BaseSystemSetting):
    """Key-value store for persistent application settings (e.g., branding_*)
    """

    id: _int
    key: _str
    value: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime



    @staticmethod
    def create_partial(
        name: str,
        include: Iterable['types.SystemSettingKeys'] | None = None,
        exclude: Iterable['types.SystemSettingKeys'] | None = None,
        required: Iterable['types.SystemSettingKeys'] | None = None,
        optional: Iterable['types.SystemSettingKeys'] | None = None,
        relations: Mapping['types.SystemSettingRelationalFieldKeys', str] | None = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: dict[types.SystemSettingKeys, PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _SystemSetting_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _SystemSetting_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _SystemSetting_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _SystemSetting_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "SystemSetting" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid SystemSetting / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'SystemSetting',
            }
        )
        _created_partial_types.add(name)


class Notification(bases.BaseNotification):
    """Represents a Notification record"""

    id: _int
    user: Optional['models.User'] = None
    userId: _int
    type: _str
    title: _str
    message: _str
    data: Optional['fields.Json'] = None
    read: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime



    @staticmethod
    def create_partial(
        name: str,
        include: Iterable['types.NotificationKeys'] | None = None,
        exclude: Iterable['types.NotificationKeys'] | None = None,
        required: Iterable['types.NotificationKeys'] | None = None,
        optional: Iterable['types.NotificationKeys'] | None = None,
        relations: Mapping['types.NotificationRelationalFieldKeys', str] | None = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: dict[types.NotificationKeys, PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Notification_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Notification_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Notification_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Notification_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Notification_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Notification_relational_fields:
                        raise errors.UnknownRelationalFieldError('Notification', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Notification / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Notification',
            }
        )
        _created_partial_types.add(name)


class StockAdjustment(bases.BaseStockAdjustment):
    """Records of stock adjustments (inventory corrections, damage, recounts, etc.)
    """

    id: _int
    product: Optional['models.Product'] = None
    productId: _int
    adjustmentType: 'enums.AdjustmentType'
    reason: 'enums.AdjustmentReason'
    quantityBefore: _int
    quantityAfter: _int
    adjustmentQty: _int
    notes: _str | None = None
    referenceNumber: _str | None = None
    createdBy: Optional['models.User'] = None
    createdById: _int | None = None
    createdAt: datetime.datetime



    @staticmethod
    def create_partial(
        name: str,
        include: Iterable['types.StockAdjustmentKeys'] | None = None,
        exclude: Iterable['types.StockAdjustmentKeys'] | None = None,
        required: Iterable['types.StockAdjustmentKeys'] | None = None,
        optional: Iterable['types.StockAdjustmentKeys'] | None = None,
        relations: Mapping['types.StockAdjustmentRelationalFieldKeys', str] | None = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: dict[types.StockAdjustmentKeys, PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _StockAdjustment_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _StockAdjustment_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _StockAdjustment_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _StockAdjustment_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _StockAdjustment_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _StockAdjustment_relational_fields:
                        raise errors.UnknownRelationalFieldError('StockAdjustment', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid StockAdjustment / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'StockAdjustment',
            }
        )
        _created_partial_types.add(name)



_User_relational_fields: set[str] = {
        'branch',
        'auditLogs',
        'permissions',
        'notifications',
        'revokedTokens',
        'stockAdjustments',
        'Sale',
        'deletedSales',
        'Payment',
        'Backup',
        'requestedOrders',
        'approvedOrders',
        'sentOrders',
        'receivedOrders',
    }
_User_fields: dict['types.UserKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('username', {
            'name': 'username',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('email', {
            'name': 'email',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('firstName', {
            'name': 'firstName',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('lastName', {
            'name': 'lastName',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('hashedPassword', {
            'name': 'hashedPassword',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('role', {
            'name': 'role',
            'is_list': False,
            'optional': False,
            'type': 'enums.Role',
            'is_relational': False,
            'documentation': None,
        }),
        ('isActive', {
            'name': 'isActive',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('branchId', {
            'name': 'branchId',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('branch', {
            'name': 'branch',
            'is_list': False,
            'optional': True,
            'type': 'models.Branch',
            'is_relational': True,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('auditLogs', {
            'name': 'auditLogs',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.AuditLog\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('permissions', {
            'name': 'permissions',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.UserPermission\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('notifications', {
            'name': 'notifications',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Notification\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('revokedTokens', {
            'name': 'revokedTokens',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.RevokedToken\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('stockAdjustments', {
            'name': 'stockAdjustments',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.StockAdjustment\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('Sale', {
            'name': 'Sale',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Sale\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('deletedSales', {
            'name': 'deletedSales',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Sale\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('Payment', {
            'name': 'Payment',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Payment\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('Backup', {
            'name': 'Backup',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Backup\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('requestedOrders', {
            'name': 'requestedOrders',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.BranchOrder\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('approvedOrders', {
            'name': 'approvedOrders',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.BranchOrder\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('sentOrders', {
            'name': 'sentOrders',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.BranchOrder\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('receivedOrders', {
            'name': 'receivedOrders',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.BranchOrder\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_UserPermission_relational_fields: set[str] = {
        'user',
    }
_UserPermission_fields: dict['types.UserPermissionKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('resource', {
            'name': 'resource',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('actions', {
            'name': 'actions',
            'is_list': False,
            'optional': False,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_Branch_relational_fields: set[str] = {
        'users',
        'Sale',
        'Account',
        'BranchOrder',
    }
_Branch_fields: dict['types.BranchKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('address', {
            'name': 'address',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('phone', {
            'name': 'phone',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('isActive', {
            'name': 'isActive',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('users', {
            'name': 'users',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.User\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('Sale', {
            'name': 'Sale',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Sale\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('Account', {
            'name': 'Account',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Account\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('BranchOrder', {
            'name': 'BranchOrder',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.BranchOrder\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Product_relational_fields: set[str] = {
        'category',
        'stocks',
        'stockAdjustments',
    }
_Product_fields: dict['types.ProductKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('sku', {
            'name': 'sku',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('barcode', {
            'name': 'barcode',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('costPrice', {
            'name': 'costPrice',
            'is_list': False,
            'optional': False,
            'type': 'decimal.Decimal',
            'is_relational': False,
            'documentation': None,
        }),
        ('sellingPrice', {
            'name': 'sellingPrice',
            'is_list': False,
            'optional': False,
            'type': 'decimal.Decimal',
            'is_relational': False,
            'documentation': None,
        }),
        ('categoryId', {
            'name': 'categoryId',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('category', {
            'name': 'category',
            'is_list': False,
            'optional': True,
            'type': 'models.Category',
            'is_relational': True,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('stocks', {
            'name': 'stocks',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Stock\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('stockAdjustments', {
            'name': 'stockAdjustments',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.StockAdjustment\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Category_relational_fields: set[str] = {
        'products',
    }
_Category_fields: dict['types.CategoryKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': 'enums.CategoryStatus',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('products', {
            'name': 'products',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Product\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Stock_relational_fields: set[str] = {
        'product',
        'SaleItem',
        'BranchOrderItem',
    }
_Stock_fields: dict['types.StockKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('productId', {
            'name': 'productId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('product', {
            'name': 'product',
            'is_list': False,
            'optional': True,
            'type': 'models.Product',
            'is_relational': True,
            'documentation': None,
        }),
        ('quantity', {
            'name': 'quantity',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('lastRestocked', {
            'name': 'lastRestocked',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('SaleItem', {
            'name': 'SaleItem',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.SaleItem\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('BranchOrderItem', {
            'name': 'BranchOrderItem',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.BranchOrderItem\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Customer_relational_fields: set[str] = {
        'Sale',
    }
_Customer_fields: dict['types.CustomerKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('email', {
            'name': 'email',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('phone', {
            'name': 'phone',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('address', {
            'name': 'address',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('type', {
            'name': 'type',
            'is_list': False,
            'optional': False,
            'type': 'enums.CustomerType',
            'is_relational': False,
            'documentation': None,
        }),
        ('creditLimit', {
            'name': 'creditLimit',
            'is_list': False,
            'optional': False,
            'type': 'decimal.Decimal',
            'is_relational': False,
            'documentation': None,
        }),
        ('balance', {
            'name': 'balance',
            'is_list': False,
            'optional': False,
            'type': 'decimal.Decimal',
            'is_relational': False,
            'documentation': None,
        }),
        ('totalPurchases', {
            'name': 'totalPurchases',
            'is_list': False,
            'optional': False,
            'type': 'decimal.Decimal',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': 'enums.CustomerStatus',
            'is_relational': False,
            'documentation': None,
        }),
        ('notes', {
            'name': 'notes',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('Sale', {
            'name': 'Sale',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Sale\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_Sale_relational_fields: set[str] = {
        'branch',
        'customer',
        'user',
        'items',
        'payments',
        'returns',
        'deletedBy',
    }
_Sale_fields: dict['types.SaleKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('branchId', {
            'name': 'branchId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('branch', {
            'name': 'branch',
            'is_list': False,
            'optional': True,
            'type': 'models.Branch',
            'is_relational': True,
            'documentation': None,
        }),
        ('totalAmount', {
            'name': 'totalAmount',
            'is_list': False,
            'optional': False,
            'type': 'decimal.Decimal',
            'is_relational': False,
            'documentation': None,
        }),
        ('discount', {
            'name': 'discount',
            'is_list': False,
            'optional': False,
            'type': 'decimal.Decimal',
            'is_relational': False,
            'documentation': None,
        }),
        ('paymentType', {
            'name': 'paymentType',
            'is_list': False,
            'optional': False,
            'type': 'enums.PaymentType',
            'is_relational': False,
            'documentation': None,
        }),
        ('customerId', {
            'name': 'customerId',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('customer', {
            'name': 'customer',
            'is_list': False,
            'optional': True,
            'type': 'models.Customer',
            'is_relational': True,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('items', {
            'name': 'items',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.SaleItem\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('payments', {
            'name': 'payments',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Payment\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('returns', {
            'name': 'returns',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.ReturnSale\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('deletedAt', {
            'name': 'deletedAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('deletedById', {
            'name': 'deletedById',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('deletedBy', {
            'name': 'deletedBy',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_SaleItem_relational_fields: set[str] = {
        'sale',
        'stock',
        'ReturnItem',
    }
_SaleItem_fields: dict['types.SaleItemKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('saleId', {
            'name': 'saleId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('sale', {
            'name': 'sale',
            'is_list': False,
            'optional': True,
            'type': 'models.Sale',
            'is_relational': True,
            'documentation': None,
        }),
        ('stockId', {
            'name': 'stockId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('stock', {
            'name': 'stock',
            'is_list': False,
            'optional': True,
            'type': 'models.Stock',
            'is_relational': True,
            'documentation': None,
        }),
        ('quantity', {
            'name': 'quantity',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('price', {
            'name': 'price',
            'is_list': False,
            'optional': False,
            'type': 'decimal.Decimal',
            'is_relational': False,
            'documentation': None,
        }),
        ('subtotal', {
            'name': 'subtotal',
            'is_list': False,
            'optional': False,
            'type': 'decimal.Decimal',
            'is_relational': False,
            'documentation': None,
        }),
        ('ReturnItem', {
            'name': 'ReturnItem',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.ReturnItem\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_ReturnSale_relational_fields: set[str] = {
        'original',
        'items',
        'refund',
    }
_ReturnSale_fields: dict['types.ReturnSaleKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('originalId', {
            'name': 'originalId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('original', {
            'name': 'original',
            'is_list': False,
            'optional': True,
            'type': 'models.Sale',
            'is_relational': True,
            'documentation': None,
        }),
        ('items', {
            'name': 'items',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.ReturnItem\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('reason', {
            'name': 'reason',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('refund', {
            'name': 'refund',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Payment\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_ReturnItem_relational_fields: set[str] = {
        'returnSale',
        'saleItem',
    }
_ReturnItem_fields: dict['types.ReturnItemKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('returnId', {
            'name': 'returnId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('returnSale', {
            'name': 'returnSale',
            'is_list': False,
            'optional': True,
            'type': 'models.ReturnSale',
            'is_relational': True,
            'documentation': None,
        }),
        ('saleItemId', {
            'name': 'saleItemId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('saleItem', {
            'name': 'saleItem',
            'is_list': False,
            'optional': True,
            'type': 'models.SaleItem',
            'is_relational': True,
            'documentation': None,
        }),
        ('quantity', {
            'name': 'quantity',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('refundAmount', {
            'name': 'refundAmount',
            'is_list': False,
            'optional': False,
            'type': 'decimal.Decimal',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_Payment_relational_fields: set[str] = {
        'sale',
        'account',
        'returnSale',
        'user',
    }
_Payment_fields: dict['types.PaymentKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('saleId', {
            'name': 'saleId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('sale', {
            'name': 'sale',
            'is_list': False,
            'optional': True,
            'type': 'models.Sale',
            'is_relational': True,
            'documentation': None,
        }),
        ('accountId', {
            'name': 'accountId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('account', {
            'name': 'account',
            'is_list': False,
            'optional': True,
            'type': 'models.Account',
            'is_relational': True,
            'documentation': None,
        }),
        ('returnId', {
            'name': 'returnId',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('returnSale', {
            'name': 'returnSale',
            'is_list': False,
            'optional': True,
            'type': 'models.ReturnSale',
            'is_relational': True,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('amount', {
            'name': 'amount',
            'is_list': False,
            'optional': False,
            'type': 'decimal.Decimal',
            'is_relational': False,
            'documentation': None,
        }),
        ('currency', {
            'name': 'currency',
            'is_list': False,
            'optional': False,
            'type': 'enums.Currency',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_JournalEntry_relational_fields: set[str] = {
        'lines',
    }
_JournalEntry_fields: dict['types.JournalEntryKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('referenceType', {
            'name': 'referenceType',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('referenceId', {
            'name': 'referenceId',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('lines', {
            'name': 'lines',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.JournalEntryLine\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('date', {
            'name': 'date',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_JournalEntryLine_relational_fields: set[str] = {
        'entry',
        'account',
    }
_JournalEntryLine_fields: dict['types.JournalEntryLineKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('entryId', {
            'name': 'entryId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('entry', {
            'name': 'entry',
            'is_list': False,
            'optional': True,
            'type': 'models.JournalEntry',
            'is_relational': True,
            'documentation': None,
        }),
        ('account', {
            'name': 'account',
            'is_list': False,
            'optional': True,
            'type': 'models.Account',
            'is_relational': True,
            'documentation': None,
        }),
        ('accountId', {
            'name': 'accountId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('debit', {
            'name': 'debit',
            'is_list': False,
            'optional': False,
            'type': 'decimal.Decimal',
            'is_relational': False,
            'documentation': None,
        }),
        ('credit', {
            'name': 'credit',
            'is_list': False,
            'optional': False,
            'type': 'decimal.Decimal',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_Account_relational_fields: set[str] = {
        'branch',
        'entries',
        'payments',
        'outgoingTransfers',
        'incomingTransfers',
    }
_Account_fields: dict['types.AccountKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('type', {
            'name': 'type',
            'is_list': False,
            'optional': False,
            'type': 'enums.AccountType',
            'is_relational': False,
            'documentation': None,
        }),
        ('currency', {
            'name': 'currency',
            'is_list': False,
            'optional': False,
            'type': 'enums.Currency',
            'is_relational': False,
            'documentation': None,
        }),
        ('balance', {
            'name': 'balance',
            'is_list': False,
            'optional': False,
            'type': 'decimal.Decimal',
            'is_relational': False,
            'documentation': None,
        }),
        ('branchId', {
            'name': 'branchId',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('branch', {
            'name': 'branch',
            'is_list': False,
            'optional': True,
            'type': 'models.Branch',
            'is_relational': True,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('entries', {
            'name': 'entries',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.JournalEntryLine\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('payments', {
            'name': 'payments',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Payment\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('outgoingTransfers', {
            'name': 'outgoingTransfers',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.AccountTransfer\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('incomingTransfers', {
            'name': 'incomingTransfers',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.AccountTransfer\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_AccountTransfer_relational_fields: set[str] = {
        'fromAccount',
        'toAccount',
    }
_AccountTransfer_fields: dict['types.AccountTransferKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('fromAccount', {
            'name': 'fromAccount',
            'is_list': False,
            'optional': True,
            'type': 'models.Account',
            'is_relational': True,
            'documentation': None,
        }),
        ('fromAccountId', {
            'name': 'fromAccountId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('toAccount', {
            'name': 'toAccount',
            'is_list': False,
            'optional': True,
            'type': 'models.Account',
            'is_relational': True,
            'documentation': None,
        }),
        ('toAccountId', {
            'name': 'toAccountId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('amount', {
            'name': 'amount',
            'is_list': False,
            'optional': False,
            'type': 'decimal.Decimal',
            'is_relational': False,
            'documentation': None,
        }),
        ('currency', {
            'name': 'currency',
            'is_list': False,
            'optional': False,
            'type': 'enums.Currency',
            'is_relational': False,
            'documentation': None,
        }),
        ('rateApplied', {
            'name': 'rateApplied',
            'is_list': False,
            'optional': True,
            'type': 'decimal.Decimal',
            'is_relational': False,
            'documentation': None,
        }),
        ('note', {
            'name': 'note',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': 'enums.TransferStatus',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_BranchOrder_relational_fields: set[str] = {
        'branch',
        'requestedBy',
        'approvedBy',
        'sentBy',
        'receivedBy',
        'items',
    }
_BranchOrder_fields: dict['types.BranchOrderKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('branchId', {
            'name': 'branchId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('branch', {
            'name': 'branch',
            'is_list': False,
            'optional': True,
            'type': 'models.Branch',
            'is_relational': True,
            'documentation': None,
        }),
        ('requestedById', {
            'name': 'requestedById',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('requestedBy', {
            'name': 'requestedBy',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('approvedById', {
            'name': 'approvedById',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('approvedBy', {
            'name': 'approvedBy',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('sentById', {
            'name': 'sentById',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('sentBy', {
            'name': 'sentBy',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('receivedById', {
            'name': 'receivedById',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('receivedBy', {
            'name': 'receivedBy',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('items', {
            'name': 'items',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.BranchOrderItem\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': 'enums.BranchOrderStatus',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_BranchOrderItem_relational_fields: set[str] = {
        'branchOrder',
        'stock',
    }
_BranchOrderItem_fields: dict['types.BranchOrderItemKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('branchOrderId', {
            'name': 'branchOrderId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('branchOrder', {
            'name': 'branchOrder',
            'is_list': False,
            'optional': True,
            'type': 'models.BranchOrder',
            'is_relational': True,
            'documentation': None,
        }),
        ('stockId', {
            'name': 'stockId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('stock', {
            'name': 'stock',
            'is_list': False,
            'optional': True,
            'type': 'models.Stock',
            'is_relational': True,
            'documentation': None,
        }),
        ('requestedQty', {
            'name': 'requestedQty',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('approvedQty', {
            'name': 'approvedQty',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('sentQty', {
            'name': 'sentQty',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('receivedQty', {
            'name': 'receivedQty',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_AuditLog_relational_fields: set[str] = {
        'user',
    }
_AuditLog_fields: dict['types.AuditLogKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('action', {
            'name': 'action',
            'is_list': False,
            'optional': False,
            'type': 'enums.AuditAction',
            'is_relational': False,
            'documentation': None,
        }),
        ('entityType', {
            'name': 'entityType',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('entityId', {
            'name': 'entityId',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('oldValues', {
            'name': 'oldValues',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('newValues', {
            'name': 'newValues',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('severity', {
            'name': 'severity',
            'is_list': False,
            'optional': False,
            'type': 'enums.AuditSeverity',
            'is_relational': False,
            'documentation': None,
        }),
        ('ipAddress', {
            'name': 'ipAddress',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('userAgent', {
            'name': 'userAgent',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_SystemInfo_relational_fields: set[str] = set()  # pyright: ignore[reportUnusedVariable]
_SystemInfo_fields: dict['types.SystemInfoKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('systemName', {
            'name': 'systemName',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('version', {
            'name': 'version',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('environment', {
            'name': 'environment',
            'is_list': False,
            'optional': False,
            'type': 'enums.Environment',
            'is_relational': False,
            'documentation': None,
        }),
        ('companyName', {
            'name': 'companyName',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('companyEmail', {
            'name': 'companyEmail',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('companyPhone', {
            'name': 'companyPhone',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('companyAddress', {
            'name': 'companyAddress',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('baseCurrency', {
            'name': 'baseCurrency',
            'is_list': False,
            'optional': False,
            'type': 'enums.Currency',
            'is_relational': False,
            'documentation': None,
        }),
        ('timezone', {
            'name': 'timezone',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_Backup_relational_fields: set[str] = {
        'createdBy',
    }
_Backup_fields: dict['types.BackupKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('type', {
            'name': 'type',
            'is_list': False,
            'optional': False,
            'type': 'enums.BackupType',
            'is_relational': False,
            'documentation': None,
        }),
        ('location', {
            'name': 'location',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('fileName', {
            'name': 'fileName',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('sizeMB', {
            'name': 'sizeMB',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': 'enums.BackupStatus',
            'is_relational': False,
            'documentation': None,
        }),
        ('errorLog', {
            'name': 'errorLog',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdBy', {
            'name': 'createdBy',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('createdById', {
            'name': 'createdById',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('completedAt', {
            'name': 'completedAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_RevokedToken_relational_fields: set[str] = {
        'user',
    }
_RevokedToken_fields: dict['types.RevokedTokenKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('jti', {
            'name': 'jti',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('token', {
            'name': 'token',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('reason', {
            'name': 'reason',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('expiresAt', {
            'name': 'expiresAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('revokedBy', {
            'name': 'revokedBy',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_SystemSetting_relational_fields: set[str] = set()  # pyright: ignore[reportUnusedVariable]
_SystemSetting_fields: dict['types.SystemSettingKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('key', {
            'name': 'key',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('value', {
            'name': 'value',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_Notification_relational_fields: set[str] = {
        'user',
    }
_Notification_fields: dict['types.NotificationKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('type', {
            'name': 'type',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('title', {
            'name': 'title',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('message', {
            'name': 'message',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('data', {
            'name': 'data',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('read', {
            'name': 'read',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_StockAdjustment_relational_fields: set[str] = {
        'product',
        'createdBy',
    }
_StockAdjustment_fields: dict['types.StockAdjustmentKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('product', {
            'name': 'product',
            'is_list': False,
            'optional': True,
            'type': 'models.Product',
            'is_relational': True,
            'documentation': None,
        }),
        ('productId', {
            'name': 'productId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('adjustmentType', {
            'name': 'adjustmentType',
            'is_list': False,
            'optional': False,
            'type': 'enums.AdjustmentType',
            'is_relational': False,
            'documentation': None,
        }),
        ('reason', {
            'name': 'reason',
            'is_list': False,
            'optional': False,
            'type': 'enums.AdjustmentReason',
            'is_relational': False,
            'documentation': None,
        }),
        ('quantityBefore', {
            'name': 'quantityBefore',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('quantityAfter', {
            'name': 'quantityAfter',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('adjustmentQty', {
            'name': 'adjustmentQty',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('notes', {
            'name': 'notes',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('referenceNumber', {
            'name': 'referenceNumber',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdBy', {
            'name': 'createdBy',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('createdById', {
            'name': 'createdById',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)



# we have to import ourselves as relation types are namespaced to models
# e.g. models.Post
from . import models

# required to support relationships between models
model_rebuild(User)
model_rebuild(UserPermission)
model_rebuild(Branch)
model_rebuild(Product)
model_rebuild(Category)
model_rebuild(Stock)
model_rebuild(Customer)
model_rebuild(Sale)
model_rebuild(SaleItem)
model_rebuild(ReturnSale)
model_rebuild(ReturnItem)
model_rebuild(Payment)
model_rebuild(JournalEntry)
model_rebuild(JournalEntryLine)
model_rebuild(Account)
model_rebuild(AccountTransfer)
model_rebuild(BranchOrder)
model_rebuild(BranchOrderItem)
model_rebuild(AuditLog)
model_rebuild(SystemInfo)
model_rebuild(Backup)
model_rebuild(RevokedToken)
model_rebuild(SystemSetting)
model_rebuild(Notification)
model_rebuild(StockAdjustment)
