# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off
from __future__ import annotations

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


from typing_extensions import LiteralString
# -- template actions.py.jinja --
from typing import TypeVar
import warnings

from . import types, errors, bases
from ._compat import model_parse

if TYPE_CHECKING:
    from .client import Client
    from .bases import _PrismaModel


_PrismaModelT = TypeVar('_PrismaModelT', bound='_PrismaModel')


class UserActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.User]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await User.prisma().query_raw(
            'SELECT * FROM User WHERE id = $1',
            1103527590,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.User
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await User.prisma().query_first(
            'SELECT * FROM User WHERE username = $1',
            'dhheabfhf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UserCreateInput,
        include: Optional[types.UserInclude] = None
    ) -> _PrismaModelT:
        """Create a new User record.

        Parameters
        ----------
        data
            User record data
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The created User record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a User record from just the required fields
        user = await User.prisma().create(
            data={
                # data to create a User record
                'username': 'ggciceaie',
                'firstName': 'bbehjachib',
                'lastName': 'cadfabfehe',
                'hashedPassword': 'dgiiaaijj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UserCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple User records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of User record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await User.prisma().create_many(
            data=[
                {
                    # data to create a User record
                    'username': 'bfaiacjjfc',
                    'firstName': 'eigcfgbif',
                    'lastName': 'bagcfbhiig',
                    'hashedPassword': 'cghideieh',
                },
                {
                    # data to create a User record
                    'username': 'biabhbdai',
                    'firstName': 'idghgaicb',
                    'lastName': 'fjfddhigg',
                    'hashedPassword': 'hjaecfifb',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single User record.

        Parameters
        ----------
        where
            User filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The deleted User record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().delete(
            where={
                'id': 2111915288,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique User record.

        Parameters
        ----------
        where
            User filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The found User record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().find_unique(
            where={
                'id': 1149758321,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> _PrismaModelT:
        """Find a unique User record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            User filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The found User record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().find_unique_or_raise(
            where={
                'id': 1644289366,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple User records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of User records returned
        skip
            Ignore the first N results
        where
            User filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.User]
            The list of all User records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 User records
        users = await User.prisma().find_many(take=10)

        # find the first 5 User records ordered by the email field
        users = await User.prisma().find_many(
            take=5,
            order={
                'email': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single User record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            User filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.User
            The first User record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second User record ordered by the firstName field
        user = await User.prisma().find_first(
            skip=1,
            order={
                'firstName': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single User record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            User filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.User
            The first User record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second User record ordered by the lastName field
        user = await User.prisma().find_first_or_raise(
            skip=1,
            order={
                'lastName': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.UserUpdateInput,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single User record.

        Parameters
        ----------
        data
            User record data specifying what to update
        where
            User filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The updated User record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await User.prisma().update(
            where={
                'id': 1388290519,
            },
            data={
                # data to update the User record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.UserWhereUniqueInput,
        data: types.UserUpsertInput,
        include: Optional[types.UserInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            User filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The created or updated User record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().upsert(
            where={
                'id': 1647418052,
            },
            data={
                'create': {
                    'id': 1647418052,
                    'username': 'biabhbdai',
                    'firstName': 'idghgaicb',
                    'lastName': 'fjfddhigg',
                    'hashedPassword': 'hjaecfifb',
                },
                'update': {
                    'username': 'biabhbdai',
                    'firstName': 'idghgaicb',
                    'lastName': 'fjfddhigg',
                    'hashedPassword': 'hjaecfifb',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.UserUpdateManyMutationInput,
        where: types.UserWhereInput,
    ) -> int:
        """Update multiple User records

        Parameters
        ----------
        data
            User data to update the selected User records to
        where
            Filter to select the User records to update

        Returns
        -------
        int
            The total number of User records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all User records
        total = await User.prisma().update_many(
            data={
                'hashedPassword': 'bghffegacj'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> int:
        """Count the number of User records present in the database

        Parameters
        ----------
        select
            Select the User fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            User filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await User.prisma().count()

        # results: prisma.types.UserCountAggregateOutput
        results = await User.prisma().count(
            select={
                '_all': True,
                'role': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UserCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> types.UserCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UserCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> Union[int, types.UserCountAggregateOutput]:
        """Count the number of User records present in the database

        Parameters
        ----------
        select
            Select the User fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            User filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await User.prisma().count()

        # results: prisma.types.UserCountAggregateOutput
        results = await User.prisma().count(
            select={
                '_all': True,
                'isActive': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UserWhereInput] = None
    ) -> int:
        """Delete multiple User records.

        Parameters
        ----------
        where
            Optional User filter to find the records to be deleted

        Returns
        -------
        int
            The total number of User records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all User records
        total = await User.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UserScalarFieldKeysT'],
        *,
        where: Optional['types.UserWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserAvgAggregateInput'] = None,
        sum: Optional['types.UserSumAggregateInput'] = None,
        min: Optional['types.UserMinAggregateInput'] = None,
        max: Optional['types.UserMaxAggregateInput'] = None,
        having: Optional['types.UserScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.UserScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.UserGroupByOutput']:
        """Group User records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar User fields to group records by
        where
            User filter to select records
        take
            Limit the maximum number of User records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserGroupByOutput]
            A list of dictionaries representing the User record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group User records by branchId values
        # and count how many records are in each group
        results = await User.prisma().group_by(
            ['branchId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class UserPermissionActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.UserPermission]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await UserPermission.prisma().query_raw(
            'SELECT * FROM UserPermission WHERE id = $1',
            1767274722,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.UserPermission
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await UserPermission.prisma().query_first(
            'SELECT * FROM UserPermission WHERE userId = $1',
            326272115,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UserPermissionCreateInput,
        include: Optional[types.UserPermissionInclude] = None
    ) -> _PrismaModelT:
        """Create a new UserPermission record.

        Parameters
        ----------
        data
            UserPermission record data
        include
            Specifies which relations should be loaded on the returned UserPermission model

        Returns
        -------
        prisma.models.UserPermission
            The created UserPermission record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a UserPermission record from just the required fields
        userpermission = await UserPermission.prisma().create(
            data={
                # data to create a UserPermission record
                'userId': 1343201072,
                'resource': 'ghfhiafcb',
                'actions': Json({'heejgedji': True}),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UserPermissionCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple UserPermission records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of UserPermission record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await UserPermission.prisma().create_many(
            data=[
                {
                    # data to create a UserPermission record
                    'userId': 1969681615,
                    'resource': 'bbbgbhfjge',
                    'actions': Json({'igbehcbab': True}),
                },
                {
                    # data to create a UserPermission record
                    'userId': 1303003706,
                    'resource': 'bgiggdidbf',
                    'actions': Json({'caaaedabfc': True}),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UserPermissionWhereUniqueInput,
        include: Optional[types.UserPermissionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single UserPermission record.

        Parameters
        ----------
        where
            UserPermission filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned UserPermission model

        Returns
        -------
        prisma.models.UserPermission
            The deleted UserPermission record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userpermission = await UserPermission.prisma().delete(
            where={
                'id': 1868141281,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.UserPermissionWhereUniqueInput,
        include: Optional[types.UserPermissionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique UserPermission record.

        Parameters
        ----------
        where
            UserPermission filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserPermission model

        Returns
        -------
        prisma.models.UserPermission
            The found UserPermission record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userpermission = await UserPermission.prisma().find_unique(
            where={
                'id': 1860847622,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.UserPermissionWhereUniqueInput,
        include: Optional[types.UserPermissionInclude] = None
    ) -> _PrismaModelT:
        """Find a unique UserPermission record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            UserPermission filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserPermission model

        Returns
        -------
        prisma.models.UserPermission
            The found UserPermission record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userpermission = await UserPermission.prisma().find_unique_or_raise(
            where={
                'id': 1448521415,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserPermissionWhereInput] = None,
        cursor: Optional[types.UserPermissionWhereUniqueInput] = None,
        include: Optional[types.UserPermissionInclude] = None,
        order: Optional[Union[types.UserPermissionOrderByInput, List[types.UserPermissionOrderByInput]]] = None,
        distinct: Optional[List[types.UserPermissionScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple UserPermission records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of UserPermission records returned
        skip
            Ignore the first N results
        where
            UserPermission filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserPermission model
        order
            Order the returned UserPermission records by any field
        distinct
            Filter UserPermission records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.UserPermission]
            The list of all UserPermission records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 UserPermission records
        userpermissions = await UserPermission.prisma().find_many(take=10)

        # find the first 5 UserPermission records ordered by the resource field
        userpermissions = await UserPermission.prisma().find_many(
            take=5,
            order={
                'resource': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserPermissionWhereInput] = None,
        cursor: Optional[types.UserPermissionWhereUniqueInput] = None,
        include: Optional[types.UserPermissionInclude] = None,
        order: Optional[Union[types.UserPermissionOrderByInput, List[types.UserPermissionOrderByInput]]] = None,
        distinct: Optional[List[types.UserPermissionScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single UserPermission record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserPermission filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserPermission model
        order
            Order the returned UserPermission records by any field
        distinct
            Filter UserPermission records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserPermission
            The first UserPermission record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserPermission record ordered by the actions field
        userpermission = await UserPermission.prisma().find_first(
            skip=1,
            order={
                'actions': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserPermissionWhereInput] = None,
        cursor: Optional[types.UserPermissionWhereUniqueInput] = None,
        include: Optional[types.UserPermissionInclude] = None,
        order: Optional[Union[types.UserPermissionOrderByInput, List[types.UserPermissionOrderByInput]]] = None,
        distinct: Optional[List[types.UserPermissionScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single UserPermission record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserPermission filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserPermission model
        order
            Order the returned UserPermission records by any field
        distinct
            Filter UserPermission records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserPermission
            The first UserPermission record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserPermission record ordered by the createdAt field
        userpermission = await UserPermission.prisma().find_first_or_raise(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.UserPermissionUpdateInput,
        where: types.UserPermissionWhereUniqueInput,
        include: Optional[types.UserPermissionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single UserPermission record.

        Parameters
        ----------
        data
            UserPermission record data specifying what to update
        where
            UserPermission filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned UserPermission model

        Returns
        -------
        prisma.models.UserPermission
            The updated UserPermission record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        userpermission = await UserPermission.prisma().update(
            where={
                'id': 1628650740,
            },
            data={
                # data to update the UserPermission record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.UserPermissionWhereUniqueInput,
        data: types.UserPermissionUpsertInput,
        include: Optional[types.UserPermissionInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            UserPermission filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned UserPermission model

        Returns
        -------
        prisma.models.UserPermission
            The created or updated UserPermission record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userpermission = await UserPermission.prisma().upsert(
            where={
                'id': 1249606685,
            },
            data={
                'create': {
                    'id': 1249606685,
                    'userId': 1303003706,
                    'resource': 'bgiggdidbf',
                    'actions': Json({'caaaedabfc': True}),
                },
                'update': {
                    'userId': 1303003706,
                    'resource': 'bgiggdidbf',
                    'actions': Json({'caaaedabfc': True}),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.UserPermissionUpdateManyMutationInput,
        where: types.UserPermissionWhereInput,
    ) -> int:
        """Update multiple UserPermission records

        Parameters
        ----------
        data
            UserPermission data to update the selected UserPermission records to
        where
            Filter to select the UserPermission records to update

        Returns
        -------
        int
            The total number of UserPermission records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all UserPermission records
        total = await UserPermission.prisma().update_many(
            data={
                'updatedAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserPermissionWhereInput] = None,
        cursor: Optional[types.UserPermissionWhereUniqueInput] = None,
    ) -> int:
        """Count the number of UserPermission records present in the database

        Parameters
        ----------
        select
            Select the UserPermission fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserPermission filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserPermissionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserPermission.prisma().count()

        # results: prisma.types.UserPermissionCountAggregateOutput
        results = await UserPermission.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UserPermissionCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserPermissionWhereInput] = None,
        cursor: Optional[types.UserPermissionWhereUniqueInput] = None,
    ) -> types.UserPermissionCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UserPermissionCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserPermissionWhereInput] = None,
        cursor: Optional[types.UserPermissionWhereUniqueInput] = None,
    ) -> Union[int, types.UserPermissionCountAggregateOutput]:
        """Count the number of UserPermission records present in the database

        Parameters
        ----------
        select
            Select the UserPermission fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserPermission filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserPermissionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserPermission.prisma().count()

        # results: prisma.types.UserPermissionCountAggregateOutput
        results = await UserPermission.prisma().count(
            select={
                '_all': True,
                'userId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserPermissionCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UserPermissionWhereInput] = None
    ) -> int:
        """Delete multiple UserPermission records.

        Parameters
        ----------
        where
            Optional UserPermission filter to find the records to be deleted

        Returns
        -------
        int
            The total number of UserPermission records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all UserPermission records
        total = await UserPermission.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UserPermissionScalarFieldKeysT'],
        *,
        where: Optional['types.UserPermissionWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserPermissionAvgAggregateInput'] = None,
        sum: Optional['types.UserPermissionSumAggregateInput'] = None,
        min: Optional['types.UserPermissionMinAggregateInput'] = None,
        max: Optional['types.UserPermissionMaxAggregateInput'] = None,
        having: Optional['types.UserPermissionScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserPermissionCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserPermissionScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.UserPermissionScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.UserPermissionGroupByOutput']:
        """Group UserPermission records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar UserPermission fields to group records by
        where
            UserPermission filter to select records
        take
            Limit the maximum number of UserPermission records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserPermissionGroupByOutput]
            A list of dictionaries representing the UserPermission record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group UserPermission records by resource values
        # and count how many records are in each group
        results = await UserPermission.prisma().group_by(
            ['resource'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class BranchActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Branch]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Branch.prisma().query_raw(
            'SELECT * FROM Branch WHERE id = $1',
            835903122,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Branch
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Branch.prisma().query_first(
            'SELECT * FROM Branch WHERE name = $1',
            'hgdhbjhhj',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.BranchCreateInput,
        include: Optional[types.BranchInclude] = None
    ) -> _PrismaModelT:
        """Create a new Branch record.

        Parameters
        ----------
        data
            Branch record data
        include
            Specifies which relations should be loaded on the returned Branch model

        Returns
        -------
        prisma.models.Branch
            The created Branch record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Branch record from just the required fields
        branch = await Branch.prisma().create(
            data={
                # data to create a Branch record
                'name': 'ecjjjfbae',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.BranchCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Branch records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Branch record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Branch.prisma().create_many(
            data=[
                {
                    # data to create a Branch record
                    'name': 'bhhfibbigf',
                },
                {
                    # data to create a Branch record
                    'name': 'ijdbeffgg',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.BranchWhereUniqueInput,
        include: Optional[types.BranchInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Branch record.

        Parameters
        ----------
        where
            Branch filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Branch model

        Returns
        -------
        prisma.models.Branch
            The deleted Branch record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        branch = await Branch.prisma().delete(
            where={
                'id': 995405759,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.BranchWhereUniqueInput,
        include: Optional[types.BranchInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Branch record.

        Parameters
        ----------
        where
            Branch filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Branch model

        Returns
        -------
        prisma.models.Branch
            The found Branch record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        branch = await Branch.prisma().find_unique(
            where={
                'id': 2102736524,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.BranchWhereUniqueInput,
        include: Optional[types.BranchInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Branch record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Branch filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Branch model

        Returns
        -------
        prisma.models.Branch
            The found Branch record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        branch = await Branch.prisma().find_unique_or_raise(
            where={
                'id': 271520213,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BranchWhereInput] = None,
        cursor: Optional[types.BranchWhereUniqueInput] = None,
        include: Optional[types.BranchInclude] = None,
        order: Optional[Union[types.BranchOrderByInput, List[types.BranchOrderByInput]]] = None,
        distinct: Optional[List[types.BranchScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Branch records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Branch records returned
        skip
            Ignore the first N results
        where
            Branch filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Branch model
        order
            Order the returned Branch records by any field
        distinct
            Filter Branch records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Branch]
            The list of all Branch records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Branch records
        branchs = await Branch.prisma().find_many(take=10)

        # find the first 5 Branch records ordered by the address field
        branchs = await Branch.prisma().find_many(
            take=5,
            order={
                'address': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.BranchWhereInput] = None,
        cursor: Optional[types.BranchWhereUniqueInput] = None,
        include: Optional[types.BranchInclude] = None,
        order: Optional[Union[types.BranchOrderByInput, List[types.BranchOrderByInput]]] = None,
        distinct: Optional[List[types.BranchScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Branch record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Branch filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Branch model
        order
            Order the returned Branch records by any field
        distinct
            Filter Branch records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Branch
            The first Branch record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Branch record ordered by the phone field
        branch = await Branch.prisma().find_first(
            skip=1,
            order={
                'phone': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.BranchWhereInput] = None,
        cursor: Optional[types.BranchWhereUniqueInput] = None,
        include: Optional[types.BranchInclude] = None,
        order: Optional[Union[types.BranchOrderByInput, List[types.BranchOrderByInput]]] = None,
        distinct: Optional[List[types.BranchScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Branch record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Branch filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Branch model
        order
            Order the returned Branch records by any field
        distinct
            Filter Branch records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Branch
            The first Branch record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Branch record ordered by the isActive field
        branch = await Branch.prisma().find_first_or_raise(
            skip=1,
            order={
                'isActive': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.BranchUpdateInput,
        where: types.BranchWhereUniqueInput,
        include: Optional[types.BranchInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Branch record.

        Parameters
        ----------
        data
            Branch record data specifying what to update
        where
            Branch filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Branch model

        Returns
        -------
        prisma.models.Branch
            The updated Branch record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        branch = await Branch.prisma().update(
            where={
                'id': 456633834,
            },
            data={
                # data to update the Branch record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.BranchWhereUniqueInput,
        data: types.BranchUpsertInput,
        include: Optional[types.BranchInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Branch filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Branch model

        Returns
        -------
        prisma.models.Branch
            The created or updated Branch record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        branch = await Branch.prisma().upsert(
            where={
                'id': 2058258651,
            },
            data={
                'create': {
                    'id': 2058258651,
                    'name': 'ijdbeffgg',
                },
                'update': {
                    'name': 'ijdbeffgg',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.BranchUpdateManyMutationInput,
        where: types.BranchWhereInput,
    ) -> int:
        """Update multiple Branch records

        Parameters
        ----------
        data
            Branch data to update the selected Branch records to
        where
            Filter to select the Branch records to update

        Returns
        -------
        int
            The total number of Branch records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Branch records
        total = await Branch.prisma().update_many(
            data={
                'createdAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BranchWhereInput] = None,
        cursor: Optional[types.BranchWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Branch records present in the database

        Parameters
        ----------
        select
            Select the Branch fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Branch filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.BranchCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Branch.prisma().count()

        # results: prisma.types.BranchCountAggregateOutput
        results = await Branch.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.BranchCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BranchWhereInput] = None,
        cursor: Optional[types.BranchWhereUniqueInput] = None,
    ) -> types.BranchCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.BranchCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BranchWhereInput] = None,
        cursor: Optional[types.BranchWhereUniqueInput] = None,
    ) -> Union[int, types.BranchCountAggregateOutput]:
        """Count the number of Branch records present in the database

        Parameters
        ----------
        select
            Select the Branch fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Branch filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.BranchCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Branch.prisma().count()

        # results: prisma.types.BranchCountAggregateOutput
        results = await Branch.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.BranchCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.BranchWhereInput] = None
    ) -> int:
        """Delete multiple Branch records.

        Parameters
        ----------
        where
            Optional Branch filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Branch records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Branch records
        total = await Branch.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.BranchScalarFieldKeysT'],
        *,
        where: Optional['types.BranchWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.BranchAvgAggregateInput'] = None,
        sum: Optional['types.BranchSumAggregateInput'] = None,
        min: Optional['types.BranchMinAggregateInput'] = None,
        max: Optional['types.BranchMaxAggregateInput'] = None,
        having: Optional['types.BranchScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.BranchCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.BranchScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.BranchScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.BranchGroupByOutput']:
        """Group Branch records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Branch fields to group records by
        where
            Branch filter to select records
        take
            Limit the maximum number of Branch records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.BranchGroupByOutput]
            A list of dictionaries representing the Branch record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Branch records by name values
        # and count how many records are in each group
        results = await Branch.prisma().group_by(
            ['name'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ProductActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Product]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Product.prisma().query_raw(
            'SELECT * FROM Product WHERE id = $1',
            1583689592,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Product
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Product.prisma().query_first(
            'SELECT * FROM Product WHERE sku = $1',
            'ihieecagf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ProductCreateInput,
        include: Optional[types.ProductInclude] = None
    ) -> _PrismaModelT:
        """Create a new Product record.

        Parameters
        ----------
        data
            Product record data
        include
            Specifies which relations should be loaded on the returned Product model

        Returns
        -------
        prisma.models.Product
            The created Product record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Product record from just the required fields
        product = await Product.prisma().create(
            data={
                # data to create a Product record
                'sku': 'bghfciaafe',
                'name': 'bgchfhgceh',
                'costPrice': Decimal('2054802212.6033'),
                'sellingPrice': Decimal('684462146.162550'),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ProductCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Product records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Product record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Product.prisma().create_many(
            data=[
                {
                    # data to create a Product record
                    'sku': 'fcbichhci',
                    'name': 'bcggadccgf',
                    'costPrice': Decimal('93253262.205304'),
                    'sellingPrice': Decimal('685333180.12747'),
                },
                {
                    # data to create a Product record
                    'sku': 'jeijcbhfe',
                    'name': 'bjgejjabff',
                    'costPrice': Decimal('1228891816.25520'),
                    'sellingPrice': Decimal('1223573862.54126'),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ProductWhereUniqueInput,
        include: Optional[types.ProductInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Product record.

        Parameters
        ----------
        where
            Product filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Product model

        Returns
        -------
        prisma.models.Product
            The deleted Product record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        product = await Product.prisma().delete(
            where={
                'id': 1064846676,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ProductWhereUniqueInput,
        include: Optional[types.ProductInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Product record.

        Parameters
        ----------
        where
            Product filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Product model

        Returns
        -------
        prisma.models.Product
            The found Product record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        product = await Product.prisma().find_unique(
            where={
                'id': 508382461,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ProductWhereUniqueInput,
        include: Optional[types.ProductInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Product record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Product filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Product model

        Returns
        -------
        prisma.models.Product
            The found Product record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        product = await Product.prisma().find_unique_or_raise(
            where={
                'id': 1024265714,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProductWhereInput] = None,
        cursor: Optional[types.ProductWhereUniqueInput] = None,
        include: Optional[types.ProductInclude] = None,
        order: Optional[Union[types.ProductOrderByInput, List[types.ProductOrderByInput]]] = None,
        distinct: Optional[List[types.ProductScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Product records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Product records returned
        skip
            Ignore the first N results
        where
            Product filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Product model
        order
            Order the returned Product records by any field
        distinct
            Filter Product records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Product]
            The list of all Product records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Product records
        products = await Product.prisma().find_many(take=10)

        # find the first 5 Product records ordered by the name field
        products = await Product.prisma().find_many(
            take=5,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ProductWhereInput] = None,
        cursor: Optional[types.ProductWhereUniqueInput] = None,
        include: Optional[types.ProductInclude] = None,
        order: Optional[Union[types.ProductOrderByInput, List[types.ProductOrderByInput]]] = None,
        distinct: Optional[List[types.ProductScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Product record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Product filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Product model
        order
            Order the returned Product records by any field
        distinct
            Filter Product records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Product
            The first Product record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Product record ordered by the barcode field
        product = await Product.prisma().find_first(
            skip=1,
            order={
                'barcode': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ProductWhereInput] = None,
        cursor: Optional[types.ProductWhereUniqueInput] = None,
        include: Optional[types.ProductInclude] = None,
        order: Optional[Union[types.ProductOrderByInput, List[types.ProductOrderByInput]]] = None,
        distinct: Optional[List[types.ProductScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Product record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Product filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Product model
        order
            Order the returned Product records by any field
        distinct
            Filter Product records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Product
            The first Product record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Product record ordered by the description field
        product = await Product.prisma().find_first_or_raise(
            skip=1,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ProductUpdateInput,
        where: types.ProductWhereUniqueInput,
        include: Optional[types.ProductInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Product record.

        Parameters
        ----------
        data
            Product record data specifying what to update
        where
            Product filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Product model

        Returns
        -------
        prisma.models.Product
            The updated Product record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        product = await Product.prisma().update(
            where={
                'id': 872078403,
            },
            data={
                # data to update the Product record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ProductWhereUniqueInput,
        data: types.ProductUpsertInput,
        include: Optional[types.ProductInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Product filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Product model

        Returns
        -------
        prisma.models.Product
            The created or updated Product record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        product = await Product.prisma().upsert(
            where={
                'id': 1874748096,
            },
            data={
                'create': {
                    'id': 1874748096,
                    'sku': 'jeijcbhfe',
                    'name': 'bjgejjabff',
                    'costPrice': Decimal('1228891816.25520'),
                    'sellingPrice': Decimal('1223573862.54126'),
                },
                'update': {
                    'sku': 'jeijcbhfe',
                    'name': 'bjgejjabff',
                    'costPrice': Decimal('1228891816.25520'),
                    'sellingPrice': Decimal('1223573862.54126'),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ProductUpdateManyMutationInput,
        where: types.ProductWhereInput,
    ) -> int:
        """Update multiple Product records

        Parameters
        ----------
        data
            Product data to update the selected Product records to
        where
            Filter to select the Product records to update

        Returns
        -------
        int
            The total number of Product records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Product records
        total = await Product.prisma().update_many(
            data={
                'costPrice': Decimal('916896761.76926')
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProductWhereInput] = None,
        cursor: Optional[types.ProductWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Product records present in the database

        Parameters
        ----------
        select
            Select the Product fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Product filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ProductCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Product.prisma().count()

        # results: prisma.types.ProductCountAggregateOutput
        results = await Product.prisma().count(
            select={
                '_all': True,
                'sellingPrice': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ProductCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProductWhereInput] = None,
        cursor: Optional[types.ProductWhereUniqueInput] = None,
    ) -> types.ProductCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ProductCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProductWhereInput] = None,
        cursor: Optional[types.ProductWhereUniqueInput] = None,
    ) -> Union[int, types.ProductCountAggregateOutput]:
        """Count the number of Product records present in the database

        Parameters
        ----------
        select
            Select the Product fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Product filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ProductCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Product.prisma().count()

        # results: prisma.types.ProductCountAggregateOutput
        results = await Product.prisma().count(
            select={
                '_all': True,
                'categoryId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ProductCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ProductWhereInput] = None
    ) -> int:
        """Delete multiple Product records.

        Parameters
        ----------
        where
            Optional Product filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Product records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Product records
        total = await Product.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ProductScalarFieldKeysT'],
        *,
        where: Optional['types.ProductWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ProductAvgAggregateInput'] = None,
        sum: Optional['types.ProductSumAggregateInput'] = None,
        min: Optional['types.ProductMinAggregateInput'] = None,
        max: Optional['types.ProductMaxAggregateInput'] = None,
        having: Optional['types.ProductScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ProductCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ProductScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.ProductScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.ProductGroupByOutput']:
        """Group Product records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Product fields to group records by
        where
            Product filter to select records
        take
            Limit the maximum number of Product records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ProductGroupByOutput]
            A list of dictionaries representing the Product record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Product records by createdAt values
        # and count how many records are in each group
        results = await Product.prisma().group_by(
            ['createdAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class CategoryActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Category]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Category.prisma().query_raw(
            'SELECT * FROM Category WHERE id = $1',
            820312479,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Category
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Category.prisma().query_first(
            'SELECT * FROM Category WHERE name = $1',
            'jchciaee',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.CategoryCreateInput,
        include: Optional[types.CategoryInclude] = None
    ) -> _PrismaModelT:
        """Create a new Category record.

        Parameters
        ----------
        data
            Category record data
        include
            Specifies which relations should be loaded on the returned Category model

        Returns
        -------
        prisma.models.Category
            The created Category record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Category record from just the required fields
        category = await Category.prisma().create(
            data={
                # data to create a Category record
                'name': 'deeificjd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.CategoryCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Category records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Category record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Category.prisma().create_many(
            data=[
                {
                    # data to create a Category record
                    'name': 'bbcbhebbda',
                },
                {
                    # data to create a Category record
                    'name': 'bejfijgcfb',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.CategoryWhereUniqueInput,
        include: Optional[types.CategoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Category record.

        Parameters
        ----------
        where
            Category filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Category model

        Returns
        -------
        prisma.models.Category
            The deleted Category record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        category = await Category.prisma().delete(
            where={
                'id': 208521688,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.CategoryWhereUniqueInput,
        include: Optional[types.CategoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Category record.

        Parameters
        ----------
        where
            Category filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Category model

        Returns
        -------
        prisma.models.Category
            The found Category record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        category = await Category.prisma().find_unique(
            where={
                'id': 860811569,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.CategoryWhereUniqueInput,
        include: Optional[types.CategoryInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Category record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Category filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Category model

        Returns
        -------
        prisma.models.Category
            The found Category record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        category = await Category.prisma().find_unique_or_raise(
            where={
                'id': 1660932118,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CategoryWhereInput] = None,
        cursor: Optional[types.CategoryWhereUniqueInput] = None,
        include: Optional[types.CategoryInclude] = None,
        order: Optional[Union[types.CategoryOrderByInput, List[types.CategoryOrderByInput]]] = None,
        distinct: Optional[List[types.CategoryScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Category records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Category records returned
        skip
            Ignore the first N results
        where
            Category filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Category model
        order
            Order the returned Category records by any field
        distinct
            Filter Category records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Category]
            The list of all Category records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Category records
        categorys = await Category.prisma().find_many(take=10)

        # find the first 5 Category records ordered by the description field
        categorys = await Category.prisma().find_many(
            take=5,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CategoryWhereInput] = None,
        cursor: Optional[types.CategoryWhereUniqueInput] = None,
        include: Optional[types.CategoryInclude] = None,
        order: Optional[Union[types.CategoryOrderByInput, List[types.CategoryOrderByInput]]] = None,
        distinct: Optional[List[types.CategoryScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Category record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Category filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Category model
        order
            Order the returned Category records by any field
        distinct
            Filter Category records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Category
            The first Category record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Category record ordered by the status field
        category = await Category.prisma().find_first(
            skip=1,
            order={
                'status': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CategoryWhereInput] = None,
        cursor: Optional[types.CategoryWhereUniqueInput] = None,
        include: Optional[types.CategoryInclude] = None,
        order: Optional[Union[types.CategoryOrderByInput, List[types.CategoryOrderByInput]]] = None,
        distinct: Optional[List[types.CategoryScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Category record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Category filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Category model
        order
            Order the returned Category records by any field
        distinct
            Filter Category records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Category
            The first Category record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Category record ordered by the createdAt field
        category = await Category.prisma().find_first_or_raise(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.CategoryUpdateInput,
        where: types.CategoryWhereUniqueInput,
        include: Optional[types.CategoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Category record.

        Parameters
        ----------
        data
            Category record data specifying what to update
        where
            Category filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Category model

        Returns
        -------
        prisma.models.Category
            The updated Category record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        category = await Category.prisma().update(
            where={
                'id': 525761943,
            },
            data={
                # data to update the Category record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.CategoryWhereUniqueInput,
        data: types.CategoryUpsertInput,
        include: Optional[types.CategoryInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Category filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Category model

        Returns
        -------
        prisma.models.Category
            The created or updated Category record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        category = await Category.prisma().upsert(
            where={
                'id': 736209796,
            },
            data={
                'create': {
                    'id': 736209796,
                    'name': 'bejfijgcfb',
                },
                'update': {
                    'name': 'bejfijgcfb',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.CategoryUpdateManyMutationInput,
        where: types.CategoryWhereInput,
    ) -> int:
        """Update multiple Category records

        Parameters
        ----------
        data
            Category data to update the selected Category records to
        where
            Filter to select the Category records to update

        Returns
        -------
        int
            The total number of Category records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Category records
        total = await Category.prisma().update_many(
            data={
                'updatedAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CategoryWhereInput] = None,
        cursor: Optional[types.CategoryWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Category records present in the database

        Parameters
        ----------
        select
            Select the Category fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Category filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CategoryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Category.prisma().count()

        # results: prisma.types.CategoryCountAggregateOutput
        results = await Category.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.CategoryCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CategoryWhereInput] = None,
        cursor: Optional[types.CategoryWhereUniqueInput] = None,
    ) -> types.CategoryCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.CategoryCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CategoryWhereInput] = None,
        cursor: Optional[types.CategoryWhereUniqueInput] = None,
    ) -> Union[int, types.CategoryCountAggregateOutput]:
        """Count the number of Category records present in the database

        Parameters
        ----------
        select
            Select the Category fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Category filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CategoryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Category.prisma().count()

        # results: prisma.types.CategoryCountAggregateOutput
        results = await Category.prisma().count(
            select={
                '_all': True,
                'name': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.CategoryCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.CategoryWhereInput] = None
    ) -> int:
        """Delete multiple Category records.

        Parameters
        ----------
        where
            Optional Category filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Category records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Category records
        total = await Category.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.CategoryScalarFieldKeysT'],
        *,
        where: Optional['types.CategoryWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.CategoryAvgAggregateInput'] = None,
        sum: Optional['types.CategorySumAggregateInput'] = None,
        min: Optional['types.CategoryMinAggregateInput'] = None,
        max: Optional['types.CategoryMaxAggregateInput'] = None,
        having: Optional['types.CategoryScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.CategoryCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.CategoryScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.CategoryScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.CategoryGroupByOutput']:
        """Group Category records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Category fields to group records by
        where
            Category filter to select records
        take
            Limit the maximum number of Category records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.CategoryGroupByOutput]
            A list of dictionaries representing the Category record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Category records by description values
        # and count how many records are in each group
        results = await Category.prisma().group_by(
            ['description'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class StockActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Stock]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Stock.prisma().query_raw(
            'SELECT * FROM Stock WHERE id = $1',
            493907821,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Stock
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Stock.prisma().query_first(
            'SELECT * FROM Stock WHERE productId = $1',
            639686562,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.StockCreateInput,
        include: Optional[types.StockInclude] = None
    ) -> _PrismaModelT:
        """Create a new Stock record.

        Parameters
        ----------
        data
            Stock record data
        include
            Specifies which relations should be loaded on the returned Stock model

        Returns
        -------
        prisma.models.Stock
            The created Stock record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Stock record from just the required fields
        stock = await Stock.prisma().create(
            data={
                # data to create a Stock record
                'productId': 654007347,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.StockCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Stock records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Stock record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Stock.prisma().create_many(
            data=[
                {
                    # data to create a Stock record
                    'productId': 1905261552,
                },
                {
                    # data to create a Stock record
                    'productId': 78746985,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.StockWhereUniqueInput,
        include: Optional[types.StockInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Stock record.

        Parameters
        ----------
        where
            Stock filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Stock model

        Returns
        -------
        prisma.models.Stock
            The deleted Stock record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        stock = await Stock.prisma().delete(
            where={
                'id': 1398328302,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.StockWhereUniqueInput,
        include: Optional[types.StockInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Stock record.

        Parameters
        ----------
        where
            Stock filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Stock model

        Returns
        -------
        prisma.models.Stock
            The found Stock record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        stock = await Stock.prisma().find_unique(
            where={
                'id': 856000655,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.StockWhereUniqueInput,
        include: Optional[types.StockInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Stock record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Stock filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Stock model

        Returns
        -------
        prisma.models.Stock
            The found Stock record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        stock = await Stock.prisma().find_unique_or_raise(
            where={
                'id': 1452336924,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.StockWhereInput] = None,
        cursor: Optional[types.StockWhereUniqueInput] = None,
        include: Optional[types.StockInclude] = None,
        order: Optional[Union[types.StockOrderByInput, List[types.StockOrderByInput]]] = None,
        distinct: Optional[List[types.StockScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Stock records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Stock records returned
        skip
            Ignore the first N results
        where
            Stock filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Stock model
        order
            Order the returned Stock records by any field
        distinct
            Filter Stock records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Stock]
            The list of all Stock records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Stock records
        stocks = await Stock.prisma().find_many(take=10)

        # find the first 5 Stock records ordered by the quantity field
        stocks = await Stock.prisma().find_many(
            take=5,
            order={
                'quantity': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.StockWhereInput] = None,
        cursor: Optional[types.StockWhereUniqueInput] = None,
        include: Optional[types.StockInclude] = None,
        order: Optional[Union[types.StockOrderByInput, List[types.StockOrderByInput]]] = None,
        distinct: Optional[List[types.StockScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Stock record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Stock filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Stock model
        order
            Order the returned Stock records by any field
        distinct
            Filter Stock records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Stock
            The first Stock record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Stock record ordered by the lastRestocked field
        stock = await Stock.prisma().find_first(
            skip=1,
            order={
                'lastRestocked': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.StockWhereInput] = None,
        cursor: Optional[types.StockWhereUniqueInput] = None,
        include: Optional[types.StockInclude] = None,
        order: Optional[Union[types.StockOrderByInput, List[types.StockOrderByInput]]] = None,
        distinct: Optional[List[types.StockScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Stock record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Stock filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Stock model
        order
            Order the returned Stock records by any field
        distinct
            Filter Stock records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Stock
            The first Stock record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Stock record ordered by the createdAt field
        stock = await Stock.prisma().find_first_or_raise(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.StockUpdateInput,
        where: types.StockWhereUniqueInput,
        include: Optional[types.StockInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Stock record.

        Parameters
        ----------
        data
            Stock record data specifying what to update
        where
            Stock filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Stock model

        Returns
        -------
        prisma.models.Stock
            The updated Stock record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        stock = await Stock.prisma().update(
            where={
                'id': 1573199653,
            },
            data={
                # data to update the Stock record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.StockWhereUniqueInput,
        data: types.StockUpsertInput,
        include: Optional[types.StockInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Stock filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Stock model

        Returns
        -------
        prisma.models.Stock
            The created or updated Stock record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        stock = await Stock.prisma().upsert(
            where={
                'id': 2013903098,
            },
            data={
                'create': {
                    'id': 2013903098,
                    'productId': 78746985,
                },
                'update': {
                    'productId': 78746985,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.StockUpdateManyMutationInput,
        where: types.StockWhereInput,
    ) -> int:
        """Update multiple Stock records

        Parameters
        ----------
        data
            Stock data to update the selected Stock records to
        where
            Filter to select the Stock records to update

        Returns
        -------
        int
            The total number of Stock records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Stock records
        total = await Stock.prisma().update_many(
            data={
                'updatedAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.StockWhereInput] = None,
        cursor: Optional[types.StockWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Stock records present in the database

        Parameters
        ----------
        select
            Select the Stock fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Stock filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.StockCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Stock.prisma().count()

        # results: prisma.types.StockCountAggregateOutput
        results = await Stock.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.StockCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.StockWhereInput] = None,
        cursor: Optional[types.StockWhereUniqueInput] = None,
    ) -> types.StockCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.StockCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.StockWhereInput] = None,
        cursor: Optional[types.StockWhereUniqueInput] = None,
    ) -> Union[int, types.StockCountAggregateOutput]:
        """Count the number of Stock records present in the database

        Parameters
        ----------
        select
            Select the Stock fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Stock filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.StockCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Stock.prisma().count()

        # results: prisma.types.StockCountAggregateOutput
        results = await Stock.prisma().count(
            select={
                '_all': True,
                'productId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.StockCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.StockWhereInput] = None
    ) -> int:
        """Delete multiple Stock records.

        Parameters
        ----------
        where
            Optional Stock filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Stock records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Stock records
        total = await Stock.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.StockScalarFieldKeysT'],
        *,
        where: Optional['types.StockWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.StockAvgAggregateInput'] = None,
        sum: Optional['types.StockSumAggregateInput'] = None,
        min: Optional['types.StockMinAggregateInput'] = None,
        max: Optional['types.StockMaxAggregateInput'] = None,
        having: Optional['types.StockScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.StockCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.StockScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.StockScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.StockGroupByOutput']:
        """Group Stock records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Stock fields to group records by
        where
            Stock filter to select records
        take
            Limit the maximum number of Stock records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.StockGroupByOutput]
            A list of dictionaries representing the Stock record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Stock records by quantity values
        # and count how many records are in each group
        results = await Stock.prisma().group_by(
            ['quantity'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class CustomerActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Customer]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Customer.prisma().query_raw(
            'SELECT * FROM Customer WHERE id = $1',
            500965035,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Customer
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Customer.prisma().query_first(
            'SELECT * FROM Customer WHERE name = $1',
            'biaagcedjc',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.CustomerCreateInput,
        include: Optional[types.CustomerInclude] = None
    ) -> _PrismaModelT:
        """Create a new Customer record.

        Parameters
        ----------
        data
            Customer record data
        include
            Specifies which relations should be loaded on the returned Customer model

        Returns
        -------
        prisma.models.Customer
            The created Customer record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Customer record from just the required fields
        customer = await Customer.prisma().create(
            data={
                # data to create a Customer record
                'name': 'cahhaghecf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.CustomerCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Customer records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Customer record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Customer.prisma().create_many(
            data=[
                {
                    # data to create a Customer record
                    'name': 'bghcbbcidi',
                },
                {
                    # data to create a Customer record
                    'name': 'jcgghhgdj',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.CustomerWhereUniqueInput,
        include: Optional[types.CustomerInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Customer record.

        Parameters
        ----------
        where
            Customer filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Customer model

        Returns
        -------
        prisma.models.Customer
            The deleted Customer record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        customer = await Customer.prisma().delete(
            where={
                'id': 1447624116,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.CustomerWhereUniqueInput,
        include: Optional[types.CustomerInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Customer record.

        Parameters
        ----------
        where
            Customer filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Customer model

        Returns
        -------
        prisma.models.Customer
            The found Customer record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        customer = await Customer.prisma().find_unique(
            where={
                'id': 1738083805,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.CustomerWhereUniqueInput,
        include: Optional[types.CustomerInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Customer record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Customer filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Customer model

        Returns
        -------
        prisma.models.Customer
            The found Customer record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        customer = await Customer.prisma().find_unique_or_raise(
            where={
                'id': 340946258,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CustomerWhereInput] = None,
        cursor: Optional[types.CustomerWhereUniqueInput] = None,
        include: Optional[types.CustomerInclude] = None,
        order: Optional[Union[types.CustomerOrderByInput, List[types.CustomerOrderByInput]]] = None,
        distinct: Optional[List[types.CustomerScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Customer records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Customer records returned
        skip
            Ignore the first N results
        where
            Customer filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Customer model
        order
            Order the returned Customer records by any field
        distinct
            Filter Customer records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Customer]
            The list of all Customer records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Customer records
        customers = await Customer.prisma().find_many(take=10)

        # find the first 5 Customer records ordered by the email field
        customers = await Customer.prisma().find_many(
            take=5,
            order={
                'email': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CustomerWhereInput] = None,
        cursor: Optional[types.CustomerWhereUniqueInput] = None,
        include: Optional[types.CustomerInclude] = None,
        order: Optional[Union[types.CustomerOrderByInput, List[types.CustomerOrderByInput]]] = None,
        distinct: Optional[List[types.CustomerScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Customer record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Customer filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Customer model
        order
            Order the returned Customer records by any field
        distinct
            Filter Customer records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Customer
            The first Customer record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Customer record ordered by the phone field
        customer = await Customer.prisma().find_first(
            skip=1,
            order={
                'phone': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CustomerWhereInput] = None,
        cursor: Optional[types.CustomerWhereUniqueInput] = None,
        include: Optional[types.CustomerInclude] = None,
        order: Optional[Union[types.CustomerOrderByInput, List[types.CustomerOrderByInput]]] = None,
        distinct: Optional[List[types.CustomerScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Customer record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Customer filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Customer model
        order
            Order the returned Customer records by any field
        distinct
            Filter Customer records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Customer
            The first Customer record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Customer record ordered by the address field
        customer = await Customer.prisma().find_first_or_raise(
            skip=1,
            order={
                'address': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.CustomerUpdateInput,
        where: types.CustomerWhereUniqueInput,
        include: Optional[types.CustomerInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Customer record.

        Parameters
        ----------
        data
            Customer record data specifying what to update
        where
            Customer filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Customer model

        Returns
        -------
        prisma.models.Customer
            The updated Customer record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        customer = await Customer.prisma().update(
            where={
                'id': 601077795,
            },
            data={
                # data to update the Customer record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.CustomerWhereUniqueInput,
        data: types.CustomerUpsertInput,
        include: Optional[types.CustomerInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Customer filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Customer model

        Returns
        -------
        prisma.models.Customer
            The created or updated Customer record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        customer = await Customer.prisma().upsert(
            where={
                'id': 290603296,
            },
            data={
                'create': {
                    'id': 290603296,
                    'name': 'jcgghhgdj',
                },
                'update': {
                    'name': 'jcgghhgdj',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.CustomerUpdateManyMutationInput,
        where: types.CustomerWhereInput,
    ) -> int:
        """Update multiple Customer records

        Parameters
        ----------
        data
            Customer data to update the selected Customer records to
        where
            Filter to select the Customer records to update

        Returns
        -------
        int
            The total number of Customer records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Customer records
        total = await Customer.prisma().update_many(
            data={
                'type': enums.CustomerType.INDIVIDUAL
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CustomerWhereInput] = None,
        cursor: Optional[types.CustomerWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Customer records present in the database

        Parameters
        ----------
        select
            Select the Customer fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Customer filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CustomerCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Customer.prisma().count()

        # results: prisma.types.CustomerCountAggregateOutput
        results = await Customer.prisma().count(
            select={
                '_all': True,
                'creditLimit': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.CustomerCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CustomerWhereInput] = None,
        cursor: Optional[types.CustomerWhereUniqueInput] = None,
    ) -> types.CustomerCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.CustomerCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CustomerWhereInput] = None,
        cursor: Optional[types.CustomerWhereUniqueInput] = None,
    ) -> Union[int, types.CustomerCountAggregateOutput]:
        """Count the number of Customer records present in the database

        Parameters
        ----------
        select
            Select the Customer fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Customer filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CustomerCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Customer.prisma().count()

        # results: prisma.types.CustomerCountAggregateOutput
        results = await Customer.prisma().count(
            select={
                '_all': True,
                'balance': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.CustomerCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.CustomerWhereInput] = None
    ) -> int:
        """Delete multiple Customer records.

        Parameters
        ----------
        where
            Optional Customer filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Customer records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Customer records
        total = await Customer.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.CustomerScalarFieldKeysT'],
        *,
        where: Optional['types.CustomerWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.CustomerAvgAggregateInput'] = None,
        sum: Optional['types.CustomerSumAggregateInput'] = None,
        min: Optional['types.CustomerMinAggregateInput'] = None,
        max: Optional['types.CustomerMaxAggregateInput'] = None,
        having: Optional['types.CustomerScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.CustomerCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.CustomerScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.CustomerScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.CustomerGroupByOutput']:
        """Group Customer records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Customer fields to group records by
        where
            Customer filter to select records
        take
            Limit the maximum number of Customer records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.CustomerGroupByOutput]
            A list of dictionaries representing the Customer record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Customer records by totalPurchases values
        # and count how many records are in each group
        results = await Customer.prisma().group_by(
            ['totalPurchases'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class SaleActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Sale]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Sale.prisma().query_raw(
            'SELECT * FROM Sale WHERE id = $1',
            1855826649,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Sale
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Sale.prisma().query_first(
            'SELECT * FROM Sale WHERE branchId = $1',
            1611009182,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.SaleCreateInput,
        include: Optional[types.SaleInclude] = None
    ) -> _PrismaModelT:
        """Create a new Sale record.

        Parameters
        ----------
        data
            Sale record data
        include
            Specifies which relations should be loaded on the returned Sale model

        Returns
        -------
        prisma.models.Sale
            The created Sale record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Sale record from just the required fields
        sale = await Sale.prisma().create(
            data={
                # data to create a Sale record
                'branchId': 446673791,
                'totalAmount': Decimal('300568396.63262'),
                'userId': 1724011690,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.SaleCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Sale records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Sale record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Sale.prisma().create_many(
            data=[
                {
                    # data to create a Sale record
                    'branchId': 470157467,
                    'totalAmount': Decimal('1209209912.153674'),
                    'userId': 424218998,
                },
                {
                    # data to create a Sale record
                    'branchId': 2125632375,
                    'totalAmount': Decimal('536951780.92472'),
                    'userId': 1621937922,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.SaleWhereUniqueInput,
        include: Optional[types.SaleInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Sale record.

        Parameters
        ----------
        where
            Sale filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Sale model

        Returns
        -------
        prisma.models.Sale
            The deleted Sale record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        sale = await Sale.prisma().delete(
            where={
                'id': 1848832019,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.SaleWhereUniqueInput,
        include: Optional[types.SaleInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Sale record.

        Parameters
        ----------
        where
            Sale filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Sale model

        Returns
        -------
        prisma.models.Sale
            The found Sale record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        sale = await Sale.prisma().find_unique(
            where={
                'id': 1921528400,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.SaleWhereUniqueInput,
        include: Optional[types.SaleInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Sale record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Sale filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Sale model

        Returns
        -------
        prisma.models.Sale
            The found Sale record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        sale = await Sale.prisma().find_unique_or_raise(
            where={
                'id': 2100427849,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SaleWhereInput] = None,
        cursor: Optional[types.SaleWhereUniqueInput] = None,
        include: Optional[types.SaleInclude] = None,
        order: Optional[Union[types.SaleOrderByInput, List[types.SaleOrderByInput]]] = None,
        distinct: Optional[List[types.SaleScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Sale records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Sale records returned
        skip
            Ignore the first N results
        where
            Sale filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Sale model
        order
            Order the returned Sale records by any field
        distinct
            Filter Sale records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Sale]
            The list of all Sale records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Sale records
        sales = await Sale.prisma().find_many(take=10)

        # find the first 5 Sale records ordered by the totalAmount field
        sales = await Sale.prisma().find_many(
            take=5,
            order={
                'totalAmount': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SaleWhereInput] = None,
        cursor: Optional[types.SaleWhereUniqueInput] = None,
        include: Optional[types.SaleInclude] = None,
        order: Optional[Union[types.SaleOrderByInput, List[types.SaleOrderByInput]]] = None,
        distinct: Optional[List[types.SaleScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Sale record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Sale filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Sale model
        order
            Order the returned Sale records by any field
        distinct
            Filter Sale records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Sale
            The first Sale record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Sale record ordered by the discount field
        sale = await Sale.prisma().find_first(
            skip=1,
            order={
                'discount': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SaleWhereInput] = None,
        cursor: Optional[types.SaleWhereUniqueInput] = None,
        include: Optional[types.SaleInclude] = None,
        order: Optional[Union[types.SaleOrderByInput, List[types.SaleOrderByInput]]] = None,
        distinct: Optional[List[types.SaleScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Sale record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Sale filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Sale model
        order
            Order the returned Sale records by any field
        distinct
            Filter Sale records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Sale
            The first Sale record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Sale record ordered by the paymentType field
        sale = await Sale.prisma().find_first_or_raise(
            skip=1,
            order={
                'paymentType': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.SaleUpdateInput,
        where: types.SaleWhereUniqueInput,
        include: Optional[types.SaleInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Sale record.

        Parameters
        ----------
        data
            Sale record data specifying what to update
        where
            Sale filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Sale model

        Returns
        -------
        prisma.models.Sale
            The updated Sale record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        sale = await Sale.prisma().update(
            where={
                'id': 849140046,
            },
            data={
                # data to update the Sale record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.SaleWhereUniqueInput,
        data: types.SaleUpsertInput,
        include: Optional[types.SaleInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Sale filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Sale model

        Returns
        -------
        prisma.models.Sale
            The created or updated Sale record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        sale = await Sale.prisma().upsert(
            where={
                'id': 928152175,
            },
            data={
                'create': {
                    'id': 928152175,
                    'branchId': 2125632375,
                    'totalAmount': Decimal('536951780.92472'),
                    'userId': 1621937922,
                },
                'update': {
                    'branchId': 2125632375,
                    'totalAmount': Decimal('536951780.92472'),
                    'userId': 1621937922,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.SaleUpdateManyMutationInput,
        where: types.SaleWhereInput,
    ) -> int:
        """Update multiple Sale records

        Parameters
        ----------
        data
            Sale data to update the selected Sale records to
        where
            Filter to select the Sale records to update

        Returns
        -------
        int
            The total number of Sale records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Sale records
        total = await Sale.prisma().update_many(
            data={
                'customerId': 273032060
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SaleWhereInput] = None,
        cursor: Optional[types.SaleWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Sale records present in the database

        Parameters
        ----------
        select
            Select the Sale fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Sale filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SaleCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Sale.prisma().count()

        # results: prisma.types.SaleCountAggregateOutput
        results = await Sale.prisma().count(
            select={
                '_all': True,
                'userId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.SaleCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SaleWhereInput] = None,
        cursor: Optional[types.SaleWhereUniqueInput] = None,
    ) -> types.SaleCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.SaleCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SaleWhereInput] = None,
        cursor: Optional[types.SaleWhereUniqueInput] = None,
    ) -> Union[int, types.SaleCountAggregateOutput]:
        """Count the number of Sale records present in the database

        Parameters
        ----------
        select
            Select the Sale fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Sale filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SaleCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Sale.prisma().count()

        # results: prisma.types.SaleCountAggregateOutput
        results = await Sale.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.SaleCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.SaleWhereInput] = None
    ) -> int:
        """Delete multiple Sale records.

        Parameters
        ----------
        where
            Optional Sale filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Sale records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Sale records
        total = await Sale.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.SaleScalarFieldKeysT'],
        *,
        where: Optional['types.SaleWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.SaleAvgAggregateInput'] = None,
        sum: Optional['types.SaleSumAggregateInput'] = None,
        min: Optional['types.SaleMinAggregateInput'] = None,
        max: Optional['types.SaleMaxAggregateInput'] = None,
        having: Optional['types.SaleScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.SaleCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.SaleScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.SaleScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.SaleGroupByOutput']:
        """Group Sale records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Sale fields to group records by
        where
            Sale filter to select records
        take
            Limit the maximum number of Sale records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.SaleGroupByOutput]
            A list of dictionaries representing the Sale record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Sale records by updatedAt values
        # and count how many records are in each group
        results = await Sale.prisma().group_by(
            ['updatedAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class SaleItemActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.SaleItem]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await SaleItem.prisma().query_raw(
            'SELECT * FROM SaleItem WHERE id = $1',
            982848517,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.SaleItem
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await SaleItem.prisma().query_first(
            'SELECT * FROM SaleItem WHERE saleId = $1',
            510737498,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.SaleItemCreateInput,
        include: Optional[types.SaleItemInclude] = None
    ) -> _PrismaModelT:
        """Create a new SaleItem record.

        Parameters
        ----------
        data
            SaleItem record data
        include
            Specifies which relations should be loaded on the returned SaleItem model

        Returns
        -------
        prisma.models.SaleItem
            The created SaleItem record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a SaleItem record from just the required fields
        saleitem = await SaleItem.prisma().create(
            data={
                # data to create a SaleItem record
                'saleId': 2117488267,
                'stockId': 1401944936,
                'quantity': 1297607553,
                'price': Decimal('519488550.97683'),
                'subtotal': Decimal('1696425492.16926'),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.SaleItemCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple SaleItem records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of SaleItem record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await SaleItem.prisma().create_many(
            data=[
                {
                    # data to create a SaleItem record
                    'saleId': 1023081650,
                    'stockId': 327681027,
                    'quantity': 527748992,
                    'price': Decimal('2029357497.131859'),
                    'subtotal': Decimal('2122112351.102494'),
                },
                {
                    # data to create a SaleItem record
                    'saleId': 1717307509,
                    'stockId': 1598124042,
                    'quantity': 817623163,
                    'price': Decimal('1030557336.113152'),
                    'subtotal': Decimal('210666198.127605'),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.SaleItemWhereUniqueInput,
        include: Optional[types.SaleItemInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single SaleItem record.

        Parameters
        ----------
        where
            SaleItem filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned SaleItem model

        Returns
        -------
        prisma.models.SaleItem
            The deleted SaleItem record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        saleitem = await SaleItem.prisma().delete(
            where={
                'id': 745569348,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.SaleItemWhereUniqueInput,
        include: Optional[types.SaleItemInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique SaleItem record.

        Parameters
        ----------
        where
            SaleItem filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned SaleItem model

        Returns
        -------
        prisma.models.SaleItem
            The found SaleItem record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        saleitem = await SaleItem.prisma().find_unique(
            where={
                'id': 307876141,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.SaleItemWhereUniqueInput,
        include: Optional[types.SaleItemInclude] = None
    ) -> _PrismaModelT:
        """Find a unique SaleItem record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            SaleItem filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned SaleItem model

        Returns
        -------
        prisma.models.SaleItem
            The found SaleItem record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        saleitem = await SaleItem.prisma().find_unique_or_raise(
            where={
                'id': 1674049122,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SaleItemWhereInput] = None,
        cursor: Optional[types.SaleItemWhereUniqueInput] = None,
        include: Optional[types.SaleItemInclude] = None,
        order: Optional[Union[types.SaleItemOrderByInput, List[types.SaleItemOrderByInput]]] = None,
        distinct: Optional[List[types.SaleItemScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple SaleItem records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of SaleItem records returned
        skip
            Ignore the first N results
        where
            SaleItem filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned SaleItem model
        order
            Order the returned SaleItem records by any field
        distinct
            Filter SaleItem records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.SaleItem]
            The list of all SaleItem records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 SaleItem records
        saleitems = await SaleItem.prisma().find_many(take=10)

        # find the first 5 SaleItem records ordered by the stockId field
        saleitems = await SaleItem.prisma().find_many(
            take=5,
            order={
                'stockId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SaleItemWhereInput] = None,
        cursor: Optional[types.SaleItemWhereUniqueInput] = None,
        include: Optional[types.SaleItemInclude] = None,
        order: Optional[Union[types.SaleItemOrderByInput, List[types.SaleItemOrderByInput]]] = None,
        distinct: Optional[List[types.SaleItemScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single SaleItem record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            SaleItem filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned SaleItem model
        order
            Order the returned SaleItem records by any field
        distinct
            Filter SaleItem records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.SaleItem
            The first SaleItem record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second SaleItem record ordered by the quantity field
        saleitem = await SaleItem.prisma().find_first(
            skip=1,
            order={
                'quantity': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SaleItemWhereInput] = None,
        cursor: Optional[types.SaleItemWhereUniqueInput] = None,
        include: Optional[types.SaleItemInclude] = None,
        order: Optional[Union[types.SaleItemOrderByInput, List[types.SaleItemOrderByInput]]] = None,
        distinct: Optional[List[types.SaleItemScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single SaleItem record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            SaleItem filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned SaleItem model
        order
            Order the returned SaleItem records by any field
        distinct
            Filter SaleItem records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.SaleItem
            The first SaleItem record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second SaleItem record ordered by the price field
        saleitem = await SaleItem.prisma().find_first_or_raise(
            skip=1,
            order={
                'price': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.SaleItemUpdateInput,
        where: types.SaleItemWhereUniqueInput,
        include: Optional[types.SaleItemInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single SaleItem record.

        Parameters
        ----------
        data
            SaleItem record data specifying what to update
        where
            SaleItem filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned SaleItem model

        Returns
        -------
        prisma.models.SaleItem
            The updated SaleItem record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        saleitem = await SaleItem.prisma().update(
            where={
                'id': 1526854643,
            },
            data={
                # data to update the SaleItem record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.SaleItemWhereUniqueInput,
        data: types.SaleItemUpsertInput,
        include: Optional[types.SaleItemInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            SaleItem filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned SaleItem model

        Returns
        -------
        prisma.models.SaleItem
            The created or updated SaleItem record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        saleitem = await SaleItem.prisma().upsert(
            where={
                'id': 958077104,
            },
            data={
                'create': {
                    'id': 958077104,
                    'saleId': 1717307509,
                    'stockId': 1598124042,
                    'quantity': 817623163,
                    'price': Decimal('1030557336.113152'),
                    'subtotal': Decimal('210666198.127605'),
                },
                'update': {
                    'saleId': 1717307509,
                    'stockId': 1598124042,
                    'quantity': 817623163,
                    'price': Decimal('1030557336.113152'),
                    'subtotal': Decimal('210666198.127605'),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.SaleItemUpdateManyMutationInput,
        where: types.SaleItemWhereInput,
    ) -> int:
        """Update multiple SaleItem records

        Parameters
        ----------
        data
            SaleItem data to update the selected SaleItem records to
        where
            Filter to select the SaleItem records to update

        Returns
        -------
        int
            The total number of SaleItem records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all SaleItem records
        total = await SaleItem.prisma().update_many(
            data={
                'subtotal': Decimal('1513050921.20467')
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SaleItemWhereInput] = None,
        cursor: Optional[types.SaleItemWhereUniqueInput] = None,
    ) -> int:
        """Count the number of SaleItem records present in the database

        Parameters
        ----------
        select
            Select the SaleItem fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            SaleItem filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SaleItemCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await SaleItem.prisma().count()

        # results: prisma.types.SaleItemCountAggregateOutput
        results = await SaleItem.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.SaleItemCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SaleItemWhereInput] = None,
        cursor: Optional[types.SaleItemWhereUniqueInput] = None,
    ) -> types.SaleItemCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.SaleItemCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SaleItemWhereInput] = None,
        cursor: Optional[types.SaleItemWhereUniqueInput] = None,
    ) -> Union[int, types.SaleItemCountAggregateOutput]:
        """Count the number of SaleItem records present in the database

        Parameters
        ----------
        select
            Select the SaleItem fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            SaleItem filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SaleItemCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await SaleItem.prisma().count()

        # results: prisma.types.SaleItemCountAggregateOutput
        results = await SaleItem.prisma().count(
            select={
                '_all': True,
                'saleId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.SaleItemCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.SaleItemWhereInput] = None
    ) -> int:
        """Delete multiple SaleItem records.

        Parameters
        ----------
        where
            Optional SaleItem filter to find the records to be deleted

        Returns
        -------
        int
            The total number of SaleItem records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all SaleItem records
        total = await SaleItem.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.SaleItemScalarFieldKeysT'],
        *,
        where: Optional['types.SaleItemWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.SaleItemAvgAggregateInput'] = None,
        sum: Optional['types.SaleItemSumAggregateInput'] = None,
        min: Optional['types.SaleItemMinAggregateInput'] = None,
        max: Optional['types.SaleItemMaxAggregateInput'] = None,
        having: Optional['types.SaleItemScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.SaleItemCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.SaleItemScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.SaleItemScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.SaleItemGroupByOutput']:
        """Group SaleItem records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar SaleItem fields to group records by
        where
            SaleItem filter to select records
        take
            Limit the maximum number of SaleItem records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.SaleItemGroupByOutput]
            A list of dictionaries representing the SaleItem record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group SaleItem records by stockId values
        # and count how many records are in each group
        results = await SaleItem.prisma().group_by(
            ['stockId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ReturnSaleActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.ReturnSale]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await ReturnSale.prisma().query_raw(
            'SELECT * FROM ReturnSale WHERE id = $1',
            2067651663,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.ReturnSale
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await ReturnSale.prisma().query_first(
            'SELECT * FROM ReturnSale WHERE originalId = $1',
            1183911900,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ReturnSaleCreateInput,
        include: Optional[types.ReturnSaleInclude] = None
    ) -> _PrismaModelT:
        """Create a new ReturnSale record.

        Parameters
        ----------
        data
            ReturnSale record data
        include
            Specifies which relations should be loaded on the returned ReturnSale model

        Returns
        -------
        prisma.models.ReturnSale
            The created ReturnSale record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a ReturnSale record from just the required fields
        returnsale = await ReturnSale.prisma().create(
            data={
                # data to create a ReturnSale record
                'originalId': 1589704933,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ReturnSaleCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple ReturnSale records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of ReturnSale record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await ReturnSale.prisma().create_many(
            data=[
                {
                    # data to create a ReturnSale record
                    'originalId': 1243475898,
                },
                {
                    # data to create a ReturnSale record
                    'originalId': 1369828971,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ReturnSaleWhereUniqueInput,
        include: Optional[types.ReturnSaleInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single ReturnSale record.

        Parameters
        ----------
        where
            ReturnSale filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned ReturnSale model

        Returns
        -------
        prisma.models.ReturnSale
            The deleted ReturnSale record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        returnsale = await ReturnSale.prisma().delete(
            where={
                'id': 1678593480,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ReturnSaleWhereUniqueInput,
        include: Optional[types.ReturnSaleInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique ReturnSale record.

        Parameters
        ----------
        where
            ReturnSale filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ReturnSale model

        Returns
        -------
        prisma.models.ReturnSale
            The found ReturnSale record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        returnsale = await ReturnSale.prisma().find_unique(
            where={
                'id': 403521121,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ReturnSaleWhereUniqueInput,
        include: Optional[types.ReturnSaleInclude] = None
    ) -> _PrismaModelT:
        """Find a unique ReturnSale record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            ReturnSale filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ReturnSale model

        Returns
        -------
        prisma.models.ReturnSale
            The found ReturnSale record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        returnsale = await ReturnSale.prisma().find_unique_or_raise(
            where={
                'id': 648760710,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ReturnSaleWhereInput] = None,
        cursor: Optional[types.ReturnSaleWhereUniqueInput] = None,
        include: Optional[types.ReturnSaleInclude] = None,
        order: Optional[Union[types.ReturnSaleOrderByInput, List[types.ReturnSaleOrderByInput]]] = None,
        distinct: Optional[List[types.ReturnSaleScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple ReturnSale records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of ReturnSale records returned
        skip
            Ignore the first N results
        where
            ReturnSale filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ReturnSale model
        order
            Order the returned ReturnSale records by any field
        distinct
            Filter ReturnSale records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.ReturnSale]
            The list of all ReturnSale records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 ReturnSale records
        returnsales = await ReturnSale.prisma().find_many(take=10)

        # find the first 5 ReturnSale records ordered by the reason field
        returnsales = await ReturnSale.prisma().find_many(
            take=5,
            order={
                'reason': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ReturnSaleWhereInput] = None,
        cursor: Optional[types.ReturnSaleWhereUniqueInput] = None,
        include: Optional[types.ReturnSaleInclude] = None,
        order: Optional[Union[types.ReturnSaleOrderByInput, List[types.ReturnSaleOrderByInput]]] = None,
        distinct: Optional[List[types.ReturnSaleScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single ReturnSale record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ReturnSale filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ReturnSale model
        order
            Order the returned ReturnSale records by any field
        distinct
            Filter ReturnSale records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ReturnSale
            The first ReturnSale record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ReturnSale record ordered by the createdAt field
        returnsale = await ReturnSale.prisma().find_first(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ReturnSaleWhereInput] = None,
        cursor: Optional[types.ReturnSaleWhereUniqueInput] = None,
        include: Optional[types.ReturnSaleInclude] = None,
        order: Optional[Union[types.ReturnSaleOrderByInput, List[types.ReturnSaleOrderByInput]]] = None,
        distinct: Optional[List[types.ReturnSaleScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single ReturnSale record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ReturnSale filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ReturnSale model
        order
            Order the returned ReturnSale records by any field
        distinct
            Filter ReturnSale records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ReturnSale
            The first ReturnSale record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ReturnSale record ordered by the updatedAt field
        returnsale = await ReturnSale.prisma().find_first_or_raise(
            skip=1,
            order={
                'updatedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ReturnSaleUpdateInput,
        where: types.ReturnSaleWhereUniqueInput,
        include: Optional[types.ReturnSaleInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single ReturnSale record.

        Parameters
        ----------
        data
            ReturnSale record data specifying what to update
        where
            ReturnSale filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned ReturnSale model

        Returns
        -------
        prisma.models.ReturnSale
            The updated ReturnSale record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        returnsale = await ReturnSale.prisma().update(
            where={
                'id': 607323719,
            },
            data={
                # data to update the ReturnSale record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ReturnSaleWhereUniqueInput,
        data: types.ReturnSaleUpsertInput,
        include: Optional[types.ReturnSaleInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            ReturnSale filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned ReturnSale model

        Returns
        -------
        prisma.models.ReturnSale
            The created or updated ReturnSale record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        returnsale = await ReturnSale.prisma().upsert(
            where={
                'id': 1468890740,
            },
            data={
                'create': {
                    'id': 1468890740,
                    'originalId': 1369828971,
                },
                'update': {
                    'originalId': 1369828971,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ReturnSaleUpdateManyMutationInput,
        where: types.ReturnSaleWhereInput,
    ) -> int:
        """Update multiple ReturnSale records

        Parameters
        ----------
        data
            ReturnSale data to update the selected ReturnSale records to
        where
            Filter to select the ReturnSale records to update

        Returns
        -------
        int
            The total number of ReturnSale records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all ReturnSale records
        total = await ReturnSale.prisma().update_many(
            data={
                'id': 629039005
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ReturnSaleWhereInput] = None,
        cursor: Optional[types.ReturnSaleWhereUniqueInput] = None,
    ) -> int:
        """Count the number of ReturnSale records present in the database

        Parameters
        ----------
        select
            Select the ReturnSale fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ReturnSale filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ReturnSaleCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ReturnSale.prisma().count()

        # results: prisma.types.ReturnSaleCountAggregateOutput
        results = await ReturnSale.prisma().count(
            select={
                '_all': True,
                'originalId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ReturnSaleCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ReturnSaleWhereInput] = None,
        cursor: Optional[types.ReturnSaleWhereUniqueInput] = None,
    ) -> types.ReturnSaleCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ReturnSaleCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ReturnSaleWhereInput] = None,
        cursor: Optional[types.ReturnSaleWhereUniqueInput] = None,
    ) -> Union[int, types.ReturnSaleCountAggregateOutput]:
        """Count the number of ReturnSale records present in the database

        Parameters
        ----------
        select
            Select the ReturnSale fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ReturnSale filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ReturnSaleCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ReturnSale.prisma().count()

        # results: prisma.types.ReturnSaleCountAggregateOutput
        results = await ReturnSale.prisma().count(
            select={
                '_all': True,
                'reason': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ReturnSaleCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ReturnSaleWhereInput] = None
    ) -> int:
        """Delete multiple ReturnSale records.

        Parameters
        ----------
        where
            Optional ReturnSale filter to find the records to be deleted

        Returns
        -------
        int
            The total number of ReturnSale records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all ReturnSale records
        total = await ReturnSale.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ReturnSaleScalarFieldKeysT'],
        *,
        where: Optional['types.ReturnSaleWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ReturnSaleAvgAggregateInput'] = None,
        sum: Optional['types.ReturnSaleSumAggregateInput'] = None,
        min: Optional['types.ReturnSaleMinAggregateInput'] = None,
        max: Optional['types.ReturnSaleMaxAggregateInput'] = None,
        having: Optional['types.ReturnSaleScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ReturnSaleCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ReturnSaleScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.ReturnSaleScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.ReturnSaleGroupByOutput']:
        """Group ReturnSale records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar ReturnSale fields to group records by
        where
            ReturnSale filter to select records
        take
            Limit the maximum number of ReturnSale records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ReturnSaleGroupByOutput]
            A list of dictionaries representing the ReturnSale record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group ReturnSale records by createdAt values
        # and count how many records are in each group
        results = await ReturnSale.prisma().group_by(
            ['createdAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ReturnItemActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.ReturnItem]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await ReturnItem.prisma().query_raw(
            'SELECT * FROM ReturnItem WHERE id = $1',
            1214168082,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.ReturnItem
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await ReturnItem.prisma().query_first(
            'SELECT * FROM ReturnItem WHERE returnId = $1',
            898613219,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ReturnItemCreateInput,
        include: Optional[types.ReturnItemInclude] = None
    ) -> _PrismaModelT:
        """Create a new ReturnItem record.

        Parameters
        ----------
        data
            ReturnItem record data
        include
            Specifies which relations should be loaded on the returned ReturnItem model

        Returns
        -------
        prisma.models.ReturnItem
            The created ReturnItem record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a ReturnItem record from just the required fields
        returnitem = await ReturnItem.prisma().create(
            data={
                # data to create a ReturnItem record
                'returnId': 658378208,
                'saleItemId': 954620057,
                'quantity': 1214809950,
                'refundAmount': Decimal('1047820095.130273'),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ReturnItemCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple ReturnItem records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of ReturnItem record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await ReturnItem.prisma().create_many(
            data=[
                {
                    # data to create a ReturnItem record
                    'returnId': 893052245,
                    'saleItemId': 280083306,
                    'quantity': 549668955,
                    'refundAmount': Decimal('76790008.209829'),
                },
                {
                    # data to create a ReturnItem record
                    'returnId': 245900342,
                    'saleItemId': 811863863,
                    'quantity': 1388801188,
                    'refundAmount': Decimal('752577037.118766'),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ReturnItemWhereUniqueInput,
        include: Optional[types.ReturnItemInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single ReturnItem record.

        Parameters
        ----------
        where
            ReturnItem filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned ReturnItem model

        Returns
        -------
        prisma.models.ReturnItem
            The deleted ReturnItem record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        returnitem = await ReturnItem.prisma().delete(
            where={
                'id': 769681363,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ReturnItemWhereUniqueInput,
        include: Optional[types.ReturnItemInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique ReturnItem record.

        Parameters
        ----------
        where
            ReturnItem filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ReturnItem model

        Returns
        -------
        prisma.models.ReturnItem
            The found ReturnItem record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        returnitem = await ReturnItem.prisma().find_unique(
            where={
                'id': 1214295824,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ReturnItemWhereUniqueInput,
        include: Optional[types.ReturnItemInclude] = None
    ) -> _PrismaModelT:
        """Find a unique ReturnItem record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            ReturnItem filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ReturnItem model

        Returns
        -------
        prisma.models.ReturnItem
            The found ReturnItem record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        returnitem = await ReturnItem.prisma().find_unique_or_raise(
            where={
                'id': 1021417993,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ReturnItemWhereInput] = None,
        cursor: Optional[types.ReturnItemWhereUniqueInput] = None,
        include: Optional[types.ReturnItemInclude] = None,
        order: Optional[Union[types.ReturnItemOrderByInput, List[types.ReturnItemOrderByInput]]] = None,
        distinct: Optional[List[types.ReturnItemScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple ReturnItem records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of ReturnItem records returned
        skip
            Ignore the first N results
        where
            ReturnItem filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ReturnItem model
        order
            Order the returned ReturnItem records by any field
        distinct
            Filter ReturnItem records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.ReturnItem]
            The list of all ReturnItem records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 ReturnItem records
        returnitems = await ReturnItem.prisma().find_many(take=10)

        # find the first 5 ReturnItem records ordered by the saleItemId field
        returnitems = await ReturnItem.prisma().find_many(
            take=5,
            order={
                'saleItemId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ReturnItemWhereInput] = None,
        cursor: Optional[types.ReturnItemWhereUniqueInput] = None,
        include: Optional[types.ReturnItemInclude] = None,
        order: Optional[Union[types.ReturnItemOrderByInput, List[types.ReturnItemOrderByInput]]] = None,
        distinct: Optional[List[types.ReturnItemScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single ReturnItem record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ReturnItem filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ReturnItem model
        order
            Order the returned ReturnItem records by any field
        distinct
            Filter ReturnItem records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ReturnItem
            The first ReturnItem record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ReturnItem record ordered by the quantity field
        returnitem = await ReturnItem.prisma().find_first(
            skip=1,
            order={
                'quantity': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ReturnItemWhereInput] = None,
        cursor: Optional[types.ReturnItemWhereUniqueInput] = None,
        include: Optional[types.ReturnItemInclude] = None,
        order: Optional[Union[types.ReturnItemOrderByInput, List[types.ReturnItemOrderByInput]]] = None,
        distinct: Optional[List[types.ReturnItemScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single ReturnItem record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ReturnItem filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ReturnItem model
        order
            Order the returned ReturnItem records by any field
        distinct
            Filter ReturnItem records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ReturnItem
            The first ReturnItem record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ReturnItem record ordered by the refundAmount field
        returnitem = await ReturnItem.prisma().find_first_or_raise(
            skip=1,
            order={
                'refundAmount': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ReturnItemUpdateInput,
        where: types.ReturnItemWhereUniqueInput,
        include: Optional[types.ReturnItemInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single ReturnItem record.

        Parameters
        ----------
        data
            ReturnItem record data specifying what to update
        where
            ReturnItem filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned ReturnItem model

        Returns
        -------
        prisma.models.ReturnItem
            The updated ReturnItem record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        returnitem = await ReturnItem.prisma().update(
            where={
                'id': 351503374,
            },
            data={
                # data to update the ReturnItem record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ReturnItemWhereUniqueInput,
        data: types.ReturnItemUpsertInput,
        include: Optional[types.ReturnItemInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            ReturnItem filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned ReturnItem model

        Returns
        -------
        prisma.models.ReturnItem
            The created or updated ReturnItem record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        returnitem = await ReturnItem.prisma().upsert(
            where={
                'id': 1321184815,
            },
            data={
                'create': {
                    'id': 1321184815,
                    'returnId': 245900342,
                    'saleItemId': 811863863,
                    'quantity': 1388801188,
                    'refundAmount': Decimal('752577037.118766'),
                },
                'update': {
                    'returnId': 245900342,
                    'saleItemId': 811863863,
                    'quantity': 1388801188,
                    'refundAmount': Decimal('752577037.118766'),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ReturnItemUpdateManyMutationInput,
        where: types.ReturnItemWhereInput,
    ) -> int:
        """Update multiple ReturnItem records

        Parameters
        ----------
        data
            ReturnItem data to update the selected ReturnItem records to
        where
            Filter to select the ReturnItem records to update

        Returns
        -------
        int
            The total number of ReturnItem records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all ReturnItem records
        total = await ReturnItem.prisma().update_many(
            data={
                'id': 369732668
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ReturnItemWhereInput] = None,
        cursor: Optional[types.ReturnItemWhereUniqueInput] = None,
    ) -> int:
        """Count the number of ReturnItem records present in the database

        Parameters
        ----------
        select
            Select the ReturnItem fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ReturnItem filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ReturnItemCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ReturnItem.prisma().count()

        # results: prisma.types.ReturnItemCountAggregateOutput
        results = await ReturnItem.prisma().count(
            select={
                '_all': True,
                'returnId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ReturnItemCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ReturnItemWhereInput] = None,
        cursor: Optional[types.ReturnItemWhereUniqueInput] = None,
    ) -> types.ReturnItemCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ReturnItemCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ReturnItemWhereInput] = None,
        cursor: Optional[types.ReturnItemWhereUniqueInput] = None,
    ) -> Union[int, types.ReturnItemCountAggregateOutput]:
        """Count the number of ReturnItem records present in the database

        Parameters
        ----------
        select
            Select the ReturnItem fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ReturnItem filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ReturnItemCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ReturnItem.prisma().count()

        # results: prisma.types.ReturnItemCountAggregateOutput
        results = await ReturnItem.prisma().count(
            select={
                '_all': True,
                'saleItemId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ReturnItemCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ReturnItemWhereInput] = None
    ) -> int:
        """Delete multiple ReturnItem records.

        Parameters
        ----------
        where
            Optional ReturnItem filter to find the records to be deleted

        Returns
        -------
        int
            The total number of ReturnItem records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all ReturnItem records
        total = await ReturnItem.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ReturnItemScalarFieldKeysT'],
        *,
        where: Optional['types.ReturnItemWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ReturnItemAvgAggregateInput'] = None,
        sum: Optional['types.ReturnItemSumAggregateInput'] = None,
        min: Optional['types.ReturnItemMinAggregateInput'] = None,
        max: Optional['types.ReturnItemMaxAggregateInput'] = None,
        having: Optional['types.ReturnItemScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ReturnItemCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ReturnItemScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.ReturnItemScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.ReturnItemGroupByOutput']:
        """Group ReturnItem records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar ReturnItem fields to group records by
        where
            ReturnItem filter to select records
        take
            Limit the maximum number of ReturnItem records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ReturnItemGroupByOutput]
            A list of dictionaries representing the ReturnItem record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group ReturnItem records by quantity values
        # and count how many records are in each group
        results = await ReturnItem.prisma().group_by(
            ['quantity'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class PaymentActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Payment]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Payment.prisma().query_raw(
            'SELECT * FROM Payment WHERE id = $1',
            1191235013,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Payment
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Payment.prisma().query_first(
            'SELECT * FROM Payment WHERE saleId = $1',
            627561242,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.PaymentCreateInput,
        include: Optional[types.PaymentInclude] = None
    ) -> _PrismaModelT:
        """Create a new Payment record.

        Parameters
        ----------
        data
            Payment record data
        include
            Specifies which relations should be loaded on the returned Payment model

        Returns
        -------
        prisma.models.Payment
            The created Payment record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Payment record from just the required fields
        payment = await Payment.prisma().create(
            data={
                # data to create a Payment record
                'saleId': 1872952907,
                'accountId': 1793282088,
                'userId': 1814397249,
                'amount': Decimal('1923090150.127724'),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.PaymentCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Payment records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Payment record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Payment.prisma().create_many(
            data=[
                {
                    # data to create a Payment record
                    'saleId': 1160857300,
                    'accountId': 361230461,
                    'userId': 1406511986,
                    'amount': Decimal('1482877891.56662'),
                },
                {
                    # data to create a Payment record
                    'saleId': 229119865,
                    'accountId': 1750011070,
                    'userId': 410943775,
                    'amount': Decimal('909024364.75561'),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.PaymentWhereUniqueInput,
        include: Optional[types.PaymentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Payment record.

        Parameters
        ----------
        where
            Payment filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Payment model

        Returns
        -------
        prisma.models.Payment
            The deleted Payment record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        payment = await Payment.prisma().delete(
            where={
                'id': 1802188490,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.PaymentWhereUniqueInput,
        include: Optional[types.PaymentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Payment record.

        Parameters
        ----------
        where
            Payment filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Payment model

        Returns
        -------
        prisma.models.Payment
            The found Payment record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        payment = await Payment.prisma().find_unique(
            where={
                'id': 294916155,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.PaymentWhereUniqueInput,
        include: Optional[types.PaymentInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Payment record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Payment filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Payment model

        Returns
        -------
        prisma.models.Payment
            The found Payment record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        payment = await Payment.prisma().find_unique_or_raise(
            where={
                'id': 564073304,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PaymentWhereInput] = None,
        cursor: Optional[types.PaymentWhereUniqueInput] = None,
        include: Optional[types.PaymentInclude] = None,
        order: Optional[Union[types.PaymentOrderByInput, List[types.PaymentOrderByInput]]] = None,
        distinct: Optional[List[types.PaymentScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Payment records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Payment records returned
        skip
            Ignore the first N results
        where
            Payment filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Payment model
        order
            Order the returned Payment records by any field
        distinct
            Filter Payment records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Payment]
            The list of all Payment records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Payment records
        payments = await Payment.prisma().find_many(take=10)

        # find the first 5 Payment records ordered by the accountId field
        payments = await Payment.prisma().find_many(
            take=5,
            order={
                'accountId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PaymentWhereInput] = None,
        cursor: Optional[types.PaymentWhereUniqueInput] = None,
        include: Optional[types.PaymentInclude] = None,
        order: Optional[Union[types.PaymentOrderByInput, List[types.PaymentOrderByInput]]] = None,
        distinct: Optional[List[types.PaymentScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Payment record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Payment filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Payment model
        order
            Order the returned Payment records by any field
        distinct
            Filter Payment records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Payment
            The first Payment record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Payment record ordered by the returnId field
        payment = await Payment.prisma().find_first(
            skip=1,
            order={
                'returnId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PaymentWhereInput] = None,
        cursor: Optional[types.PaymentWhereUniqueInput] = None,
        include: Optional[types.PaymentInclude] = None,
        order: Optional[Union[types.PaymentOrderByInput, List[types.PaymentOrderByInput]]] = None,
        distinct: Optional[List[types.PaymentScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Payment record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Payment filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Payment model
        order
            Order the returned Payment records by any field
        distinct
            Filter Payment records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Payment
            The first Payment record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Payment record ordered by the userId field
        payment = await Payment.prisma().find_first_or_raise(
            skip=1,
            order={
                'userId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.PaymentUpdateInput,
        where: types.PaymentWhereUniqueInput,
        include: Optional[types.PaymentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Payment record.

        Parameters
        ----------
        data
            Payment record data specifying what to update
        where
            Payment filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Payment model

        Returns
        -------
        prisma.models.Payment
            The updated Payment record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        payment = await Payment.prisma().update(
            where={
                'id': 380648625,
            },
            data={
                # data to update the Payment record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.PaymentWhereUniqueInput,
        data: types.PaymentUpsertInput,
        include: Optional[types.PaymentInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Payment filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Payment model

        Returns
        -------
        prisma.models.Payment
            The created or updated Payment record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        payment = await Payment.prisma().upsert(
            where={
                'id': 1030616470,
            },
            data={
                'create': {
                    'id': 1030616470,
                    'saleId': 229119865,
                    'accountId': 1750011070,
                    'userId': 410943775,
                    'amount': Decimal('909024364.75561'),
                },
                'update': {
                    'saleId': 229119865,
                    'accountId': 1750011070,
                    'userId': 410943775,
                    'amount': Decimal('909024364.75561'),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.PaymentUpdateManyMutationInput,
        where: types.PaymentWhereInput,
    ) -> int:
        """Update multiple Payment records

        Parameters
        ----------
        data
            Payment data to update the selected Payment records to
        where
            Filter to select the Payment records to update

        Returns
        -------
        int
            The total number of Payment records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Payment records
        total = await Payment.prisma().update_many(
            data={
                'amount': Decimal('816411927.108409')
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PaymentWhereInput] = None,
        cursor: Optional[types.PaymentWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Payment records present in the database

        Parameters
        ----------
        select
            Select the Payment fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Payment filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PaymentCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Payment.prisma().count()

        # results: prisma.types.PaymentCountAggregateOutput
        results = await Payment.prisma().count(
            select={
                '_all': True,
                'currency': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.PaymentCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PaymentWhereInput] = None,
        cursor: Optional[types.PaymentWhereUniqueInput] = None,
    ) -> types.PaymentCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.PaymentCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PaymentWhereInput] = None,
        cursor: Optional[types.PaymentWhereUniqueInput] = None,
    ) -> Union[int, types.PaymentCountAggregateOutput]:
        """Count the number of Payment records present in the database

        Parameters
        ----------
        select
            Select the Payment fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Payment filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PaymentCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Payment.prisma().count()

        # results: prisma.types.PaymentCountAggregateOutput
        results = await Payment.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.PaymentCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.PaymentWhereInput] = None
    ) -> int:
        """Delete multiple Payment records.

        Parameters
        ----------
        where
            Optional Payment filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Payment records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Payment records
        total = await Payment.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.PaymentScalarFieldKeysT'],
        *,
        where: Optional['types.PaymentWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.PaymentAvgAggregateInput'] = None,
        sum: Optional['types.PaymentSumAggregateInput'] = None,
        min: Optional['types.PaymentMinAggregateInput'] = None,
        max: Optional['types.PaymentMaxAggregateInput'] = None,
        having: Optional['types.PaymentScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.PaymentCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.PaymentScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.PaymentScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.PaymentGroupByOutput']:
        """Group Payment records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Payment fields to group records by
        where
            Payment filter to select records
        take
            Limit the maximum number of Payment records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.PaymentGroupByOutput]
            A list of dictionaries representing the Payment record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Payment records by updatedAt values
        # and count how many records are in each group
        results = await Payment.prisma().group_by(
            ['updatedAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class JournalEntryActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.JournalEntry]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await JournalEntry.prisma().query_raw(
            'SELECT * FROM JournalEntry WHERE id = $1',
            1079702253,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.JournalEntry
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await JournalEntry.prisma().query_first(
            'SELECT * FROM JournalEntry WHERE referenceType = $1',
            'hffhfabhi',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.JournalEntryCreateInput,
        include: Optional[types.JournalEntryInclude] = None
    ) -> _PrismaModelT:
        """Create a new JournalEntry record.

        Parameters
        ----------
        data
            JournalEntry record data
        include
            Specifies which relations should be loaded on the returned JournalEntry model

        Returns
        -------
        prisma.models.JournalEntry
            The created JournalEntry record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a JournalEntry record from just the required fields
        journalentry = await JournalEntry.prisma().create(
            data={
                # data to create a JournalEntry record
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.JournalEntryCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple JournalEntry records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of JournalEntry record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await JournalEntry.prisma().create_many(
            data=[
                {
                    # data to create a JournalEntry record
                },
                {
                    # data to create a JournalEntry record
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.JournalEntryWhereUniqueInput,
        include: Optional[types.JournalEntryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single JournalEntry record.

        Parameters
        ----------
        where
            JournalEntry filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned JournalEntry model

        Returns
        -------
        prisma.models.JournalEntry
            The deleted JournalEntry record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        journalentry = await JournalEntry.prisma().delete(
            where={
                'id': 1128680371,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.JournalEntryWhereUniqueInput,
        include: Optional[types.JournalEntryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique JournalEntry record.

        Parameters
        ----------
        where
            JournalEntry filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned JournalEntry model

        Returns
        -------
        prisma.models.JournalEntry
            The found JournalEntry record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        journalentry = await JournalEntry.prisma().find_unique(
            where={
                'id': 259061104,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.JournalEntryWhereUniqueInput,
        include: Optional[types.JournalEntryInclude] = None
    ) -> _PrismaModelT:
        """Find a unique JournalEntry record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            JournalEntry filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned JournalEntry model

        Returns
        -------
        prisma.models.JournalEntry
            The found JournalEntry record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        journalentry = await JournalEntry.prisma().find_unique_or_raise(
            where={
                'id': 1115738345,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.JournalEntryWhereInput] = None,
        cursor: Optional[types.JournalEntryWhereUniqueInput] = None,
        include: Optional[types.JournalEntryInclude] = None,
        order: Optional[Union[types.JournalEntryOrderByInput, List[types.JournalEntryOrderByInput]]] = None,
        distinct: Optional[List[types.JournalEntryScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple JournalEntry records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of JournalEntry records returned
        skip
            Ignore the first N results
        where
            JournalEntry filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned JournalEntry model
        order
            Order the returned JournalEntry records by any field
        distinct
            Filter JournalEntry records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.JournalEntry]
            The list of all JournalEntry records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 JournalEntry records
        journalentrys = await JournalEntry.prisma().find_many(take=10)

        # find the first 5 JournalEntry records ordered by the referenceId field
        journalentrys = await JournalEntry.prisma().find_many(
            take=5,
            order={
                'referenceId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.JournalEntryWhereInput] = None,
        cursor: Optional[types.JournalEntryWhereUniqueInput] = None,
        include: Optional[types.JournalEntryInclude] = None,
        order: Optional[Union[types.JournalEntryOrderByInput, List[types.JournalEntryOrderByInput]]] = None,
        distinct: Optional[List[types.JournalEntryScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single JournalEntry record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            JournalEntry filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned JournalEntry model
        order
            Order the returned JournalEntry records by any field
        distinct
            Filter JournalEntry records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.JournalEntry
            The first JournalEntry record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second JournalEntry record ordered by the date field
        journalentry = await JournalEntry.prisma().find_first(
            skip=1,
            order={
                'date': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.JournalEntryWhereInput] = None,
        cursor: Optional[types.JournalEntryWhereUniqueInput] = None,
        include: Optional[types.JournalEntryInclude] = None,
        order: Optional[Union[types.JournalEntryOrderByInput, List[types.JournalEntryOrderByInput]]] = None,
        distinct: Optional[List[types.JournalEntryScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single JournalEntry record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            JournalEntry filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned JournalEntry model
        order
            Order the returned JournalEntry records by any field
        distinct
            Filter JournalEntry records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.JournalEntry
            The first JournalEntry record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second JournalEntry record ordered by the updatedAt field
        journalentry = await JournalEntry.prisma().find_first_or_raise(
            skip=1,
            order={
                'updatedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.JournalEntryUpdateInput,
        where: types.JournalEntryWhereUniqueInput,
        include: Optional[types.JournalEntryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single JournalEntry record.

        Parameters
        ----------
        data
            JournalEntry record data specifying what to update
        where
            JournalEntry filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned JournalEntry model

        Returns
        -------
        prisma.models.JournalEntry
            The updated JournalEntry record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        journalentry = await JournalEntry.prisma().update(
            where={
                'id': 1303781742,
            },
            data={
                # data to update the JournalEntry record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.JournalEntryWhereUniqueInput,
        data: types.JournalEntryUpsertInput,
        include: Optional[types.JournalEntryInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            JournalEntry filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned JournalEntry model

        Returns
        -------
        prisma.models.JournalEntry
            The created or updated JournalEntry record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        journalentry = await JournalEntry.prisma().upsert(
            where={
                'id': 1573908495,
            },
            data={
                'create': {
                    'id': 1573908495,
                },
                'update': {
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.JournalEntryUpdateManyMutationInput,
        where: types.JournalEntryWhereInput,
    ) -> int:
        """Update multiple JournalEntry records

        Parameters
        ----------
        data
            JournalEntry data to update the selected JournalEntry records to
        where
            Filter to select the JournalEntry records to update

        Returns
        -------
        int
            The total number of JournalEntry records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all JournalEntry records
        total = await JournalEntry.prisma().update_many(
            data={
                'id': 1195899036
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.JournalEntryWhereInput] = None,
        cursor: Optional[types.JournalEntryWhereUniqueInput] = None,
    ) -> int:
        """Count the number of JournalEntry records present in the database

        Parameters
        ----------
        select
            Select the JournalEntry fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            JournalEntry filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.JournalEntryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await JournalEntry.prisma().count()

        # results: prisma.types.JournalEntryCountAggregateOutput
        results = await JournalEntry.prisma().count(
            select={
                '_all': True,
                'referenceType': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.JournalEntryCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.JournalEntryWhereInput] = None,
        cursor: Optional[types.JournalEntryWhereUniqueInput] = None,
    ) -> types.JournalEntryCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.JournalEntryCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.JournalEntryWhereInput] = None,
        cursor: Optional[types.JournalEntryWhereUniqueInput] = None,
    ) -> Union[int, types.JournalEntryCountAggregateOutput]:
        """Count the number of JournalEntry records present in the database

        Parameters
        ----------
        select
            Select the JournalEntry fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            JournalEntry filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.JournalEntryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await JournalEntry.prisma().count()

        # results: prisma.types.JournalEntryCountAggregateOutput
        results = await JournalEntry.prisma().count(
            select={
                '_all': True,
                'referenceId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.JournalEntryCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.JournalEntryWhereInput] = None
    ) -> int:
        """Delete multiple JournalEntry records.

        Parameters
        ----------
        where
            Optional JournalEntry filter to find the records to be deleted

        Returns
        -------
        int
            The total number of JournalEntry records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all JournalEntry records
        total = await JournalEntry.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.JournalEntryScalarFieldKeysT'],
        *,
        where: Optional['types.JournalEntryWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.JournalEntryAvgAggregateInput'] = None,
        sum: Optional['types.JournalEntrySumAggregateInput'] = None,
        min: Optional['types.JournalEntryMinAggregateInput'] = None,
        max: Optional['types.JournalEntryMaxAggregateInput'] = None,
        having: Optional['types.JournalEntryScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.JournalEntryCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.JournalEntryScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.JournalEntryScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.JournalEntryGroupByOutput']:
        """Group JournalEntry records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar JournalEntry fields to group records by
        where
            JournalEntry filter to select records
        take
            Limit the maximum number of JournalEntry records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.JournalEntryGroupByOutput]
            A list of dictionaries representing the JournalEntry record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group JournalEntry records by date values
        # and count how many records are in each group
        results = await JournalEntry.prisma().group_by(
            ['date'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class JournalEntryLineActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.JournalEntryLine]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await JournalEntryLine.prisma().query_raw(
            'SELECT * FROM JournalEntryLine WHERE id = $1',
            739021477,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.JournalEntryLine
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await JournalEntryLine.prisma().query_first(
            'SELECT * FROM JournalEntryLine WHERE entryId = $1',
            1722214010,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.JournalEntryLineCreateInput,
        include: Optional[types.JournalEntryLineInclude] = None
    ) -> _PrismaModelT:
        """Create a new JournalEntryLine record.

        Parameters
        ----------
        data
            JournalEntryLine record data
        include
            Specifies which relations should be loaded on the returned JournalEntryLine model

        Returns
        -------
        prisma.models.JournalEntryLine
            The created JournalEntryLine record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a JournalEntryLine record from just the required fields
        journalentryline = await JournalEntryLine.prisma().create(
            data={
                # data to create a JournalEntryLine record
                'entryId': 1269136939,
                'accountId': 573178504,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.JournalEntryLineCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple JournalEntryLine records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of JournalEntryLine record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await JournalEntryLine.prisma().create_many(
            data=[
                {
                    # data to create a JournalEntryLine record
                    'entryId': 1440265249,
                    'accountId': 1185738822,
                },
                {
                    # data to create a JournalEntryLine record
                    'entryId': 1694224903,
                    'accountId': 1906360116,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.JournalEntryLineWhereUniqueInput,
        include: Optional[types.JournalEntryLineInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single JournalEntryLine record.

        Parameters
        ----------
        where
            JournalEntryLine filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned JournalEntryLine model

        Returns
        -------
        prisma.models.JournalEntryLine
            The deleted JournalEntryLine record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        journalentryline = await JournalEntryLine.prisma().delete(
            where={
                'id': 1911255389,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.JournalEntryLineWhereUniqueInput,
        include: Optional[types.JournalEntryLineInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique JournalEntryLine record.

        Parameters
        ----------
        where
            JournalEntryLine filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned JournalEntryLine model

        Returns
        -------
        prisma.models.JournalEntryLine
            The found JournalEntryLine record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        journalentryline = await JournalEntryLine.prisma().find_unique(
            where={
                'id': 146262738,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.JournalEntryLineWhereUniqueInput,
        include: Optional[types.JournalEntryLineInclude] = None
    ) -> _PrismaModelT:
        """Find a unique JournalEntryLine record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            JournalEntryLine filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned JournalEntryLine model

        Returns
        -------
        prisma.models.JournalEntryLine
            The found JournalEntryLine record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        journalentryline = await JournalEntryLine.prisma().find_unique_or_raise(
            where={
                'id': 1719240611,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.JournalEntryLineWhereInput] = None,
        cursor: Optional[types.JournalEntryLineWhereUniqueInput] = None,
        include: Optional[types.JournalEntryLineInclude] = None,
        order: Optional[Union[types.JournalEntryLineOrderByInput, List[types.JournalEntryLineOrderByInput]]] = None,
        distinct: Optional[List[types.JournalEntryLineScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple JournalEntryLine records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of JournalEntryLine records returned
        skip
            Ignore the first N results
        where
            JournalEntryLine filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned JournalEntryLine model
        order
            Order the returned JournalEntryLine records by any field
        distinct
            Filter JournalEntryLine records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.JournalEntryLine]
            The list of all JournalEntryLine records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 JournalEntryLine records
        journalentrylines = await JournalEntryLine.prisma().find_many(take=10)

        # find the first 5 JournalEntryLine records ordered by the accountId field
        journalentrylines = await JournalEntryLine.prisma().find_many(
            take=5,
            order={
                'accountId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.JournalEntryLineWhereInput] = None,
        cursor: Optional[types.JournalEntryLineWhereUniqueInput] = None,
        include: Optional[types.JournalEntryLineInclude] = None,
        order: Optional[Union[types.JournalEntryLineOrderByInput, List[types.JournalEntryLineOrderByInput]]] = None,
        distinct: Optional[List[types.JournalEntryLineScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single JournalEntryLine record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            JournalEntryLine filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned JournalEntryLine model
        order
            Order the returned JournalEntryLine records by any field
        distinct
            Filter JournalEntryLine records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.JournalEntryLine
            The first JournalEntryLine record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second JournalEntryLine record ordered by the debit field
        journalentryline = await JournalEntryLine.prisma().find_first(
            skip=1,
            order={
                'debit': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.JournalEntryLineWhereInput] = None,
        cursor: Optional[types.JournalEntryLineWhereUniqueInput] = None,
        include: Optional[types.JournalEntryLineInclude] = None,
        order: Optional[Union[types.JournalEntryLineOrderByInput, List[types.JournalEntryLineOrderByInput]]] = None,
        distinct: Optional[List[types.JournalEntryLineScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single JournalEntryLine record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            JournalEntryLine filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned JournalEntryLine model
        order
            Order the returned JournalEntryLine records by any field
        distinct
            Filter JournalEntryLine records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.JournalEntryLine
            The first JournalEntryLine record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second JournalEntryLine record ordered by the credit field
        journalentryline = await JournalEntryLine.prisma().find_first_or_raise(
            skip=1,
            order={
                'credit': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.JournalEntryLineUpdateInput,
        where: types.JournalEntryLineWhereUniqueInput,
        include: Optional[types.JournalEntryLineInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single JournalEntryLine record.

        Parameters
        ----------
        data
            JournalEntryLine record data specifying what to update
        where
            JournalEntryLine filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned JournalEntryLine model

        Returns
        -------
        prisma.models.JournalEntryLine
            The updated JournalEntryLine record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        journalentryline = await JournalEntryLine.prisma().update(
            where={
                'id': 1948555936,
            },
            data={
                # data to update the JournalEntryLine record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.JournalEntryLineWhereUniqueInput,
        data: types.JournalEntryLineUpsertInput,
        include: Optional[types.JournalEntryLineInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            JournalEntryLine filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned JournalEntryLine model

        Returns
        -------
        prisma.models.JournalEntryLine
            The created or updated JournalEntryLine record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        journalentryline = await JournalEntryLine.prisma().upsert(
            where={
                'id': 1383253593,
            },
            data={
                'create': {
                    'id': 1383253593,
                    'entryId': 1694224903,
                    'accountId': 1906360116,
                },
                'update': {
                    'entryId': 1694224903,
                    'accountId': 1906360116,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.JournalEntryLineUpdateManyMutationInput,
        where: types.JournalEntryLineWhereInput,
    ) -> int:
        """Update multiple JournalEntryLine records

        Parameters
        ----------
        data
            JournalEntryLine data to update the selected JournalEntryLine records to
        where
            Filter to select the JournalEntryLine records to update

        Returns
        -------
        int
            The total number of JournalEntryLine records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all JournalEntryLine records
        total = await JournalEntryLine.prisma().update_many(
            data={
                'description': 'dfeggejja'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.JournalEntryLineWhereInput] = None,
        cursor: Optional[types.JournalEntryLineWhereUniqueInput] = None,
    ) -> int:
        """Count the number of JournalEntryLine records present in the database

        Parameters
        ----------
        select
            Select the JournalEntryLine fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            JournalEntryLine filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.JournalEntryLineCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await JournalEntryLine.prisma().count()

        # results: prisma.types.JournalEntryLineCountAggregateOutput
        results = await JournalEntryLine.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.JournalEntryLineCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.JournalEntryLineWhereInput] = None,
        cursor: Optional[types.JournalEntryLineWhereUniqueInput] = None,
    ) -> types.JournalEntryLineCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.JournalEntryLineCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.JournalEntryLineWhereInput] = None,
        cursor: Optional[types.JournalEntryLineWhereUniqueInput] = None,
    ) -> Union[int, types.JournalEntryLineCountAggregateOutput]:
        """Count the number of JournalEntryLine records present in the database

        Parameters
        ----------
        select
            Select the JournalEntryLine fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            JournalEntryLine filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.JournalEntryLineCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await JournalEntryLine.prisma().count()

        # results: prisma.types.JournalEntryLineCountAggregateOutput
        results = await JournalEntryLine.prisma().count(
            select={
                '_all': True,
                'entryId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.JournalEntryLineCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.JournalEntryLineWhereInput] = None
    ) -> int:
        """Delete multiple JournalEntryLine records.

        Parameters
        ----------
        where
            Optional JournalEntryLine filter to find the records to be deleted

        Returns
        -------
        int
            The total number of JournalEntryLine records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all JournalEntryLine records
        total = await JournalEntryLine.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.JournalEntryLineScalarFieldKeysT'],
        *,
        where: Optional['types.JournalEntryLineWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.JournalEntryLineAvgAggregateInput'] = None,
        sum: Optional['types.JournalEntryLineSumAggregateInput'] = None,
        min: Optional['types.JournalEntryLineMinAggregateInput'] = None,
        max: Optional['types.JournalEntryLineMaxAggregateInput'] = None,
        having: Optional['types.JournalEntryLineScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.JournalEntryLineCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.JournalEntryLineScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.JournalEntryLineScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.JournalEntryLineGroupByOutput']:
        """Group JournalEntryLine records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar JournalEntryLine fields to group records by
        where
            JournalEntryLine filter to select records
        take
            Limit the maximum number of JournalEntryLine records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.JournalEntryLineGroupByOutput]
            A list of dictionaries representing the JournalEntryLine record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group JournalEntryLine records by accountId values
        # and count how many records are in each group
        results = await JournalEntryLine.prisma().group_by(
            ['accountId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class AccountActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Account]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Account.prisma().query_raw(
            'SELECT * FROM Account WHERE id = $1',
            647166719,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Account
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Account.prisma().query_first(
            'SELECT * FROM Account WHERE name = $1',
            'dfhaijeie',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.AccountCreateInput,
        include: Optional[types.AccountInclude] = None
    ) -> _PrismaModelT:
        """Create a new Account record.

        Parameters
        ----------
        data
            Account record data
        include
            Specifies which relations should be loaded on the returned Account model

        Returns
        -------
        prisma.models.Account
            The created Account record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Account record from just the required fields
        account = await Account.prisma().create(
            data={
                # data to create a Account record
                'name': 'gbcdjgicb',
                'type': enums.AccountType.ASSET,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.AccountCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Account records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Account record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Account.prisma().create_many(
            data=[
                {
                    # data to create a Account record
                    'name': 'biaibdagac',
                    'type': enums.AccountType.ASSET,
                },
                {
                    # data to create a Account record
                    'name': 'bbfbheibcd',
                    'type': enums.AccountType.ASSET,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.AccountWhereUniqueInput,
        include: Optional[types.AccountInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Account record.

        Parameters
        ----------
        where
            Account filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Account model

        Returns
        -------
        prisma.models.Account
            The deleted Account record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        account = await Account.prisma().delete(
            where={
                'id': 78060984,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.AccountWhereUniqueInput,
        include: Optional[types.AccountInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Account record.

        Parameters
        ----------
        where
            Account filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Account model

        Returns
        -------
        prisma.models.Account
            The found Account record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        account = await Account.prisma().find_unique(
            where={
                'id': 444983185,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.AccountWhereUniqueInput,
        include: Optional[types.AccountInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Account record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Account filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Account model

        Returns
        -------
        prisma.models.Account
            The found Account record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        account = await Account.prisma().find_unique_or_raise(
            where={
                'id': 45610742,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AccountWhereInput] = None,
        cursor: Optional[types.AccountWhereUniqueInput] = None,
        include: Optional[types.AccountInclude] = None,
        order: Optional[Union[types.AccountOrderByInput, List[types.AccountOrderByInput]]] = None,
        distinct: Optional[List[types.AccountScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Account records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Account records returned
        skip
            Ignore the first N results
        where
            Account filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Account model
        order
            Order the returned Account records by any field
        distinct
            Filter Account records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Account]
            The list of all Account records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Account records
        accounts = await Account.prisma().find_many(take=10)

        # find the first 5 Account records ordered by the type field
        accounts = await Account.prisma().find_many(
            take=5,
            order={
                'type': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AccountWhereInput] = None,
        cursor: Optional[types.AccountWhereUniqueInput] = None,
        include: Optional[types.AccountInclude] = None,
        order: Optional[Union[types.AccountOrderByInput, List[types.AccountOrderByInput]]] = None,
        distinct: Optional[List[types.AccountScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Account record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Account filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Account model
        order
            Order the returned Account records by any field
        distinct
            Filter Account records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Account
            The first Account record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Account record ordered by the currency field
        account = await Account.prisma().find_first(
            skip=1,
            order={
                'currency': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AccountWhereInput] = None,
        cursor: Optional[types.AccountWhereUniqueInput] = None,
        include: Optional[types.AccountInclude] = None,
        order: Optional[Union[types.AccountOrderByInput, List[types.AccountOrderByInput]]] = None,
        distinct: Optional[List[types.AccountScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Account record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Account filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Account model
        order
            Order the returned Account records by any field
        distinct
            Filter Account records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Account
            The first Account record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Account record ordered by the balance field
        account = await Account.prisma().find_first_or_raise(
            skip=1,
            order={
                'balance': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.AccountUpdateInput,
        where: types.AccountWhereUniqueInput,
        include: Optional[types.AccountInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Account record.

        Parameters
        ----------
        data
            Account record data specifying what to update
        where
            Account filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Account model

        Returns
        -------
        prisma.models.Account
            The updated Account record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        account = await Account.prisma().update(
            where={
                'id': 769084151,
            },
            data={
                # data to update the Account record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.AccountWhereUniqueInput,
        data: types.AccountUpsertInput,
        include: Optional[types.AccountInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Account filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Account model

        Returns
        -------
        prisma.models.Account
            The created or updated Account record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        account = await Account.prisma().upsert(
            where={
                'id': 1334599012,
            },
            data={
                'create': {
                    'id': 1334599012,
                    'name': 'bbfbheibcd',
                    'type': enums.AccountType.ASSET,
                },
                'update': {
                    'name': 'bbfbheibcd',
                    'type': enums.AccountType.ASSET,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.AccountUpdateManyMutationInput,
        where: types.AccountWhereInput,
    ) -> int:
        """Update multiple Account records

        Parameters
        ----------
        data
            Account data to update the selected Account records to
        where
            Filter to select the Account records to update

        Returns
        -------
        int
            The total number of Account records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Account records
        total = await Account.prisma().update_many(
            data={
                'active': False
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AccountWhereInput] = None,
        cursor: Optional[types.AccountWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Account records present in the database

        Parameters
        ----------
        select
            Select the Account fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Account filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AccountCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Account.prisma().count()

        # results: prisma.types.AccountCountAggregateOutput
        results = await Account.prisma().count(
            select={
                '_all': True,
                'branchId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.AccountCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AccountWhereInput] = None,
        cursor: Optional[types.AccountWhereUniqueInput] = None,
    ) -> types.AccountCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.AccountCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AccountWhereInput] = None,
        cursor: Optional[types.AccountWhereUniqueInput] = None,
    ) -> Union[int, types.AccountCountAggregateOutput]:
        """Count the number of Account records present in the database

        Parameters
        ----------
        select
            Select the Account fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Account filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AccountCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Account.prisma().count()

        # results: prisma.types.AccountCountAggregateOutput
        results = await Account.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.AccountCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.AccountWhereInput] = None
    ) -> int:
        """Delete multiple Account records.

        Parameters
        ----------
        where
            Optional Account filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Account records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Account records
        total = await Account.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.AccountScalarFieldKeysT'],
        *,
        where: Optional['types.AccountWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.AccountAvgAggregateInput'] = None,
        sum: Optional['types.AccountSumAggregateInput'] = None,
        min: Optional['types.AccountMinAggregateInput'] = None,
        max: Optional['types.AccountMaxAggregateInput'] = None,
        having: Optional['types.AccountScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.AccountCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.AccountScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.AccountScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.AccountGroupByOutput']:
        """Group Account records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Account fields to group records by
        where
            Account filter to select records
        take
            Limit the maximum number of Account records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.AccountGroupByOutput]
            A list of dictionaries representing the Account record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Account records by updatedAt values
        # and count how many records are in each group
        results = await Account.prisma().group_by(
            ['updatedAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class AccountTransferActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.AccountTransfer]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await AccountTransfer.prisma().query_raw(
            'SELECT * FROM AccountTransfer WHERE id = $1',
            1172606082,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.AccountTransfer
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await AccountTransfer.prisma().query_first(
            'SELECT * FROM AccountTransfer WHERE fromAccountId = $1',
            330014611,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.AccountTransferCreateInput,
        include: Optional[types.AccountTransferInclude] = None
    ) -> _PrismaModelT:
        """Create a new AccountTransfer record.

        Parameters
        ----------
        data
            AccountTransfer record data
        include
            Specifies which relations should be loaded on the returned AccountTransfer model

        Returns
        -------
        prisma.models.AccountTransfer
            The created AccountTransfer record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a AccountTransfer record from just the required fields
        accounttransfer = await AccountTransfer.prisma().create(
            data={
                # data to create a AccountTransfer record
                'fromAccountId': 1768156112,
                'toAccountId': 71628745,
                'amount': Decimal('55766734.81203'),
                'currency': enums.Currency.USD,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.AccountTransferCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple AccountTransfer records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of AccountTransfer record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await AccountTransfer.prisma().create_many(
            data=[
                {
                    # data to create a AccountTransfer record
                    'fromAccountId': 1323562236,
                    'toAccountId': 43796357,
                    'amount': Decimal('1345530330.196538'),
                    'currency': enums.Currency.USD,
                },
                {
                    # data to create a AccountTransfer record
                    'fromAccountId': 804873448,
                    'toAccountId': 1566496513,
                    'amount': Decimal('850004390.210939'),
                    'currency': enums.Currency.USD,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.AccountTransferWhereUniqueInput,
        include: Optional[types.AccountTransferInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single AccountTransfer record.

        Parameters
        ----------
        where
            AccountTransfer filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned AccountTransfer model

        Returns
        -------
        prisma.models.AccountTransfer
            The deleted AccountTransfer record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        accounttransfer = await AccountTransfer.prisma().delete(
            where={
                'id': 1282664340,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.AccountTransferWhereUniqueInput,
        include: Optional[types.AccountTransferInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique AccountTransfer record.

        Parameters
        ----------
        where
            AccountTransfer filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AccountTransfer model

        Returns
        -------
        prisma.models.AccountTransfer
            The found AccountTransfer record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        accounttransfer = await AccountTransfer.prisma().find_unique(
            where={
                'id': 241230397,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.AccountTransferWhereUniqueInput,
        include: Optional[types.AccountTransferInclude] = None
    ) -> _PrismaModelT:
        """Find a unique AccountTransfer record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            AccountTransfer filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AccountTransfer model

        Returns
        -------
        prisma.models.AccountTransfer
            The found AccountTransfer record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        accounttransfer = await AccountTransfer.prisma().find_unique_or_raise(
            where={
                'id': 475863602,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AccountTransferWhereInput] = None,
        cursor: Optional[types.AccountTransferWhereUniqueInput] = None,
        include: Optional[types.AccountTransferInclude] = None,
        order: Optional[Union[types.AccountTransferOrderByInput, List[types.AccountTransferOrderByInput]]] = None,
        distinct: Optional[List[types.AccountTransferScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple AccountTransfer records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of AccountTransfer records returned
        skip
            Ignore the first N results
        where
            AccountTransfer filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AccountTransfer model
        order
            Order the returned AccountTransfer records by any field
        distinct
            Filter AccountTransfer records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.AccountTransfer]
            The list of all AccountTransfer records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 AccountTransfer records
        accounttransfers = await AccountTransfer.prisma().find_many(take=10)

        # find the first 5 AccountTransfer records ordered by the toAccountId field
        accounttransfers = await AccountTransfer.prisma().find_many(
            take=5,
            order={
                'toAccountId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AccountTransferWhereInput] = None,
        cursor: Optional[types.AccountTransferWhereUniqueInput] = None,
        include: Optional[types.AccountTransferInclude] = None,
        order: Optional[Union[types.AccountTransferOrderByInput, List[types.AccountTransferOrderByInput]]] = None,
        distinct: Optional[List[types.AccountTransferScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single AccountTransfer record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AccountTransfer filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AccountTransfer model
        order
            Order the returned AccountTransfer records by any field
        distinct
            Filter AccountTransfer records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AccountTransfer
            The first AccountTransfer record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AccountTransfer record ordered by the amount field
        accounttransfer = await AccountTransfer.prisma().find_first(
            skip=1,
            order={
                'amount': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AccountTransferWhereInput] = None,
        cursor: Optional[types.AccountTransferWhereUniqueInput] = None,
        include: Optional[types.AccountTransferInclude] = None,
        order: Optional[Union[types.AccountTransferOrderByInput, List[types.AccountTransferOrderByInput]]] = None,
        distinct: Optional[List[types.AccountTransferScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single AccountTransfer record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AccountTransfer filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AccountTransfer model
        order
            Order the returned AccountTransfer records by any field
        distinct
            Filter AccountTransfer records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AccountTransfer
            The first AccountTransfer record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AccountTransfer record ordered by the currency field
        accounttransfer = await AccountTransfer.prisma().find_first_or_raise(
            skip=1,
            order={
                'currency': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.AccountTransferUpdateInput,
        where: types.AccountTransferWhereUniqueInput,
        include: Optional[types.AccountTransferInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single AccountTransfer record.

        Parameters
        ----------
        data
            AccountTransfer record data specifying what to update
        where
            AccountTransfer filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned AccountTransfer model

        Returns
        -------
        prisma.models.AccountTransfer
            The updated AccountTransfer record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        accounttransfer = await AccountTransfer.prisma().update(
            where={
                'id': 1716228995,
            },
            data={
                # data to update the AccountTransfer record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.AccountTransferWhereUniqueInput,
        data: types.AccountTransferUpsertInput,
        include: Optional[types.AccountTransferInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            AccountTransfer filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned AccountTransfer model

        Returns
        -------
        prisma.models.AccountTransfer
            The created or updated AccountTransfer record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        accounttransfer = await AccountTransfer.prisma().upsert(
            where={
                'id': 1869736192,
            },
            data={
                'create': {
                    'id': 1869736192,
                    'fromAccountId': 804873448,
                    'toAccountId': 1566496513,
                    'amount': Decimal('850004390.210939'),
                    'currency': enums.Currency.USD,
                },
                'update': {
                    'fromAccountId': 804873448,
                    'toAccountId': 1566496513,
                    'amount': Decimal('850004390.210939'),
                    'currency': enums.Currency.USD,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.AccountTransferUpdateManyMutationInput,
        where: types.AccountTransferWhereInput,
    ) -> int:
        """Update multiple AccountTransfer records

        Parameters
        ----------
        data
            AccountTransfer data to update the selected AccountTransfer records to
        where
            Filter to select the AccountTransfer records to update

        Returns
        -------
        int
            The total number of AccountTransfer records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all AccountTransfer records
        total = await AccountTransfer.prisma().update_many(
            data={
                'rateApplied': Decimal('1585341753.2927')
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AccountTransferWhereInput] = None,
        cursor: Optional[types.AccountTransferWhereUniqueInput] = None,
    ) -> int:
        """Count the number of AccountTransfer records present in the database

        Parameters
        ----------
        select
            Select the AccountTransfer fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AccountTransfer filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AccountTransferCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AccountTransfer.prisma().count()

        # results: prisma.types.AccountTransferCountAggregateOutput
        results = await AccountTransfer.prisma().count(
            select={
                '_all': True,
                'note': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.AccountTransferCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AccountTransferWhereInput] = None,
        cursor: Optional[types.AccountTransferWhereUniqueInput] = None,
    ) -> types.AccountTransferCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.AccountTransferCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AccountTransferWhereInput] = None,
        cursor: Optional[types.AccountTransferWhereUniqueInput] = None,
    ) -> Union[int, types.AccountTransferCountAggregateOutput]:
        """Count the number of AccountTransfer records present in the database

        Parameters
        ----------
        select
            Select the AccountTransfer fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AccountTransfer filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AccountTransferCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AccountTransfer.prisma().count()

        # results: prisma.types.AccountTransferCountAggregateOutput
        results = await AccountTransfer.prisma().count(
            select={
                '_all': True,
                'status': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.AccountTransferCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.AccountTransferWhereInput] = None
    ) -> int:
        """Delete multiple AccountTransfer records.

        Parameters
        ----------
        where
            Optional AccountTransfer filter to find the records to be deleted

        Returns
        -------
        int
            The total number of AccountTransfer records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all AccountTransfer records
        total = await AccountTransfer.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.AccountTransferScalarFieldKeysT'],
        *,
        where: Optional['types.AccountTransferWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.AccountTransferAvgAggregateInput'] = None,
        sum: Optional['types.AccountTransferSumAggregateInput'] = None,
        min: Optional['types.AccountTransferMinAggregateInput'] = None,
        max: Optional['types.AccountTransferMaxAggregateInput'] = None,
        having: Optional['types.AccountTransferScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.AccountTransferCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.AccountTransferScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.AccountTransferScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.AccountTransferGroupByOutput']:
        """Group AccountTransfer records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar AccountTransfer fields to group records by
        where
            AccountTransfer filter to select records
        take
            Limit the maximum number of AccountTransfer records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.AccountTransferGroupByOutput]
            A list of dictionaries representing the AccountTransfer record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group AccountTransfer records by createdAt values
        # and count how many records are in each group
        results = await AccountTransfer.prisma().group_by(
            ['createdAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class BranchOrderActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.BranchOrder]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await BranchOrder.prisma().query_raw(
            'SELECT * FROM BranchOrder WHERE id = $1',
            1588192479,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.BranchOrder
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await BranchOrder.prisma().query_first(
            'SELECT * FROM BranchOrder WHERE branchId = $1',
            898405676,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.BranchOrderCreateInput,
        include: Optional[types.BranchOrderInclude] = None
    ) -> _PrismaModelT:
        """Create a new BranchOrder record.

        Parameters
        ----------
        data
            BranchOrder record data
        include
            Specifies which relations should be loaded on the returned BranchOrder model

        Returns
        -------
        prisma.models.BranchOrder
            The created BranchOrder record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a BranchOrder record from just the required fields
        branchorder = await BranchOrder.prisma().create(
            data={
                # data to create a BranchOrder record
                'branchId': 777460725,
                'requestedById': 437894538,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.BranchOrderCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple BranchOrder records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of BranchOrder record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await BranchOrder.prisma().create_many(
            data=[
                {
                    # data to create a BranchOrder record
                    'branchId': 393342971,
                    'requestedById': 163829784,
                },
                {
                    # data to create a BranchOrder record
                    'branchId': 248152689,
                    'requestedById': 341715030,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.BranchOrderWhereUniqueInput,
        include: Optional[types.BranchOrderInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single BranchOrder record.

        Parameters
        ----------
        where
            BranchOrder filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned BranchOrder model

        Returns
        -------
        prisma.models.BranchOrder
            The deleted BranchOrder record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        branchorder = await BranchOrder.prisma().delete(
            where={
                'id': 1692766423,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.BranchOrderWhereUniqueInput,
        include: Optional[types.BranchOrderInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique BranchOrder record.

        Parameters
        ----------
        where
            BranchOrder filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned BranchOrder model

        Returns
        -------
        prisma.models.BranchOrder
            The found BranchOrder record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        branchorder = await BranchOrder.prisma().find_unique(
            where={
                'id': 86662596,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.BranchOrderWhereUniqueInput,
        include: Optional[types.BranchOrderInclude] = None
    ) -> _PrismaModelT:
        """Find a unique BranchOrder record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            BranchOrder filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned BranchOrder model

        Returns
        -------
        prisma.models.BranchOrder
            The found BranchOrder record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        branchorder = await BranchOrder.prisma().find_unique_or_raise(
            where={
                'id': 1697895597,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BranchOrderWhereInput] = None,
        cursor: Optional[types.BranchOrderWhereUniqueInput] = None,
        include: Optional[types.BranchOrderInclude] = None,
        order: Optional[Union[types.BranchOrderOrderByInput, List[types.BranchOrderOrderByInput]]] = None,
        distinct: Optional[List[types.BranchOrderScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple BranchOrder records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of BranchOrder records returned
        skip
            Ignore the first N results
        where
            BranchOrder filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned BranchOrder model
        order
            Order the returned BranchOrder records by any field
        distinct
            Filter BranchOrder records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.BranchOrder]
            The list of all BranchOrder records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 BranchOrder records
        branchorders = await BranchOrder.prisma().find_many(take=10)

        # find the first 5 BranchOrder records ordered by the requestedById field
        branchorders = await BranchOrder.prisma().find_many(
            take=5,
            order={
                'requestedById': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.BranchOrderWhereInput] = None,
        cursor: Optional[types.BranchOrderWhereUniqueInput] = None,
        include: Optional[types.BranchOrderInclude] = None,
        order: Optional[Union[types.BranchOrderOrderByInput, List[types.BranchOrderOrderByInput]]] = None,
        distinct: Optional[List[types.BranchOrderScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single BranchOrder record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            BranchOrder filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned BranchOrder model
        order
            Order the returned BranchOrder records by any field
        distinct
            Filter BranchOrder records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.BranchOrder
            The first BranchOrder record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second BranchOrder record ordered by the approvedById field
        branchorder = await BranchOrder.prisma().find_first(
            skip=1,
            order={
                'approvedById': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.BranchOrderWhereInput] = None,
        cursor: Optional[types.BranchOrderWhereUniqueInput] = None,
        include: Optional[types.BranchOrderInclude] = None,
        order: Optional[Union[types.BranchOrderOrderByInput, List[types.BranchOrderOrderByInput]]] = None,
        distinct: Optional[List[types.BranchOrderScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single BranchOrder record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            BranchOrder filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned BranchOrder model
        order
            Order the returned BranchOrder records by any field
        distinct
            Filter BranchOrder records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.BranchOrder
            The first BranchOrder record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second BranchOrder record ordered by the sentById field
        branchorder = await BranchOrder.prisma().find_first_or_raise(
            skip=1,
            order={
                'sentById': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.BranchOrderUpdateInput,
        where: types.BranchOrderWhereUniqueInput,
        include: Optional[types.BranchOrderInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single BranchOrder record.

        Parameters
        ----------
        data
            BranchOrder record data specifying what to update
        where
            BranchOrder filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned BranchOrder model

        Returns
        -------
        prisma.models.BranchOrder
            The updated BranchOrder record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        branchorder = await BranchOrder.prisma().update(
            where={
                'id': 1286370274,
            },
            data={
                # data to update the BranchOrder record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.BranchOrderWhereUniqueInput,
        data: types.BranchOrderUpsertInput,
        include: Optional[types.BranchOrderInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            BranchOrder filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned BranchOrder model

        Returns
        -------
        prisma.models.BranchOrder
            The created or updated BranchOrder record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        branchorder = await BranchOrder.prisma().upsert(
            where={
                'id': 864576371,
            },
            data={
                'create': {
                    'id': 864576371,
                    'branchId': 248152689,
                    'requestedById': 341715030,
                },
                'update': {
                    'branchId': 248152689,
                    'requestedById': 341715030,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.BranchOrderUpdateManyMutationInput,
        where: types.BranchOrderWhereInput,
    ) -> int:
        """Update multiple BranchOrder records

        Parameters
        ----------
        data
            BranchOrder data to update the selected BranchOrder records to
        where
            Filter to select the BranchOrder records to update

        Returns
        -------
        int
            The total number of BranchOrder records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all BranchOrder records
        total = await BranchOrder.prisma().update_many(
            data={
                'receivedById': 491885104
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BranchOrderWhereInput] = None,
        cursor: Optional[types.BranchOrderWhereUniqueInput] = None,
    ) -> int:
        """Count the number of BranchOrder records present in the database

        Parameters
        ----------
        select
            Select the BranchOrder fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            BranchOrder filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.BranchOrderCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await BranchOrder.prisma().count()

        # results: prisma.types.BranchOrderCountAggregateOutput
        results = await BranchOrder.prisma().count(
            select={
                '_all': True,
                'status': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.BranchOrderCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BranchOrderWhereInput] = None,
        cursor: Optional[types.BranchOrderWhereUniqueInput] = None,
    ) -> types.BranchOrderCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.BranchOrderCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BranchOrderWhereInput] = None,
        cursor: Optional[types.BranchOrderWhereUniqueInput] = None,
    ) -> Union[int, types.BranchOrderCountAggregateOutput]:
        """Count the number of BranchOrder records present in the database

        Parameters
        ----------
        select
            Select the BranchOrder fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            BranchOrder filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.BranchOrderCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await BranchOrder.prisma().count()

        # results: prisma.types.BranchOrderCountAggregateOutput
        results = await BranchOrder.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.BranchOrderCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.BranchOrderWhereInput] = None
    ) -> int:
        """Delete multiple BranchOrder records.

        Parameters
        ----------
        where
            Optional BranchOrder filter to find the records to be deleted

        Returns
        -------
        int
            The total number of BranchOrder records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all BranchOrder records
        total = await BranchOrder.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.BranchOrderScalarFieldKeysT'],
        *,
        where: Optional['types.BranchOrderWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.BranchOrderAvgAggregateInput'] = None,
        sum: Optional['types.BranchOrderSumAggregateInput'] = None,
        min: Optional['types.BranchOrderMinAggregateInput'] = None,
        max: Optional['types.BranchOrderMaxAggregateInput'] = None,
        having: Optional['types.BranchOrderScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.BranchOrderCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.BranchOrderScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.BranchOrderScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.BranchOrderGroupByOutput']:
        """Group BranchOrder records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar BranchOrder fields to group records by
        where
            BranchOrder filter to select records
        take
            Limit the maximum number of BranchOrder records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.BranchOrderGroupByOutput]
            A list of dictionaries representing the BranchOrder record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group BranchOrder records by updatedAt values
        # and count how many records are in each group
        results = await BranchOrder.prisma().group_by(
            ['updatedAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class BranchOrderItemActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.BranchOrderItem]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await BranchOrderItem.prisma().query_raw(
            'SELECT * FROM BranchOrderItem WHERE id = $1',
            392564393,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.BranchOrderItem
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await BranchOrderItem.prisma().query_first(
            'SELECT * FROM BranchOrderItem WHERE branchOrderId = $1',
            1319234606,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.BranchOrderItemCreateInput,
        include: Optional[types.BranchOrderItemInclude] = None
    ) -> _PrismaModelT:
        """Create a new BranchOrderItem record.

        Parameters
        ----------
        data
            BranchOrderItem record data
        include
            Specifies which relations should be loaded on the returned BranchOrderItem model

        Returns
        -------
        prisma.models.BranchOrderItem
            The created BranchOrderItem record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a BranchOrderItem record from just the required fields
        branchorderitem = await BranchOrderItem.prisma().create(
            data={
                # data to create a BranchOrderItem record
                'branchOrderId': 712754127,
                'stockId': 1299554652,
                'requestedQty': 2070408293,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.BranchOrderItemCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple BranchOrderItem records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of BranchOrderItem record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await BranchOrderItem.prisma().create_many(
            data=[
                {
                    # data to create a BranchOrderItem record
                    'branchOrderId': 811900218,
                    'stockId': 396021227,
                    'requestedQty': 644446024,
                },
                {
                    # data to create a BranchOrderItem record
                    'branchOrderId': 116386273,
                    'stockId': 309285638,
                    'requestedQty': 22437319,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.BranchOrderItemWhereUniqueInput,
        include: Optional[types.BranchOrderItemInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single BranchOrderItem record.

        Parameters
        ----------
        where
            BranchOrderItem filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned BranchOrderItem model

        Returns
        -------
        prisma.models.BranchOrderItem
            The deleted BranchOrderItem record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        branchorderitem = await BranchOrderItem.prisma().delete(
            where={
                'id': 1900199924,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.BranchOrderItemWhereUniqueInput,
        include: Optional[types.BranchOrderItemInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique BranchOrderItem record.

        Parameters
        ----------
        where
            BranchOrderItem filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned BranchOrderItem model

        Returns
        -------
        prisma.models.BranchOrderItem
            The found BranchOrderItem record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        branchorderitem = await BranchOrderItem.prisma().find_unique(
            where={
                'id': 2057323293,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.BranchOrderItemWhereUniqueInput,
        include: Optional[types.BranchOrderItemInclude] = None
    ) -> _PrismaModelT:
        """Find a unique BranchOrderItem record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            BranchOrderItem filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned BranchOrderItem model

        Returns
        -------
        prisma.models.BranchOrderItem
            The found BranchOrderItem record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        branchorderitem = await BranchOrderItem.prisma().find_unique_or_raise(
            where={
                'id': 1344117138,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BranchOrderItemWhereInput] = None,
        cursor: Optional[types.BranchOrderItemWhereUniqueInput] = None,
        include: Optional[types.BranchOrderItemInclude] = None,
        order: Optional[Union[types.BranchOrderItemOrderByInput, List[types.BranchOrderItemOrderByInput]]] = None,
        distinct: Optional[List[types.BranchOrderItemScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple BranchOrderItem records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of BranchOrderItem records returned
        skip
            Ignore the first N results
        where
            BranchOrderItem filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned BranchOrderItem model
        order
            Order the returned BranchOrderItem records by any field
        distinct
            Filter BranchOrderItem records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.BranchOrderItem]
            The list of all BranchOrderItem records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 BranchOrderItem records
        branchorderitems = await BranchOrderItem.prisma().find_many(take=10)

        # find the first 5 BranchOrderItem records ordered by the stockId field
        branchorderitems = await BranchOrderItem.prisma().find_many(
            take=5,
            order={
                'stockId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.BranchOrderItemWhereInput] = None,
        cursor: Optional[types.BranchOrderItemWhereUniqueInput] = None,
        include: Optional[types.BranchOrderItemInclude] = None,
        order: Optional[Union[types.BranchOrderItemOrderByInput, List[types.BranchOrderItemOrderByInput]]] = None,
        distinct: Optional[List[types.BranchOrderItemScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single BranchOrderItem record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            BranchOrderItem filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned BranchOrderItem model
        order
            Order the returned BranchOrderItem records by any field
        distinct
            Filter BranchOrderItem records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.BranchOrderItem
            The first BranchOrderItem record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second BranchOrderItem record ordered by the requestedQty field
        branchorderitem = await BranchOrderItem.prisma().find_first(
            skip=1,
            order={
                'requestedQty': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.BranchOrderItemWhereInput] = None,
        cursor: Optional[types.BranchOrderItemWhereUniqueInput] = None,
        include: Optional[types.BranchOrderItemInclude] = None,
        order: Optional[Union[types.BranchOrderItemOrderByInput, List[types.BranchOrderItemOrderByInput]]] = None,
        distinct: Optional[List[types.BranchOrderItemScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single BranchOrderItem record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            BranchOrderItem filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned BranchOrderItem model
        order
            Order the returned BranchOrderItem records by any field
        distinct
            Filter BranchOrderItem records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.BranchOrderItem
            The first BranchOrderItem record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second BranchOrderItem record ordered by the approvedQty field
        branchorderitem = await BranchOrderItem.prisma().find_first_or_raise(
            skip=1,
            order={
                'approvedQty': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.BranchOrderItemUpdateInput,
        where: types.BranchOrderItemWhereUniqueInput,
        include: Optional[types.BranchOrderItemInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single BranchOrderItem record.

        Parameters
        ----------
        data
            BranchOrderItem record data specifying what to update
        where
            BranchOrderItem filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned BranchOrderItem model

        Returns
        -------
        prisma.models.BranchOrderItem
            The updated BranchOrderItem record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        branchorderitem = await BranchOrderItem.prisma().update(
            where={
                'id': 2052132707,
            },
            data={
                # data to update the BranchOrderItem record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.BranchOrderItemWhereUniqueInput,
        data: types.BranchOrderItemUpsertInput,
        include: Optional[types.BranchOrderItemInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            BranchOrderItem filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned BranchOrderItem model

        Returns
        -------
        prisma.models.BranchOrderItem
            The created or updated BranchOrderItem record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        branchorderitem = await BranchOrderItem.prisma().upsert(
            where={
                'id': 1355147104,
            },
            data={
                'create': {
                    'id': 1355147104,
                    'branchOrderId': 116386273,
                    'stockId': 309285638,
                    'requestedQty': 22437319,
                },
                'update': {
                    'branchOrderId': 116386273,
                    'stockId': 309285638,
                    'requestedQty': 22437319,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.BranchOrderItemUpdateManyMutationInput,
        where: types.BranchOrderItemWhereInput,
    ) -> int:
        """Update multiple BranchOrderItem records

        Parameters
        ----------
        data
            BranchOrderItem data to update the selected BranchOrderItem records to
        where
            Filter to select the BranchOrderItem records to update

        Returns
        -------
        int
            The total number of BranchOrderItem records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all BranchOrderItem records
        total = await BranchOrderItem.prisma().update_many(
            data={
                'sentQty': 84079641
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BranchOrderItemWhereInput] = None,
        cursor: Optional[types.BranchOrderItemWhereUniqueInput] = None,
    ) -> int:
        """Count the number of BranchOrderItem records present in the database

        Parameters
        ----------
        select
            Select the BranchOrderItem fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            BranchOrderItem filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.BranchOrderItemCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await BranchOrderItem.prisma().count()

        # results: prisma.types.BranchOrderItemCountAggregateOutput
        results = await BranchOrderItem.prisma().count(
            select={
                '_all': True,
                'receivedQty': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.BranchOrderItemCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BranchOrderItemWhereInput] = None,
        cursor: Optional[types.BranchOrderItemWhereUniqueInput] = None,
    ) -> types.BranchOrderItemCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.BranchOrderItemCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BranchOrderItemWhereInput] = None,
        cursor: Optional[types.BranchOrderItemWhereUniqueInput] = None,
    ) -> Union[int, types.BranchOrderItemCountAggregateOutput]:
        """Count the number of BranchOrderItem records present in the database

        Parameters
        ----------
        select
            Select the BranchOrderItem fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            BranchOrderItem filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.BranchOrderItemCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await BranchOrderItem.prisma().count()

        # results: prisma.types.BranchOrderItemCountAggregateOutput
        results = await BranchOrderItem.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.BranchOrderItemCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.BranchOrderItemWhereInput] = None
    ) -> int:
        """Delete multiple BranchOrderItem records.

        Parameters
        ----------
        where
            Optional BranchOrderItem filter to find the records to be deleted

        Returns
        -------
        int
            The total number of BranchOrderItem records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all BranchOrderItem records
        total = await BranchOrderItem.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.BranchOrderItemScalarFieldKeysT'],
        *,
        where: Optional['types.BranchOrderItemWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.BranchOrderItemAvgAggregateInput'] = None,
        sum: Optional['types.BranchOrderItemSumAggregateInput'] = None,
        min: Optional['types.BranchOrderItemMinAggregateInput'] = None,
        max: Optional['types.BranchOrderItemMaxAggregateInput'] = None,
        having: Optional['types.BranchOrderItemScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.BranchOrderItemCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.BranchOrderItemScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.BranchOrderItemScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.BranchOrderItemGroupByOutput']:
        """Group BranchOrderItem records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar BranchOrderItem fields to group records by
        where
            BranchOrderItem filter to select records
        take
            Limit the maximum number of BranchOrderItem records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.BranchOrderItemGroupByOutput]
            A list of dictionaries representing the BranchOrderItem record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group BranchOrderItem records by branchOrderId values
        # and count how many records are in each group
        results = await BranchOrderItem.prisma().group_by(
            ['branchOrderId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class AuditLogActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.AuditLog]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await AuditLog.prisma().query_raw(
            'SELECT * FROM AuditLog WHERE id = $1',
            754433246,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.AuditLog
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await AuditLog.prisma().query_first(
            'SELECT * FROM AuditLog WHERE userId = $1',
            314261183,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.AuditLogCreateInput,
        include: Optional[types.AuditLogInclude] = None
    ) -> _PrismaModelT:
        """Create a new AuditLog record.

        Parameters
        ----------
        data
            AuditLog record data
        include
            Specifies which relations should be loaded on the returned AuditLog model

        Returns
        -------
        prisma.models.AuditLog
            The created AuditLog record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a AuditLog record from just the required fields
        auditlog = await AuditLog.prisma().create(
            data={
                # data to create a AuditLog record
                'action': enums.AuditAction.CREATE,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.AuditLogCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple AuditLog records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of AuditLog record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await AuditLog.prisma().create_many(
            data=[
                {
                    # data to create a AuditLog record
                    'action': enums.AuditAction.CREATE,
                },
                {
                    # data to create a AuditLog record
                    'action': enums.AuditAction.CREATE,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.AuditLogWhereUniqueInput,
        include: Optional[types.AuditLogInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single AuditLog record.

        Parameters
        ----------
        where
            AuditLog filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned AuditLog model

        Returns
        -------
        prisma.models.AuditLog
            The deleted AuditLog record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        auditlog = await AuditLog.prisma().delete(
            where={
                'id': 227678604,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.AuditLogWhereUniqueInput,
        include: Optional[types.AuditLogInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique AuditLog record.

        Parameters
        ----------
        where
            AuditLog filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AuditLog model

        Returns
        -------
        prisma.models.AuditLog
            The found AuditLog record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        auditlog = await AuditLog.prisma().find_unique(
            where={
                'id': 423999701,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.AuditLogWhereUniqueInput,
        include: Optional[types.AuditLogInclude] = None
    ) -> _PrismaModelT:
        """Find a unique AuditLog record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            AuditLog filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AuditLog model

        Returns
        -------
        prisma.models.AuditLog
            The found AuditLog record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        auditlog = await AuditLog.prisma().find_unique_or_raise(
            where={
                'id': 180275434,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AuditLogWhereInput] = None,
        cursor: Optional[types.AuditLogWhereUniqueInput] = None,
        include: Optional[types.AuditLogInclude] = None,
        order: Optional[Union[types.AuditLogOrderByInput, List[types.AuditLogOrderByInput]]] = None,
        distinct: Optional[List[types.AuditLogScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple AuditLog records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of AuditLog records returned
        skip
            Ignore the first N results
        where
            AuditLog filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AuditLog model
        order
            Order the returned AuditLog records by any field
        distinct
            Filter AuditLog records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.AuditLog]
            The list of all AuditLog records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 AuditLog records
        auditlogs = await AuditLog.prisma().find_many(take=10)

        # find the first 5 AuditLog records ordered by the action field
        auditlogs = await AuditLog.prisma().find_many(
            take=5,
            order={
                'action': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AuditLogWhereInput] = None,
        cursor: Optional[types.AuditLogWhereUniqueInput] = None,
        include: Optional[types.AuditLogInclude] = None,
        order: Optional[Union[types.AuditLogOrderByInput, List[types.AuditLogOrderByInput]]] = None,
        distinct: Optional[List[types.AuditLogScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single AuditLog record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AuditLog filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AuditLog model
        order
            Order the returned AuditLog records by any field
        distinct
            Filter AuditLog records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AuditLog
            The first AuditLog record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AuditLog record ordered by the entityType field
        auditlog = await AuditLog.prisma().find_first(
            skip=1,
            order={
                'entityType': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AuditLogWhereInput] = None,
        cursor: Optional[types.AuditLogWhereUniqueInput] = None,
        include: Optional[types.AuditLogInclude] = None,
        order: Optional[Union[types.AuditLogOrderByInput, List[types.AuditLogOrderByInput]]] = None,
        distinct: Optional[List[types.AuditLogScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single AuditLog record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AuditLog filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AuditLog model
        order
            Order the returned AuditLog records by any field
        distinct
            Filter AuditLog records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AuditLog
            The first AuditLog record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AuditLog record ordered by the entityId field
        auditlog = await AuditLog.prisma().find_first_or_raise(
            skip=1,
            order={
                'entityId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.AuditLogUpdateInput,
        where: types.AuditLogWhereUniqueInput,
        include: Optional[types.AuditLogInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single AuditLog record.

        Parameters
        ----------
        data
            AuditLog record data specifying what to update
        where
            AuditLog filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned AuditLog model

        Returns
        -------
        prisma.models.AuditLog
            The updated AuditLog record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        auditlog = await AuditLog.prisma().update(
            where={
                'id': 57608155,
            },
            data={
                # data to update the AuditLog record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.AuditLogWhereUniqueInput,
        data: types.AuditLogUpsertInput,
        include: Optional[types.AuditLogInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            AuditLog filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned AuditLog model

        Returns
        -------
        prisma.models.AuditLog
            The created or updated AuditLog record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        auditlog = await AuditLog.prisma().upsert(
            where={
                'id': 2030912120,
            },
            data={
                'create': {
                    'id': 2030912120,
                    'action': enums.AuditAction.CREATE,
                },
                'update': {
                    'action': enums.AuditAction.CREATE,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.AuditLogUpdateManyMutationInput,
        where: types.AuditLogWhereInput,
    ) -> int:
        """Update multiple AuditLog records

        Parameters
        ----------
        data
            AuditLog data to update the selected AuditLog records to
        where
            Filter to select the AuditLog records to update

        Returns
        -------
        int
            The total number of AuditLog records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all AuditLog records
        total = await AuditLog.prisma().update_many(
            data={
                'oldValues': Json({'bjheigfcdd': True})
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AuditLogWhereInput] = None,
        cursor: Optional[types.AuditLogWhereUniqueInput] = None,
    ) -> int:
        """Count the number of AuditLog records present in the database

        Parameters
        ----------
        select
            Select the AuditLog fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AuditLog filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AuditLogCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AuditLog.prisma().count()

        # results: prisma.types.AuditLogCountAggregateOutput
        results = await AuditLog.prisma().count(
            select={
                '_all': True,
                'newValues': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.AuditLogCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AuditLogWhereInput] = None,
        cursor: Optional[types.AuditLogWhereUniqueInput] = None,
    ) -> types.AuditLogCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.AuditLogCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AuditLogWhereInput] = None,
        cursor: Optional[types.AuditLogWhereUniqueInput] = None,
    ) -> Union[int, types.AuditLogCountAggregateOutput]:
        """Count the number of AuditLog records present in the database

        Parameters
        ----------
        select
            Select the AuditLog fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AuditLog filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AuditLogCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AuditLog.prisma().count()

        # results: prisma.types.AuditLogCountAggregateOutput
        results = await AuditLog.prisma().count(
            select={
                '_all': True,
                'severity': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.AuditLogCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.AuditLogWhereInput] = None
    ) -> int:
        """Delete multiple AuditLog records.

        Parameters
        ----------
        where
            Optional AuditLog filter to find the records to be deleted

        Returns
        -------
        int
            The total number of AuditLog records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all AuditLog records
        total = await AuditLog.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.AuditLogScalarFieldKeysT'],
        *,
        where: Optional['types.AuditLogWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.AuditLogAvgAggregateInput'] = None,
        sum: Optional['types.AuditLogSumAggregateInput'] = None,
        min: Optional['types.AuditLogMinAggregateInput'] = None,
        max: Optional['types.AuditLogMaxAggregateInput'] = None,
        having: Optional['types.AuditLogScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.AuditLogCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.AuditLogScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.AuditLogScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.AuditLogGroupByOutput']:
        """Group AuditLog records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar AuditLog fields to group records by
        where
            AuditLog filter to select records
        take
            Limit the maximum number of AuditLog records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.AuditLogGroupByOutput]
            A list of dictionaries representing the AuditLog record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group AuditLog records by ipAddress values
        # and count how many records are in each group
        results = await AuditLog.prisma().group_by(
            ['ipAddress'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class SystemInfoActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.SystemInfo]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await SystemInfo.prisma().query_raw(
            'SELECT * FROM SystemInfo WHERE id = $1',
            1949862326,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.SystemInfo
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await SystemInfo.prisma().query_first(
            'SELECT * FROM SystemInfo WHERE systemName = $1',
            'bifiiibcah',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.SystemInfoCreateInput,
        include: Optional[types.SystemInfoInclude] = None
    ) -> _PrismaModelT:
        """Create a new SystemInfo record.

        Parameters
        ----------
        data
            SystemInfo record data
        include
            Specifies which relations should be loaded on the returned SystemInfo model

        Returns
        -------
        prisma.models.SystemInfo
            The created SystemInfo record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a SystemInfo record from just the required fields
        systeminfo = await SystemInfo.prisma().create(
            data={
                # data to create a SystemInfo record
                'systemName': 'dbjibjdaa',
                'environment': enums.Environment.DEV,
                'baseCurrency': enums.Currency.USD,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.SystemInfoCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple SystemInfo records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of SystemInfo record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await SystemInfo.prisma().create_many(
            data=[
                {
                    # data to create a SystemInfo record
                    'systemName': 'dgijbdiaf',
                    'environment': enums.Environment.DEV,
                    'baseCurrency': enums.Currency.USD,
                },
                {
                    # data to create a SystemInfo record
                    'systemName': 'begfaigba',
                    'environment': enums.Environment.DEV,
                    'baseCurrency': enums.Currency.USD,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.SystemInfoWhereUniqueInput,
        include: Optional[types.SystemInfoInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single SystemInfo record.

        Parameters
        ----------
        where
            SystemInfo filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned SystemInfo model

        Returns
        -------
        prisma.models.SystemInfo
            The deleted SystemInfo record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        systeminfo = await SystemInfo.prisma().delete(
            where={
                'id': 1398052691,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.SystemInfoWhereUniqueInput,
        include: Optional[types.SystemInfoInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique SystemInfo record.

        Parameters
        ----------
        where
            SystemInfo filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned SystemInfo model

        Returns
        -------
        prisma.models.SystemInfo
            The found SystemInfo record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        systeminfo = await SystemInfo.prisma().find_unique(
            where={
                'id': 1582426256,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.SystemInfoWhereUniqueInput,
        include: Optional[types.SystemInfoInclude] = None
    ) -> _PrismaModelT:
        """Find a unique SystemInfo record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            SystemInfo filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned SystemInfo model

        Returns
        -------
        prisma.models.SystemInfo
            The found SystemInfo record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        systeminfo = await SystemInfo.prisma().find_unique_or_raise(
            where={
                'id': 219944329,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SystemInfoWhereInput] = None,
        cursor: Optional[types.SystemInfoWhereUniqueInput] = None,
        include: Optional[types.SystemInfoInclude] = None,
        order: Optional[Union[types.SystemInfoOrderByInput, List[types.SystemInfoOrderByInput]]] = None,
        distinct: Optional[List[types.SystemInfoScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple SystemInfo records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of SystemInfo records returned
        skip
            Ignore the first N results
        where
            SystemInfo filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned SystemInfo model
        order
            Order the returned SystemInfo records by any field
        distinct
            Filter SystemInfo records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.SystemInfo]
            The list of all SystemInfo records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 SystemInfo records
        systeminfos = await SystemInfo.prisma().find_many(take=10)

        # find the first 5 SystemInfo records ordered by the version field
        systeminfos = await SystemInfo.prisma().find_many(
            take=5,
            order={
                'version': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SystemInfoWhereInput] = None,
        cursor: Optional[types.SystemInfoWhereUniqueInput] = None,
        include: Optional[types.SystemInfoInclude] = None,
        order: Optional[Union[types.SystemInfoOrderByInput, List[types.SystemInfoOrderByInput]]] = None,
        distinct: Optional[List[types.SystemInfoScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single SystemInfo record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            SystemInfo filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned SystemInfo model
        order
            Order the returned SystemInfo records by any field
        distinct
            Filter SystemInfo records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.SystemInfo
            The first SystemInfo record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second SystemInfo record ordered by the environment field
        systeminfo = await SystemInfo.prisma().find_first(
            skip=1,
            order={
                'environment': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SystemInfoWhereInput] = None,
        cursor: Optional[types.SystemInfoWhereUniqueInput] = None,
        include: Optional[types.SystemInfoInclude] = None,
        order: Optional[Union[types.SystemInfoOrderByInput, List[types.SystemInfoOrderByInput]]] = None,
        distinct: Optional[List[types.SystemInfoScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single SystemInfo record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            SystemInfo filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned SystemInfo model
        order
            Order the returned SystemInfo records by any field
        distinct
            Filter SystemInfo records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.SystemInfo
            The first SystemInfo record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second SystemInfo record ordered by the companyName field
        systeminfo = await SystemInfo.prisma().find_first_or_raise(
            skip=1,
            order={
                'companyName': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.SystemInfoUpdateInput,
        where: types.SystemInfoWhereUniqueInput,
        include: Optional[types.SystemInfoInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single SystemInfo record.

        Parameters
        ----------
        data
            SystemInfo record data specifying what to update
        where
            SystemInfo filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned SystemInfo model

        Returns
        -------
        prisma.models.SystemInfo
            The updated SystemInfo record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        systeminfo = await SystemInfo.prisma().update(
            where={
                'id': 343611790,
            },
            data={
                # data to update the SystemInfo record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.SystemInfoWhereUniqueInput,
        data: types.SystemInfoUpsertInput,
        include: Optional[types.SystemInfoInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            SystemInfo filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned SystemInfo model

        Returns
        -------
        prisma.models.SystemInfo
            The created or updated SystemInfo record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        systeminfo = await SystemInfo.prisma().upsert(
            where={
                'id': 201807279,
            },
            data={
                'create': {
                    'id': 201807279,
                    'systemName': 'begfaigba',
                    'environment': enums.Environment.DEV,
                    'baseCurrency': enums.Currency.USD,
                },
                'update': {
                    'systemName': 'begfaigba',
                    'environment': enums.Environment.DEV,
                    'baseCurrency': enums.Currency.USD,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.SystemInfoUpdateManyMutationInput,
        where: types.SystemInfoWhereInput,
    ) -> int:
        """Update multiple SystemInfo records

        Parameters
        ----------
        data
            SystemInfo data to update the selected SystemInfo records to
        where
            Filter to select the SystemInfo records to update

        Returns
        -------
        int
            The total number of SystemInfo records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all SystemInfo records
        total = await SystemInfo.prisma().update_many(
            data={
                'companyEmail': 'cgbeccfce'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SystemInfoWhereInput] = None,
        cursor: Optional[types.SystemInfoWhereUniqueInput] = None,
    ) -> int:
        """Count the number of SystemInfo records present in the database

        Parameters
        ----------
        select
            Select the SystemInfo fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            SystemInfo filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SystemInfoCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await SystemInfo.prisma().count()

        # results: prisma.types.SystemInfoCountAggregateOutput
        results = await SystemInfo.prisma().count(
            select={
                '_all': True,
                'companyPhone': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.SystemInfoCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SystemInfoWhereInput] = None,
        cursor: Optional[types.SystemInfoWhereUniqueInput] = None,
    ) -> types.SystemInfoCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.SystemInfoCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SystemInfoWhereInput] = None,
        cursor: Optional[types.SystemInfoWhereUniqueInput] = None,
    ) -> Union[int, types.SystemInfoCountAggregateOutput]:
        """Count the number of SystemInfo records present in the database

        Parameters
        ----------
        select
            Select the SystemInfo fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            SystemInfo filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SystemInfoCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await SystemInfo.prisma().count()

        # results: prisma.types.SystemInfoCountAggregateOutput
        results = await SystemInfo.prisma().count(
            select={
                '_all': True,
                'companyAddress': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.SystemInfoCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.SystemInfoWhereInput] = None
    ) -> int:
        """Delete multiple SystemInfo records.

        Parameters
        ----------
        where
            Optional SystemInfo filter to find the records to be deleted

        Returns
        -------
        int
            The total number of SystemInfo records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all SystemInfo records
        total = await SystemInfo.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.SystemInfoScalarFieldKeysT'],
        *,
        where: Optional['types.SystemInfoWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.SystemInfoAvgAggregateInput'] = None,
        sum: Optional['types.SystemInfoSumAggregateInput'] = None,
        min: Optional['types.SystemInfoMinAggregateInput'] = None,
        max: Optional['types.SystemInfoMaxAggregateInput'] = None,
        having: Optional['types.SystemInfoScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.SystemInfoCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.SystemInfoScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.SystemInfoScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.SystemInfoGroupByOutput']:
        """Group SystemInfo records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar SystemInfo fields to group records by
        where
            SystemInfo filter to select records
        take
            Limit the maximum number of SystemInfo records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.SystemInfoGroupByOutput]
            A list of dictionaries representing the SystemInfo record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group SystemInfo records by baseCurrency values
        # and count how many records are in each group
        results = await SystemInfo.prisma().group_by(
            ['baseCurrency'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class BackupActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Backup]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Backup.prisma().query_raw(
            'SELECT * FROM Backup WHERE id = $1',
            52920645,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Backup
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Backup.prisma().query_first(
            'SELECT * FROM Backup WHERE type = $1',
            enums.BackupType.FULL,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.BackupCreateInput,
        include: Optional[types.BackupInclude] = None
    ) -> _PrismaModelT:
        """Create a new Backup record.

        Parameters
        ----------
        data
            Backup record data
        include
            Specifies which relations should be loaded on the returned Backup model

        Returns
        -------
        prisma.models.Backup
            The created Backup record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Backup record from just the required fields
        backup = await Backup.prisma().create(
            data={
                # data to create a Backup record
                'type': enums.BackupType.FULL,
                'location': 'bgdhaeacic',
                'status': enums.BackupStatus.PENDING,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.BackupCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Backup records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Backup record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Backup.prisma().create_many(
            data=[
                {
                    # data to create a Backup record
                    'type': enums.BackupType.FULL,
                    'location': 'caffafcheh',
                    'status': enums.BackupStatus.PENDING,
                },
                {
                    # data to create a Backup record
                    'type': enums.BackupType.FULL,
                    'location': 'fjjbegge',
                    'status': enums.BackupStatus.PENDING,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.BackupWhereUniqueInput,
        include: Optional[types.BackupInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Backup record.

        Parameters
        ----------
        where
            Backup filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Backup model

        Returns
        -------
        prisma.models.Backup
            The deleted Backup record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        backup = await Backup.prisma().delete(
            where={
                'id': 1388571841,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.BackupWhereUniqueInput,
        include: Optional[types.BackupInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Backup record.

        Parameters
        ----------
        where
            Backup filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Backup model

        Returns
        -------
        prisma.models.Backup
            The found Backup record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        backup = await Backup.prisma().find_unique(
            where={
                'id': 232049766,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.BackupWhereUniqueInput,
        include: Optional[types.BackupInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Backup record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Backup filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Backup model

        Returns
        -------
        prisma.models.Backup
            The found Backup record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        backup = await Backup.prisma().find_unique_or_raise(
            where={
                'id': 918965159,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BackupWhereInput] = None,
        cursor: Optional[types.BackupWhereUniqueInput] = None,
        include: Optional[types.BackupInclude] = None,
        order: Optional[Union[types.BackupOrderByInput, List[types.BackupOrderByInput]]] = None,
        distinct: Optional[List[types.BackupScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Backup records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Backup records returned
        skip
            Ignore the first N results
        where
            Backup filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Backup model
        order
            Order the returned Backup records by any field
        distinct
            Filter Backup records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Backup]
            The list of all Backup records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Backup records
        backups = await Backup.prisma().find_many(take=10)

        # find the first 5 Backup records ordered by the location field
        backups = await Backup.prisma().find_many(
            take=5,
            order={
                'location': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.BackupWhereInput] = None,
        cursor: Optional[types.BackupWhereUniqueInput] = None,
        include: Optional[types.BackupInclude] = None,
        order: Optional[Union[types.BackupOrderByInput, List[types.BackupOrderByInput]]] = None,
        distinct: Optional[List[types.BackupScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Backup record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Backup filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Backup model
        order
            Order the returned Backup records by any field
        distinct
            Filter Backup records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Backup
            The first Backup record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Backup record ordered by the fileName field
        backup = await Backup.prisma().find_first(
            skip=1,
            order={
                'fileName': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.BackupWhereInput] = None,
        cursor: Optional[types.BackupWhereUniqueInput] = None,
        include: Optional[types.BackupInclude] = None,
        order: Optional[Union[types.BackupOrderByInput, List[types.BackupOrderByInput]]] = None,
        distinct: Optional[List[types.BackupScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Backup record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Backup filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Backup model
        order
            Order the returned Backup records by any field
        distinct
            Filter Backup records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Backup
            The first Backup record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Backup record ordered by the sizeMB field
        backup = await Backup.prisma().find_first_or_raise(
            skip=1,
            order={
                'sizeMB': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.BackupUpdateInput,
        where: types.BackupWhereUniqueInput,
        include: Optional[types.BackupInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Backup record.

        Parameters
        ----------
        data
            Backup record data specifying what to update
        where
            Backup filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Backup model

        Returns
        -------
        prisma.models.Backup
            The updated Backup record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        backup = await Backup.prisma().update(
            where={
                'id': 665143380,
            },
            data={
                # data to update the Backup record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.BackupWhereUniqueInput,
        data: types.BackupUpsertInput,
        include: Optional[types.BackupInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Backup filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Backup model

        Returns
        -------
        prisma.models.Backup
            The created or updated Backup record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        backup = await Backup.prisma().upsert(
            where={
                'id': 39949309,
            },
            data={
                'create': {
                    'id': 39949309,
                    'type': enums.BackupType.FULL,
                    'location': 'fjjbegge',
                    'status': enums.BackupStatus.PENDING,
                },
                'update': {
                    'type': enums.BackupType.FULL,
                    'location': 'fjjbegge',
                    'status': enums.BackupStatus.PENDING,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.BackupUpdateManyMutationInput,
        where: types.BackupWhereInput,
    ) -> int:
        """Update multiple Backup records

        Parameters
        ----------
        data
            Backup data to update the selected Backup records to
        where
            Filter to select the Backup records to update

        Returns
        -------
        int
            The total number of Backup records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Backup records
        total = await Backup.prisma().update_many(
            data={
                'status': enums.BackupStatus.PENDING
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BackupWhereInput] = None,
        cursor: Optional[types.BackupWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Backup records present in the database

        Parameters
        ----------
        select
            Select the Backup fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Backup filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.BackupCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Backup.prisma().count()

        # results: prisma.types.BackupCountAggregateOutput
        results = await Backup.prisma().count(
            select={
                '_all': True,
                'errorLog': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.BackupCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BackupWhereInput] = None,
        cursor: Optional[types.BackupWhereUniqueInput] = None,
    ) -> types.BackupCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.BackupCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BackupWhereInput] = None,
        cursor: Optional[types.BackupWhereUniqueInput] = None,
    ) -> Union[int, types.BackupCountAggregateOutput]:
        """Count the number of Backup records present in the database

        Parameters
        ----------
        select
            Select the Backup fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Backup filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.BackupCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Backup.prisma().count()

        # results: prisma.types.BackupCountAggregateOutput
        results = await Backup.prisma().count(
            select={
                '_all': True,
                'createdById': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.BackupCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.BackupWhereInput] = None
    ) -> int:
        """Delete multiple Backup records.

        Parameters
        ----------
        where
            Optional Backup filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Backup records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Backup records
        total = await Backup.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.BackupScalarFieldKeysT'],
        *,
        where: Optional['types.BackupWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.BackupAvgAggregateInput'] = None,
        sum: Optional['types.BackupSumAggregateInput'] = None,
        min: Optional['types.BackupMinAggregateInput'] = None,
        max: Optional['types.BackupMaxAggregateInput'] = None,
        having: Optional['types.BackupScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.BackupCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.BackupScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.BackupScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.BackupGroupByOutput']:
        """Group Backup records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Backup fields to group records by
        where
            Backup filter to select records
        take
            Limit the maximum number of Backup records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.BackupGroupByOutput]
            A list of dictionaries representing the Backup record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Backup records by createdAt values
        # and count how many records are in each group
        results = await Backup.prisma().group_by(
            ['createdAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class RevokedTokenActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.RevokedToken]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await RevokedToken.prisma().query_raw(
            'SELECT * FROM RevokedToken WHERE id = $1',
            1901152498,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.RevokedToken
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await RevokedToken.prisma().query_first(
            'SELECT * FROM RevokedToken WHERE jti = $1',
            'bgchfbjibb',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.RevokedTokenCreateInput,
        include: Optional[types.RevokedTokenInclude] = None
    ) -> _PrismaModelT:
        """Create a new RevokedToken record.

        Parameters
        ----------
        data
            RevokedToken record data
        include
            Specifies which relations should be loaded on the returned RevokedToken model

        Returns
        -------
        prisma.models.RevokedToken
            The created RevokedToken record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a RevokedToken record from just the required fields
        revokedtoken = await RevokedToken.prisma().create(
            data={
                # data to create a RevokedToken record
                'jti': 'bajecchdjc',
                'token': 'dfgacajif',
                'expiresAt': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.RevokedTokenCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple RevokedToken records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of RevokedToken record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await RevokedToken.prisma().create_many(
            data=[
                {
                    # data to create a RevokedToken record
                    'jti': 'bgdiddfadi',
                    'token': 'bijbfghhhf',
                    'expiresAt': datetime.datetime.utcnow(),
                },
                {
                    # data to create a RevokedToken record
                    'jti': 'bahchhihdc',
                    'token': 'bihjdcibib',
                    'expiresAt': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.RevokedTokenWhereUniqueInput,
        include: Optional[types.RevokedTokenInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single RevokedToken record.

        Parameters
        ----------
        where
            RevokedToken filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned RevokedToken model

        Returns
        -------
        prisma.models.RevokedToken
            The deleted RevokedToken record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        revokedtoken = await RevokedToken.prisma().delete(
            where={
                'id': 1577911370,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.RevokedTokenWhereUniqueInput,
        include: Optional[types.RevokedTokenInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique RevokedToken record.

        Parameters
        ----------
        where
            RevokedToken filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned RevokedToken model

        Returns
        -------
        prisma.models.RevokedToken
            The found RevokedToken record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        revokedtoken = await RevokedToken.prisma().find_unique(
            where={
                'id': 504729531,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.RevokedTokenWhereUniqueInput,
        include: Optional[types.RevokedTokenInclude] = None
    ) -> _PrismaModelT:
        """Find a unique RevokedToken record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            RevokedToken filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned RevokedToken model

        Returns
        -------
        prisma.models.RevokedToken
            The found RevokedToken record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        revokedtoken = await RevokedToken.prisma().find_unique_or_raise(
            where={
                'id': 110845144,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RevokedTokenWhereInput] = None,
        cursor: Optional[types.RevokedTokenWhereUniqueInput] = None,
        include: Optional[types.RevokedTokenInclude] = None,
        order: Optional[Union[types.RevokedTokenOrderByInput, List[types.RevokedTokenOrderByInput]]] = None,
        distinct: Optional[List[types.RevokedTokenScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple RevokedToken records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of RevokedToken records returned
        skip
            Ignore the first N results
        where
            RevokedToken filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned RevokedToken model
        order
            Order the returned RevokedToken records by any field
        distinct
            Filter RevokedToken records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.RevokedToken]
            The list of all RevokedToken records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 RevokedToken records
        revokedtokens = await RevokedToken.prisma().find_many(take=10)

        # find the first 5 RevokedToken records ordered by the token field
        revokedtokens = await RevokedToken.prisma().find_many(
            take=5,
            order={
                'token': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.RevokedTokenWhereInput] = None,
        cursor: Optional[types.RevokedTokenWhereUniqueInput] = None,
        include: Optional[types.RevokedTokenInclude] = None,
        order: Optional[Union[types.RevokedTokenOrderByInput, List[types.RevokedTokenOrderByInput]]] = None,
        distinct: Optional[List[types.RevokedTokenScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single RevokedToken record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            RevokedToken filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned RevokedToken model
        order
            Order the returned RevokedToken records by any field
        distinct
            Filter RevokedToken records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.RevokedToken
            The first RevokedToken record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second RevokedToken record ordered by the reason field
        revokedtoken = await RevokedToken.prisma().find_first(
            skip=1,
            order={
                'reason': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.RevokedTokenWhereInput] = None,
        cursor: Optional[types.RevokedTokenWhereUniqueInput] = None,
        include: Optional[types.RevokedTokenInclude] = None,
        order: Optional[Union[types.RevokedTokenOrderByInput, List[types.RevokedTokenOrderByInput]]] = None,
        distinct: Optional[List[types.RevokedTokenScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single RevokedToken record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            RevokedToken filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned RevokedToken model
        order
            Order the returned RevokedToken records by any field
        distinct
            Filter RevokedToken records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.RevokedToken
            The first RevokedToken record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second RevokedToken record ordered by the expiresAt field
        revokedtoken = await RevokedToken.prisma().find_first_or_raise(
            skip=1,
            order={
                'expiresAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.RevokedTokenUpdateInput,
        where: types.RevokedTokenWhereUniqueInput,
        include: Optional[types.RevokedTokenInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single RevokedToken record.

        Parameters
        ----------
        data
            RevokedToken record data specifying what to update
        where
            RevokedToken filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned RevokedToken model

        Returns
        -------
        prisma.models.RevokedToken
            The updated RevokedToken record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        revokedtoken = await RevokedToken.prisma().update(
            where={
                'id': 1300269105,
            },
            data={
                # data to update the RevokedToken record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.RevokedTokenWhereUniqueInput,
        data: types.RevokedTokenUpsertInput,
        include: Optional[types.RevokedTokenInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            RevokedToken filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned RevokedToken model

        Returns
        -------
        prisma.models.RevokedToken
            The created or updated RevokedToken record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        revokedtoken = await RevokedToken.prisma().upsert(
            where={
                'id': 1881086742,
            },
            data={
                'create': {
                    'id': 1881086742,
                    'jti': 'bahchhihdc',
                    'token': 'bihjdcibib',
                    'expiresAt': datetime.datetime.utcnow(),
                },
                'update': {
                    'jti': 'bahchhihdc',
                    'token': 'bihjdcibib',
                    'expiresAt': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.RevokedTokenUpdateManyMutationInput,
        where: types.RevokedTokenWhereInput,
    ) -> int:
        """Update multiple RevokedToken records

        Parameters
        ----------
        data
            RevokedToken data to update the selected RevokedToken records to
        where
            Filter to select the RevokedToken records to update

        Returns
        -------
        int
            The total number of RevokedToken records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all RevokedToken records
        total = await RevokedToken.prisma().update_many(
            data={
                'revokedBy': 1082354839
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RevokedTokenWhereInput] = None,
        cursor: Optional[types.RevokedTokenWhereUniqueInput] = None,
    ) -> int:
        """Count the number of RevokedToken records present in the database

        Parameters
        ----------
        select
            Select the RevokedToken fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            RevokedToken filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.RevokedTokenCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await RevokedToken.prisma().count()

        # results: prisma.types.RevokedTokenCountAggregateOutput
        results = await RevokedToken.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.RevokedTokenCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RevokedTokenWhereInput] = None,
        cursor: Optional[types.RevokedTokenWhereUniqueInput] = None,
    ) -> types.RevokedTokenCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.RevokedTokenCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RevokedTokenWhereInput] = None,
        cursor: Optional[types.RevokedTokenWhereUniqueInput] = None,
    ) -> Union[int, types.RevokedTokenCountAggregateOutput]:
        """Count the number of RevokedToken records present in the database

        Parameters
        ----------
        select
            Select the RevokedToken fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            RevokedToken filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.RevokedTokenCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await RevokedToken.prisma().count()

        # results: prisma.types.RevokedTokenCountAggregateOutput
        results = await RevokedToken.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.RevokedTokenCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.RevokedTokenWhereInput] = None
    ) -> int:
        """Delete multiple RevokedToken records.

        Parameters
        ----------
        where
            Optional RevokedToken filter to find the records to be deleted

        Returns
        -------
        int
            The total number of RevokedToken records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all RevokedToken records
        total = await RevokedToken.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.RevokedTokenScalarFieldKeysT'],
        *,
        where: Optional['types.RevokedTokenWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.RevokedTokenAvgAggregateInput'] = None,
        sum: Optional['types.RevokedTokenSumAggregateInput'] = None,
        min: Optional['types.RevokedTokenMinAggregateInput'] = None,
        max: Optional['types.RevokedTokenMaxAggregateInput'] = None,
        having: Optional['types.RevokedTokenScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.RevokedTokenCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.RevokedTokenScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.RevokedTokenScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.RevokedTokenGroupByOutput']:
        """Group RevokedToken records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar RevokedToken fields to group records by
        where
            RevokedToken filter to select records
        take
            Limit the maximum number of RevokedToken records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.RevokedTokenGroupByOutput]
            A list of dictionaries representing the RevokedToken record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group RevokedToken records by jti values
        # and count how many records are in each group
        results = await RevokedToken.prisma().group_by(
            ['jti'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class SystemSettingActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.SystemSetting]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await SystemSetting.prisma().query_raw(
            'SELECT * FROM SystemSetting WHERE id = $1',
            1456828036,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.SystemSetting
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await SystemSetting.prisma().query_first(
            'SELECT * FROM SystemSetting WHERE key = $1',
            'cbcehahedh',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.SystemSettingCreateInput,
        include: Optional[types.SystemSettingInclude] = None
    ) -> _PrismaModelT:
        """Create a new SystemSetting record.

        Parameters
        ----------
        data
            SystemSetting record data
        include
            Specifies which relations should be loaded on the returned SystemSetting model

        Returns
        -------
        prisma.models.SystemSetting
            The created SystemSetting record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a SystemSetting record from just the required fields
        systemsetting = await SystemSetting.prisma().create(
            data={
                # data to create a SystemSetting record
                'key': 'bcjihiaide',
                'value': 'bagfijcgfj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.SystemSettingCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple SystemSetting records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of SystemSetting record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await SystemSetting.prisma().create_many(
            data=[
                {
                    # data to create a SystemSetting record
                    'key': 'bcggehiidc',
                    'value': 'bjcdacgacf',
                },
                {
                    # data to create a SystemSetting record
                    'key': 'jfieeahi',
                    'value': 'bijfjbddfj',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.SystemSettingWhereUniqueInput,
        include: Optional[types.SystemSettingInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single SystemSetting record.

        Parameters
        ----------
        where
            SystemSetting filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned SystemSetting model

        Returns
        -------
        prisma.models.SystemSetting
            The deleted SystemSetting record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        systemsetting = await SystemSetting.prisma().delete(
            where={
                'id': 232393244,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.SystemSettingWhereUniqueInput,
        include: Optional[types.SystemSettingInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique SystemSetting record.

        Parameters
        ----------
        where
            SystemSetting filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned SystemSetting model

        Returns
        -------
        prisma.models.SystemSetting
            The found SystemSetting record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        systemsetting = await SystemSetting.prisma().find_unique(
            where={
                'id': 1116931621,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.SystemSettingWhereUniqueInput,
        include: Optional[types.SystemSettingInclude] = None
    ) -> _PrismaModelT:
        """Find a unique SystemSetting record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            SystemSetting filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned SystemSetting model

        Returns
        -------
        prisma.models.SystemSetting
            The found SystemSetting record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        systemsetting = await SystemSetting.prisma().find_unique_or_raise(
            where={
                'id': 1243026426,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SystemSettingWhereInput] = None,
        cursor: Optional[types.SystemSettingWhereUniqueInput] = None,
        include: Optional[types.SystemSettingInclude] = None,
        order: Optional[Union[types.SystemSettingOrderByInput, List[types.SystemSettingOrderByInput]]] = None,
        distinct: Optional[List[types.SystemSettingScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple SystemSetting records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of SystemSetting records returned
        skip
            Ignore the first N results
        where
            SystemSetting filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned SystemSetting model
        order
            Order the returned SystemSetting records by any field
        distinct
            Filter SystemSetting records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.SystemSetting]
            The list of all SystemSetting records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 SystemSetting records
        systemsettings = await SystemSetting.prisma().find_many(take=10)

        # find the first 5 SystemSetting records ordered by the value field
        systemsettings = await SystemSetting.prisma().find_many(
            take=5,
            order={
                'value': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SystemSettingWhereInput] = None,
        cursor: Optional[types.SystemSettingWhereUniqueInput] = None,
        include: Optional[types.SystemSettingInclude] = None,
        order: Optional[Union[types.SystemSettingOrderByInput, List[types.SystemSettingOrderByInput]]] = None,
        distinct: Optional[List[types.SystemSettingScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single SystemSetting record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            SystemSetting filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned SystemSetting model
        order
            Order the returned SystemSetting records by any field
        distinct
            Filter SystemSetting records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.SystemSetting
            The first SystemSetting record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second SystemSetting record ordered by the createdAt field
        systemsetting = await SystemSetting.prisma().find_first(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SystemSettingWhereInput] = None,
        cursor: Optional[types.SystemSettingWhereUniqueInput] = None,
        include: Optional[types.SystemSettingInclude] = None,
        order: Optional[Union[types.SystemSettingOrderByInput, List[types.SystemSettingOrderByInput]]] = None,
        distinct: Optional[List[types.SystemSettingScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single SystemSetting record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            SystemSetting filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned SystemSetting model
        order
            Order the returned SystemSetting records by any field
        distinct
            Filter SystemSetting records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.SystemSetting
            The first SystemSetting record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second SystemSetting record ordered by the updatedAt field
        systemsetting = await SystemSetting.prisma().find_first_or_raise(
            skip=1,
            order={
                'updatedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.SystemSettingUpdateInput,
        where: types.SystemSettingWhereUniqueInput,
        include: Optional[types.SystemSettingInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single SystemSetting record.

        Parameters
        ----------
        data
            SystemSetting record data specifying what to update
        where
            SystemSetting filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned SystemSetting model

        Returns
        -------
        prisma.models.SystemSetting
            The updated SystemSetting record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        systemsetting = await SystemSetting.prisma().update(
            where={
                'id': 21355947,
            },
            data={
                # data to update the SystemSetting record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.SystemSettingWhereUniqueInput,
        data: types.SystemSettingUpsertInput,
        include: Optional[types.SystemSettingInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            SystemSetting filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned SystemSetting model

        Returns
        -------
        prisma.models.SystemSetting
            The created or updated SystemSetting record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        systemsetting = await SystemSetting.prisma().upsert(
            where={
                'id': 831237128,
            },
            data={
                'create': {
                    'id': 831237128,
                    'key': 'jfieeahi',
                    'value': 'bijfjbddfj',
                },
                'update': {
                    'key': 'jfieeahi',
                    'value': 'bijfjbddfj',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.SystemSettingUpdateManyMutationInput,
        where: types.SystemSettingWhereInput,
    ) -> int:
        """Update multiple SystemSetting records

        Parameters
        ----------
        data
            SystemSetting data to update the selected SystemSetting records to
        where
            Filter to select the SystemSetting records to update

        Returns
        -------
        int
            The total number of SystemSetting records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all SystemSetting records
        total = await SystemSetting.prisma().update_many(
            data={
                'id': 1024647073
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SystemSettingWhereInput] = None,
        cursor: Optional[types.SystemSettingWhereUniqueInput] = None,
    ) -> int:
        """Count the number of SystemSetting records present in the database

        Parameters
        ----------
        select
            Select the SystemSetting fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            SystemSetting filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SystemSettingCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await SystemSetting.prisma().count()

        # results: prisma.types.SystemSettingCountAggregateOutput
        results = await SystemSetting.prisma().count(
            select={
                '_all': True,
                'key': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.SystemSettingCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SystemSettingWhereInput] = None,
        cursor: Optional[types.SystemSettingWhereUniqueInput] = None,
    ) -> types.SystemSettingCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.SystemSettingCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SystemSettingWhereInput] = None,
        cursor: Optional[types.SystemSettingWhereUniqueInput] = None,
    ) -> Union[int, types.SystemSettingCountAggregateOutput]:
        """Count the number of SystemSetting records present in the database

        Parameters
        ----------
        select
            Select the SystemSetting fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            SystemSetting filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SystemSettingCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await SystemSetting.prisma().count()

        # results: prisma.types.SystemSettingCountAggregateOutput
        results = await SystemSetting.prisma().count(
            select={
                '_all': True,
                'value': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.SystemSettingCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.SystemSettingWhereInput] = None
    ) -> int:
        """Delete multiple SystemSetting records.

        Parameters
        ----------
        where
            Optional SystemSetting filter to find the records to be deleted

        Returns
        -------
        int
            The total number of SystemSetting records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all SystemSetting records
        total = await SystemSetting.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.SystemSettingScalarFieldKeysT'],
        *,
        where: Optional['types.SystemSettingWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.SystemSettingAvgAggregateInput'] = None,
        sum: Optional['types.SystemSettingSumAggregateInput'] = None,
        min: Optional['types.SystemSettingMinAggregateInput'] = None,
        max: Optional['types.SystemSettingMaxAggregateInput'] = None,
        having: Optional['types.SystemSettingScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.SystemSettingCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.SystemSettingScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.SystemSettingScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.SystemSettingGroupByOutput']:
        """Group SystemSetting records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar SystemSetting fields to group records by
        where
            SystemSetting filter to select records
        take
            Limit the maximum number of SystemSetting records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.SystemSettingGroupByOutput]
            A list of dictionaries representing the SystemSetting record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group SystemSetting records by createdAt values
        # and count how many records are in each group
        results = await SystemSetting.prisma().group_by(
            ['createdAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class NotificationActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Notification]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Notification.prisma().query_raw(
            'SELECT * FROM Notification WHERE id = $1',
            414348742,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Notification
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Notification.prisma().query_first(
            'SELECT * FROM Notification WHERE userId = $1',
            1090693511,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.NotificationCreateInput,
        include: Optional[types.NotificationInclude] = None
    ) -> _PrismaModelT:
        """Create a new Notification record.

        Parameters
        ----------
        data
            Notification record data
        include
            Specifies which relations should be loaded on the returned Notification model

        Returns
        -------
        prisma.models.Notification
            The created Notification record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Notification record from just the required fields
        notification = await Notification.prisma().create(
            data={
                # data to create a Notification record
                'userId': 1664319668,
                'title': 'hgbafifcf',
                'message': 'bejiecfecg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.NotificationCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Notification records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Notification record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Notification.prisma().create_many(
            data=[
                {
                    # data to create a Notification record
                    'userId': 1960204067,
                    'title': 'beeaihbefg',
                    'message': 'bfbfgeddfd',
                },
                {
                    # data to create a Notification record
                    'userId': 916748190,
                    'title': 'eejajbid',
                    'message': 'efhdcdaie',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.NotificationWhereUniqueInput,
        include: Optional[types.NotificationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Notification record.

        Parameters
        ----------
        where
            Notification filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Notification model

        Returns
        -------
        prisma.models.Notification
            The deleted Notification record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        notification = await Notification.prisma().delete(
            where={
                'id': 2034942613,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.NotificationWhereUniqueInput,
        include: Optional[types.NotificationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Notification record.

        Parameters
        ----------
        where
            Notification filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Notification model

        Returns
        -------
        prisma.models.Notification
            The found Notification record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        notification = await Notification.prisma().find_unique(
            where={
                'id': 1079799722,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.NotificationWhereUniqueInput,
        include: Optional[types.NotificationInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Notification record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Notification filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Notification model

        Returns
        -------
        prisma.models.Notification
            The found Notification record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        notification = await Notification.prisma().find_unique_or_raise(
            where={
                'id': 417171355,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.NotificationWhereInput] = None,
        cursor: Optional[types.NotificationWhereUniqueInput] = None,
        include: Optional[types.NotificationInclude] = None,
        order: Optional[Union[types.NotificationOrderByInput, List[types.NotificationOrderByInput]]] = None,
        distinct: Optional[List[types.NotificationScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Notification records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Notification records returned
        skip
            Ignore the first N results
        where
            Notification filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Notification model
        order
            Order the returned Notification records by any field
        distinct
            Filter Notification records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Notification]
            The list of all Notification records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Notification records
        notifications = await Notification.prisma().find_many(take=10)

        # find the first 5 Notification records ordered by the type field
        notifications = await Notification.prisma().find_many(
            take=5,
            order={
                'type': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.NotificationWhereInput] = None,
        cursor: Optional[types.NotificationWhereUniqueInput] = None,
        include: Optional[types.NotificationInclude] = None,
        order: Optional[Union[types.NotificationOrderByInput, List[types.NotificationOrderByInput]]] = None,
        distinct: Optional[List[types.NotificationScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Notification record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Notification filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Notification model
        order
            Order the returned Notification records by any field
        distinct
            Filter Notification records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Notification
            The first Notification record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Notification record ordered by the title field
        notification = await Notification.prisma().find_first(
            skip=1,
            order={
                'title': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.NotificationWhereInput] = None,
        cursor: Optional[types.NotificationWhereUniqueInput] = None,
        include: Optional[types.NotificationInclude] = None,
        order: Optional[Union[types.NotificationOrderByInput, List[types.NotificationOrderByInput]]] = None,
        distinct: Optional[List[types.NotificationScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Notification record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Notification filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Notification model
        order
            Order the returned Notification records by any field
        distinct
            Filter Notification records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Notification
            The first Notification record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Notification record ordered by the message field
        notification = await Notification.prisma().find_first_or_raise(
            skip=1,
            order={
                'message': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.NotificationUpdateInput,
        where: types.NotificationWhereUniqueInput,
        include: Optional[types.NotificationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Notification record.

        Parameters
        ----------
        data
            Notification record data specifying what to update
        where
            Notification filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Notification model

        Returns
        -------
        prisma.models.Notification
            The updated Notification record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        notification = await Notification.prisma().update(
            where={
                'id': 1384523576,
            },
            data={
                # data to update the Notification record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.NotificationWhereUniqueInput,
        data: types.NotificationUpsertInput,
        include: Optional[types.NotificationInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Notification filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Notification model

        Returns
        -------
        prisma.models.Notification
            The created or updated Notification record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        notification = await Notification.prisma().upsert(
            where={
                'id': 274854673,
            },
            data={
                'create': {
                    'id': 274854673,
                    'userId': 916748190,
                    'title': 'eejajbid',
                    'message': 'efhdcdaie',
                },
                'update': {
                    'userId': 916748190,
                    'title': 'eejajbid',
                    'message': 'efhdcdaie',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.NotificationUpdateManyMutationInput,
        where: types.NotificationWhereInput,
    ) -> int:
        """Update multiple Notification records

        Parameters
        ----------
        data
            Notification data to update the selected Notification records to
        where
            Filter to select the Notification records to update

        Returns
        -------
        int
            The total number of Notification records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Notification records
        total = await Notification.prisma().update_many(
            data={
                'data': Json({'fgijheefe': True})
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.NotificationWhereInput] = None,
        cursor: Optional[types.NotificationWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Notification records present in the database

        Parameters
        ----------
        select
            Select the Notification fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Notification filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.NotificationCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Notification.prisma().count()

        # results: prisma.types.NotificationCountAggregateOutput
        results = await Notification.prisma().count(
            select={
                '_all': True,
                'read': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.NotificationCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.NotificationWhereInput] = None,
        cursor: Optional[types.NotificationWhereUniqueInput] = None,
    ) -> types.NotificationCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.NotificationCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.NotificationWhereInput] = None,
        cursor: Optional[types.NotificationWhereUniqueInput] = None,
    ) -> Union[int, types.NotificationCountAggregateOutput]:
        """Count the number of Notification records present in the database

        Parameters
        ----------
        select
            Select the Notification fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Notification filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.NotificationCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Notification.prisma().count()

        # results: prisma.types.NotificationCountAggregateOutput
        results = await Notification.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.NotificationCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.NotificationWhereInput] = None
    ) -> int:
        """Delete multiple Notification records.

        Parameters
        ----------
        where
            Optional Notification filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Notification records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Notification records
        total = await Notification.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.NotificationScalarFieldKeysT'],
        *,
        where: Optional['types.NotificationWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.NotificationAvgAggregateInput'] = None,
        sum: Optional['types.NotificationSumAggregateInput'] = None,
        min: Optional['types.NotificationMinAggregateInput'] = None,
        max: Optional['types.NotificationMaxAggregateInput'] = None,
        having: Optional['types.NotificationScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.NotificationCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.NotificationScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.NotificationScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.NotificationGroupByOutput']:
        """Group Notification records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Notification fields to group records by
        where
            Notification filter to select records
        take
            Limit the maximum number of Notification records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.NotificationGroupByOutput]
            A list of dictionaries representing the Notification record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Notification records by updatedAt values
        # and count how many records are in each group
        results = await Notification.prisma().group_by(
            ['updatedAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class StockAdjustmentActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.StockAdjustment]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await StockAdjustment.prisma().query_raw(
            'SELECT * FROM StockAdjustment WHERE id = $1',
            721617527,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.StockAdjustment
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await StockAdjustment.prisma().query_first(
            'SELECT * FROM StockAdjustment WHERE productId = $1',
            1511161572,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.StockAdjustmentCreateInput,
        include: Optional[types.StockAdjustmentInclude] = None
    ) -> _PrismaModelT:
        """Create a new StockAdjustment record.

        Parameters
        ----------
        data
            StockAdjustment record data
        include
            Specifies which relations should be loaded on the returned StockAdjustment model

        Returns
        -------
        prisma.models.StockAdjustment
            The created StockAdjustment record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a StockAdjustment record from just the required fields
        stockadjustment = await StockAdjustment.prisma().create(
            data={
                # data to create a StockAdjustment record
                'productId': 81899341,
                'adjustmentType': enums.AdjustmentType.INCREASE,
                'reason': enums.AdjustmentReason.physical_count,
                'quantityBefore': 2047822338,
                'quantityAfter': 1620791059,
                'adjustmentQty': 1877648720,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.StockAdjustmentCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple StockAdjustment records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of StockAdjustment record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await StockAdjustment.prisma().create_many(
            data=[
                {
                    # data to create a StockAdjustment record
                    'productId': 1361507145,
                    'adjustmentType': enums.AdjustmentType.INCREASE,
                    'reason': enums.AdjustmentReason.physical_count,
                    'quantityBefore': 522978382,
                    'quantityAfter': 1365363055,
                    'adjustmentQty': 1826408060,
                },
                {
                    # data to create a StockAdjustment record
                    'productId': 509770501,
                    'adjustmentType': enums.AdjustmentType.INCREASE,
                    'reason': enums.AdjustmentReason.physical_count,
                    'quantityBefore': 1548228442,
                    'quantityAfter': 728468875,
                    'adjustmentQty': 107859560,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.StockAdjustmentWhereUniqueInput,
        include: Optional[types.StockAdjustmentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single StockAdjustment record.

        Parameters
        ----------
        where
            StockAdjustment filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned StockAdjustment model

        Returns
        -------
        prisma.models.StockAdjustment
            The deleted StockAdjustment record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        stockadjustment = await StockAdjustment.prisma().delete(
            where={
                'id': 1041547905,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.StockAdjustmentWhereUniqueInput,
        include: Optional[types.StockAdjustmentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique StockAdjustment record.

        Parameters
        ----------
        where
            StockAdjustment filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned StockAdjustment model

        Returns
        -------
        prisma.models.StockAdjustment
            The found StockAdjustment record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        stockadjustment = await StockAdjustment.prisma().find_unique(
            where={
                'id': 1927302950,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.StockAdjustmentWhereUniqueInput,
        include: Optional[types.StockAdjustmentInclude] = None
    ) -> _PrismaModelT:
        """Find a unique StockAdjustment record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            StockAdjustment filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned StockAdjustment model

        Returns
        -------
        prisma.models.StockAdjustment
            The found StockAdjustment record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        stockadjustment = await StockAdjustment.prisma().find_unique_or_raise(
            where={
                'id': 520320871,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.StockAdjustmentWhereInput] = None,
        cursor: Optional[types.StockAdjustmentWhereUniqueInput] = None,
        include: Optional[types.StockAdjustmentInclude] = None,
        order: Optional[Union[types.StockAdjustmentOrderByInput, List[types.StockAdjustmentOrderByInput]]] = None,
        distinct: Optional[List[types.StockAdjustmentScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple StockAdjustment records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of StockAdjustment records returned
        skip
            Ignore the first N results
        where
            StockAdjustment filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned StockAdjustment model
        order
            Order the returned StockAdjustment records by any field
        distinct
            Filter StockAdjustment records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.StockAdjustment]
            The list of all StockAdjustment records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 StockAdjustment records
        stockadjustments = await StockAdjustment.prisma().find_many(take=10)

        # find the first 5 StockAdjustment records ordered by the adjustmentType field
        stockadjustments = await StockAdjustment.prisma().find_many(
            take=5,
            order={
                'adjustmentType': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.StockAdjustmentWhereInput] = None,
        cursor: Optional[types.StockAdjustmentWhereUniqueInput] = None,
        include: Optional[types.StockAdjustmentInclude] = None,
        order: Optional[Union[types.StockAdjustmentOrderByInput, List[types.StockAdjustmentOrderByInput]]] = None,
        distinct: Optional[List[types.StockAdjustmentScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single StockAdjustment record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            StockAdjustment filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned StockAdjustment model
        order
            Order the returned StockAdjustment records by any field
        distinct
            Filter StockAdjustment records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.StockAdjustment
            The first StockAdjustment record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second StockAdjustment record ordered by the reason field
        stockadjustment = await StockAdjustment.prisma().find_first(
            skip=1,
            order={
                'reason': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.StockAdjustmentWhereInput] = None,
        cursor: Optional[types.StockAdjustmentWhereUniqueInput] = None,
        include: Optional[types.StockAdjustmentInclude] = None,
        order: Optional[Union[types.StockAdjustmentOrderByInput, List[types.StockAdjustmentOrderByInput]]] = None,
        distinct: Optional[List[types.StockAdjustmentScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single StockAdjustment record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            StockAdjustment filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned StockAdjustment model
        order
            Order the returned StockAdjustment records by any field
        distinct
            Filter StockAdjustment records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.StockAdjustment
            The first StockAdjustment record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second StockAdjustment record ordered by the quantityBefore field
        stockadjustment = await StockAdjustment.prisma().find_first_or_raise(
            skip=1,
            order={
                'quantityBefore': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.StockAdjustmentUpdateInput,
        where: types.StockAdjustmentWhereUniqueInput,
        include: Optional[types.StockAdjustmentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single StockAdjustment record.

        Parameters
        ----------
        data
            StockAdjustment record data specifying what to update
        where
            StockAdjustment filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned StockAdjustment model

        Returns
        -------
        prisma.models.StockAdjustment
            The updated StockAdjustment record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        stockadjustment = await StockAdjustment.prisma().update(
            where={
                'id': 1132816660,
            },
            data={
                # data to update the StockAdjustment record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.StockAdjustmentWhereUniqueInput,
        data: types.StockAdjustmentUpsertInput,
        include: Optional[types.StockAdjustmentInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            StockAdjustment filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned StockAdjustment model

        Returns
        -------
        prisma.models.StockAdjustment
            The created or updated StockAdjustment record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        stockadjustment = await StockAdjustment.prisma().upsert(
            where={
                'id': 1061815741,
            },
            data={
                'create': {
                    'id': 1061815741,
                    'productId': 509770501,
                    'adjustmentType': enums.AdjustmentType.INCREASE,
                    'reason': enums.AdjustmentReason.physical_count,
                    'quantityBefore': 1548228442,
                    'quantityAfter': 728468875,
                    'adjustmentQty': 107859560,
                },
                'update': {
                    'productId': 509770501,
                    'adjustmentType': enums.AdjustmentType.INCREASE,
                    'reason': enums.AdjustmentReason.physical_count,
                    'quantityBefore': 1548228442,
                    'quantityAfter': 728468875,
                    'adjustmentQty': 107859560,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.StockAdjustmentUpdateManyMutationInput,
        where: types.StockAdjustmentWhereInput,
    ) -> int:
        """Update multiple StockAdjustment records

        Parameters
        ----------
        data
            StockAdjustment data to update the selected StockAdjustment records to
        where
            Filter to select the StockAdjustment records to update

        Returns
        -------
        int
            The total number of StockAdjustment records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all StockAdjustment records
        total = await StockAdjustment.prisma().update_many(
            data={
                'quantityAfter': 1836201906
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.StockAdjustmentWhereInput] = None,
        cursor: Optional[types.StockAdjustmentWhereUniqueInput] = None,
    ) -> int:
        """Count the number of StockAdjustment records present in the database

        Parameters
        ----------
        select
            Select the StockAdjustment fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            StockAdjustment filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.StockAdjustmentCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await StockAdjustment.prisma().count()

        # results: prisma.types.StockAdjustmentCountAggregateOutput
        results = await StockAdjustment.prisma().count(
            select={
                '_all': True,
                'adjustmentQty': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.StockAdjustmentCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.StockAdjustmentWhereInput] = None,
        cursor: Optional[types.StockAdjustmentWhereUniqueInput] = None,
    ) -> types.StockAdjustmentCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.StockAdjustmentCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.StockAdjustmentWhereInput] = None,
        cursor: Optional[types.StockAdjustmentWhereUniqueInput] = None,
    ) -> Union[int, types.StockAdjustmentCountAggregateOutput]:
        """Count the number of StockAdjustment records present in the database

        Parameters
        ----------
        select
            Select the StockAdjustment fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            StockAdjustment filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.StockAdjustmentCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await StockAdjustment.prisma().count()

        # results: prisma.types.StockAdjustmentCountAggregateOutput
        results = await StockAdjustment.prisma().count(
            select={
                '_all': True,
                'notes': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.StockAdjustmentCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.StockAdjustmentWhereInput] = None
    ) -> int:
        """Delete multiple StockAdjustment records.

        Parameters
        ----------
        where
            Optional StockAdjustment filter to find the records to be deleted

        Returns
        -------
        int
            The total number of StockAdjustment records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all StockAdjustment records
        total = await StockAdjustment.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.StockAdjustmentScalarFieldKeysT'],
        *,
        where: Optional['types.StockAdjustmentWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.StockAdjustmentAvgAggregateInput'] = None,
        sum: Optional['types.StockAdjustmentSumAggregateInput'] = None,
        min: Optional['types.StockAdjustmentMinAggregateInput'] = None,
        max: Optional['types.StockAdjustmentMaxAggregateInput'] = None,
        having: Optional['types.StockAdjustmentScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.StockAdjustmentCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.StockAdjustmentScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.StockAdjustmentScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.StockAdjustmentGroupByOutput']:
        """Group StockAdjustment records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar StockAdjustment fields to group records by
        where
            StockAdjustment filter to select records
        take
            Limit the maximum number of StockAdjustment records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.StockAdjustmentGroupByOutput]
            A list of dictionaries representing the StockAdjustment record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group StockAdjustment records by referenceNumber values
        # and count how many records are in each group
        results = await StockAdjustment.prisma().group_by(
            ['referenceNumber'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]



def _select_fields(root: str, select: Mapping[str, Any]) -> str:
    """Helper to build a GraphQL selection string

    This is a work around until field selection is added to the query builder.
    """

    return root + ' {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))


from . import models